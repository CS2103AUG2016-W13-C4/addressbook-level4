# A0093960X
###### \java\seedu\address\history\InputHistory.java
``` java
/**
 * API of the InputHistory component
 */
public interface InputHistory {

    /**
     * Updates the input history with the given userInput String and resets the
     * input history to the latest input state
     * 
     * @param input the input to update the input history with
     */
    public void updateInputHistory(String input);

    /**
     * Returns whether we are already at the earliest input state (no more
     * previous input in memory to backtrack to)
     * 
     * @return boolean representing whether we are already at the earliest input
     *         of the input history
     */
    public boolean isEarliestInput();

    /**
     * Returns whether we are already at the latest input state (no more later
     * input in memory to move forward to)
     * 
     * @return boolean representing whether we are already at the latest input
     *         of the input history
     */
    public boolean isLatestInput();

    /**
     * Executes the action to get the next input from the input history
     * 
     * @return the next input String from the input history
     */
    public String nextStep();

    /**
     * Executes the action to get the previous input from the input history,
     * storing the current input if currently at the latest input state
     * 
     * @param currentInput the current input
     * @return the previous input String from the input history
     */
    public String prevStep(String currentInput);
}
```
###### \java\seedu\address\history\InputHistoryManager.java
``` java
/**
 * Stores the history of user inputs for navigating previous and next user
 * inputs.
 */
public class InputHistoryManager implements InputHistory {

    private static InputHistoryManager theInputHistoryManager;

    // command inputs
    private Stack<String> prevInputs;
    private Stack<String> nextInputs;
    private String currentStoredInputShown;
    
    private static final String STRING_EMPTY = "";


    // Private constructor for Singleton Pattern
    private InputHistoryManager() {
        prevInputs = new Stack<String>();
        nextInputs = new Stack<String>();
        resetCurrentStoredInputShown();
    }

    // Use Singleton Pattern here
    public static InputHistoryManager getInstance() {
        if (theInputHistoryManager == null) {
            theInputHistoryManager = new InputHistoryManager();
        }
        return theInputHistoryManager;
    }

    @Override
    public void updateInputHistory(String userInput) {
        assert prevInputs != null && nextInputs != null && currentStoredInputShown != null;

        if (!isLatestInput()) {
            pushToPrevInput(currentStoredInputShown);
        }

        resetInputHistoryToLatestState();
        pushToPrevInput(userInput);
        resetCurrentStoredInputShown();
    }

    private void resetCurrentStoredInputShown() {
        currentStoredInputShown = STRING_EMPTY;
    }

    @Override
    public boolean isEarliestInput() {
        assert prevInputs != null;
        return prevInputs.isEmpty();
    }

    @Override
    public boolean isLatestInput() {
        assert nextInputs != null;
        return nextInputs.isEmpty();
    }

    @Override
    public String prevStep(String currentInput) {
        String inputToStore;

        if (isLatestInput()) {
            inputToStore = currentInput;
        } else {
            inputToStore = currentStoredInputShown;
        }

        pushToNextInput(inputToStore);
        return popFromPrevInput();
    }

    @Override
    public String nextStep() {
        pushToPrevInput(currentStoredInputShown);
        return popFromNextInput();
    }

    // private helper methods below

    /**
     * Resets the previous and next input history to the latest state,
     * transferring all the valid next input into the previous input history.
     */
    private void resetInputHistoryToLatestState() {

        boolean isEarliestNextInputValid = isLatestInput();
        String nextInputToTransfer;

        while (!isLatestInput()) {
            nextInputToTransfer = popFromNextInput();
            pushToPrevInput(nextInputToTransfer);
        }

        if (!isEarliestNextInputValid) {
            popFromPrevInput();
        }
    }

    /**
     * Pops and returns the last stored previous input from the previous input
     * history. The caller should ensure that the previous input history is not
     * empty.
     * 
     * @return the last stored previous input String
     */
    private String popFromPrevInput() {
        assert prevInputs != null && prevInputs.size() > 0;
        currentStoredInputShown = prevInputs.pop();
        return currentStoredInputShown;
    }

    /**
     * Pops and returns the last stored next input from the next input history.
     * The caller should ensure that the next input history is not empty.
     * 
     * @return the last stored next input String
     */
    private String popFromNextInput() {
        assert nextInputs != null && nextInputs.size() > 0;
        currentStoredInputShown = nextInputs.pop();
        return currentStoredInputShown;
    }

    /**
     * Pushes the given input into the previous input history.
     */
    private void pushToPrevInput(String input) {
        assert prevInputs != null;
        prevInputs.push(input);
    }

    /**
     * Pushes the given input into the next input history.
     */
    private void pushToNextInput(String input) {
        assert nextInputs != null;
        nextInputs.push(input);
    }

}
```
###### \java\seedu\address\history\UndoableCommandHistory.java
``` java
/**
 * API of the UndoableCommandHistory Component.
 */
public interface UndoableCommandHistory {

    /**
     * Updates the UndoableCommand history with the given UndoableCommand
     * 
     * @param undoableCommand the UndoableCommand to update the history with
     */
    public void updateCommandHistory(UndoableCommand undoableCommand);

    /**
     * Returns whether we are already at the earliest command state (there is
     * nothing to undo anymore)
     * 
     * @return boolean representing whether we are already at the earliest
     *         command of the undoable command history
     */
    public boolean isEarliestCommand();

    /**
     * Returns whether we are already at the latest command state (there is
     * nothing to redo anymore)
     * 
     * @return boolean representing whether we are already at the latest command
     *         of the redoable command history
     */
    public boolean isLatestCommand();

    /**
     * Executes an undo step on the command history, returning the
     * UndoableCommand that was undone
     * 
     * @return the UndoableCommand that was undone
     */
    public UndoableCommand undoStep();

    /**
     * Executes a redo step on the command history, returning the
     * UndoableCommand that was redone
     * 
     * @return the UndoableCommand that was redone
     */
    public UndoableCommand redoStep();

}
```
###### \java\seedu\address\history\UndoableCommandHistoryManager.java
``` java
/**
 * Stores the history of undoable and redoable commands.
 */
public class UndoableCommandHistoryManager implements UndoableCommandHistory {

    private static UndoableCommandHistoryManager theUndoableCommandHistory;

    // command effects
    private Stack<UndoableCommand> undoableCommands;
    private Stack<UndoableCommand> redoableCommands;

    // Private constructor for Singleton Pattern
    private UndoableCommandHistoryManager() {
        undoableCommands = new Stack<UndoableCommand>();
        redoableCommands = new Stack<UndoableCommand>();
    }

    // Use Singleton Pattern here
    public static UndoableCommandHistoryManager getInstance() {
        if (theUndoableCommandHistory == null) {
            theUndoableCommandHistory = new UndoableCommandHistoryManager();
        }
        return theUndoableCommandHistory;
    }

    @Override
    public void updateCommandHistory(UndoableCommand undoableCommand) {
        assert undoableCommands != null;
        undoableCommands.push(undoableCommand);
        resetRedo();
    }

    @Override
    public boolean isEarliestCommand() {
        assert undoableCommands != null;
        return undoableCommands.isEmpty();
    }

    @Override
    public boolean isLatestCommand() {
        assert redoableCommands != null;
        return redoableCommands.isEmpty();
    }

    @Override
    public UndoableCommand undoStep() {
        assert redoableCommands != null && undoableCommands != null;

        UndoableCommand undoneCmd = undoableCommands.pop();
        return redoableCommands.push(undoneCmd);
    }

    @Override
    public UndoableCommand redoStep() {
        assert redoableCommands != null && undoableCommands != null;

        UndoableCommand redoneCmd = redoableCommands.pop();
        return undoableCommands.push(redoneCmd);
    }

    /**
     * Resets the redoable command history
     */
    private void resetRedo() {
        redoableCommands = new Stack<UndoableCommand>();
    }

}
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    public static final String MESSAGE_SUCCESS = "New item added: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS = "Undid add item: %1$s";
    private static final String MESSAGE_UNDO_FAILURE = "Failed to undo last add command: add %1$s";

    public static final String TOOL_TIP = "[add] NAME [start DATE_TIME] [end DATE_TIME] [repeat every RECURRING_INTERVAL] [-PRIORITY]";

```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    @Override
    public CommandResult execute() {
        assert model != null && toAdd != null;

        if (attemptToExecuteAddOnDoneList()) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_DONE_LIST_RESTRICTION);
        }

        model.addTask(toAdd);
        updateHistory();
        return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
    }

    private boolean attemptToExecuteAddOnDoneList() {
        return model.isCurrentListDoneList() && !isRedoAction;
    }

    @Override
    public CommandResult undo() {
        assert model != null && toAdd != null;

        try {
            model.deleteUndoneTask(toAdd);
        } catch (TaskNotFoundException e) {
            return new CommandResult(String.format(MESSAGE_UNDO_FAILURE, toAdd));
        }

        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, toAdd));

    }
    
```
###### \java\seedu\address\logic\commands\ClearCommand.java
``` java
/**
 * Clears the address book.
 */
public class ClearCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ":\n" + "Clears the current view of the task manager.\n\t"
            + "Example: " + COMMAND_WORD;

    public static final String TOOL_TIP = "clear";
    public static final String MESSAGE_SUCCESS_UNDONE_LIST = "Task Manager undone list has been cleared!";
    public static final String MESSAGE_SUCCESS_DONE_LIST = "Task Manager done list has been cleared!";
    public static final String MESSAGE_UNDO_SUCCESS = "Undid the clear command! Cleared tasks from the %1$s list have been restored!";

    private ObservableList<Task> clearedTasks;
    private boolean isTargetDoneList;

    public ClearCommand() {
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        if (!isRedoAction) {
            updateTargetList();
        }

        updateHistory();
        if (isTargetDoneList) {
            saveAndClearDoneList();
            return new CommandResult(MESSAGE_SUCCESS_DONE_LIST);
        } else {
            saveAndClearUndoneList();
            return new CommandResult(MESSAGE_SUCCESS_UNDONE_LIST);
        }

    }

    private void updateTargetList() {
        isTargetDoneList = model.isCurrentListDoneList();
    }

    private void saveAndClearUndoneList() {
        clearedTasks = model.getTaskManagerUndoneList();
        model.clearTaskManagerUndoneList();
    }

    private void saveAndClearDoneList() {
        clearedTasks = model.getTaskManagerDoneList();
        model.clearTaskManagerDoneList();
    }

    @Override
    public CommandResult undo() {
        assert model != null && clearedTasks != null;

        if (isTargetDoneList) {
            model.setTaskManagerDoneList(clearedTasks);
            return new CommandResult(MESSAGE_SUCCESS_DONE_LIST);
        } else {
            model.setTaskManagerUndoneList(clearedTasks);
            return new CommandResult(MESSAGE_SUCCESS_UNDONE_LIST);
        }

    }

}
```
###### \java\seedu\address\logic\commands\DeleteCommand.java
``` java
    public static final String TOOL_TIP = "delete INDEX [ANOTHER_INDEX ...]";

    public static final String MESSAGE_UNDO_SUCCESS = "Undid delete on tasks! %1$s Tasks restored!";
    
```
###### \java\seedu\address\logic\commands\DeleteCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null && targetTasks != null;    
        
        if (isViewingDoneList) {
            undoDeletedDoneTasks();
        }
        else {
            undoDeletedUndoneTasks();

        }
        
        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, targetTasks));
    }
```
###### \java\seedu\address\logic\commands\DoneCommand.java
``` java
    @Override
    public CommandResult undo() {
        doneTasksUndoFail = new ArrayList<Task>();
        
        for (Task doneTask : targetTasks){
            attemptToDeleteDoneTaskFromDoneList(doneTask);
        }
        
        for (Task readdedRecurTask : readdedRecurringTasks) { 
            attemptToDeleteReaddedRecurTaskFromUndoneList(readdedRecurTask);
        }
        
        readdSuccessfullyUndoneTasks();
        
        if (isSuccessfulInUndoingAllDoneTasks()) {
            return new CommandResult(MESSAGE_DONE_UNDO_SUCCESS);
        }
        else {
            return new CommandResult(String.format(MESSAGE_DONE_UNDO_SOME_FAILURE, doneTasksUndoFail));
        }
    }

    private void readdSuccessfullyUndoneTasks() {
        model.addTasks(targetTasks);

    }

    private void attemptToDeleteReaddedRecurTaskFromUndoneList(Task readdedRecurTask) {
        try {
            model.deleteUndoneTask(readdedRecurTask);
        } catch (TaskNotFoundException e) {
            logger.info("Cannot find task: " + readdedRecurTask + "; adding to list of done task failures to inform user.");
            doneTasksUndoFail.add(readdedRecurTask);
        }
    }

    private void attemptToDeleteDoneTaskFromDoneList(Task doneTask) {
        try {
            model.deleteDoneTask(doneTask);
        } catch (TaskNotFoundException e) {
            logger.info("Cannot find task: " + doneTask + "; adding to list of done task failures to inform user.");
            doneTasksUndoFail.add(doneTask);
        }
    }
    
    private boolean isSuccessfulInUndoingAllDoneTasks() {
        return doneTasksUndoFail.isEmpty();
    }

}
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
    private boolean attemptToEditDoneList() {
        return model.isCurrentListDoneList() && !isRedoAction;
    }

	/**
     * assign previous end date to endDate if user never input one
     * assign endDate as null if user choose to reset end date
     */
    private void assignEndDate() {
        if (endDate == null && toEdit.getEndDate().isPresent()) {
        	endDate = toEdit.getEndDate().get();
        }
        
        if (removeEndDate) {
        	endDate = null;
        }
    }
    
    /**
     * assign previous start date to startDate if user never input one
     * assign startDate as null if user choose to reset end date
     */
    private void assignStartDate() {
        if (startDate == null && toEdit.getStartDate().isPresent()) {
            startDate = toEdit.getStartDate().get();
        }
        
        if (removeStartDate) {
        	startDate = null;
        }
    }

```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
    @Override
    public CommandResult undo() {

        String taskBeforeUndoString = toEdit.toString();

        Name previousTaskName = beforeEdit.getName();
        Optional<Date> previousStartDate = beforeEdit.getStartDate();
        Optional<Date> previousEndDate = beforeEdit.getEndDate();
        Priority previousPriority = beforeEdit.getPriorityValue();
        Optional<RecurrenceRate> previousReccurence = beforeEdit.getRecurrenceRate();

        Date undoStartDate = null;
        Date undoEndDate = null;
        RecurrenceRate undoRecurrenceRate = null;

        if (previousStartDate.isPresent()) {
            undoStartDate = previousStartDate.get();
        }

        if (previousEndDate.isPresent()) {
            undoEndDate = previousEndDate.get();
        }

        if (previousReccurence.isPresent()) {
            undoRecurrenceRate = previousReccurence.get();
        }

        model.editTask(toEdit, previousTaskName, undoStartDate, undoEndDate, previousPriority, undoRecurrenceRate);
        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, taskBeforeUndoString, toEdit));
    }

}
```
###### \java\seedu\address\logic\commands\HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows program usage instructions.\n" + "Example: "
            + COMMAND_WORD;

    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";

    public static final String TOOL_TIP = "help";

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ShowHelpRequestEvent());
        return new CommandResult(SHOWING_HELP_MESSAGE);
    }
}
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
/**
 * Redoes the latest UndoableCommand that was undone.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Reverses the last undo command, reversing the effect on the task manager.\n" + "Example: "
            + COMMAND_WORD;

    public static final String TOOL_TIP = "redo";

    public static final String MESSAGE_FAILURE = "There is nothing to redo.";

    public RedoCommand() {
    }

    @Override
    public CommandResult execute() {
        assert history != null;

        if (history.isLatestCommand()) {
            return new CommandResult(MESSAGE_FAILURE);
        }

        UndoableCommand cmdToRedo = history.redoStep();
        return cmdToRedo.execute();
    }

}
```
###### \java\seedu\address\logic\commands\UndoableCommand.java
``` java
public abstract class UndoableCommand extends Command {

    protected boolean isRedoAction;

    /**
     * Undoes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult undo();

    /**
     * Updates the history of undoable commands with this undoable command, if this
     * command is not a command that was executed as part of a redo command.
     */
    public void updateHistory() {

        if (isRedoAction) {
            return;
        }

        history.updateCommandHistory(this);
        isRedoAction = true;
    }

}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
/**
 * Undoes the latest UndoableCommand that was recorded in the undoable command
 * history.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undoes the last reversible command, reversing the effect on the task manager.\n" + "Example: "
            + COMMAND_WORD;

    public static final String TOOL_TIP = "undo";

    public static final String MESSAGE_FAILURE = "There is nothing to undo.";

    public UndoCommand() {
    }

    @Override
    public CommandResult execute() {
        assert history != null;

        if (history.isEarliestCommand()) {
            return new CommandResult(MESSAGE_FAILURE);
        }

        UndoableCommand cmdToUndo = history.undoStep();
        return cmdToUndo.undo();

    }

}
```
###### \java\seedu\address\logic\parser\CommandParser.java
``` java
    /**
     * Parses an incomplete user input to determine the most appropriate tooltip for the user to see.
     * The tooltip depends on the command that the user is trying to execute (which this parser tries to 
     * determine).
     * 
     * @param userInput user input string
     * @param isViewingDoneList boolean representing if the user's current view is the done task list
     * @return a list of Strings for tooltips
     */
    public String parseForTooltip(String userInput, boolean isViewingDoneList) {
        assert userInput != null;

        String trimmedUserInput = userInput.trim();
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(trimmedUserInput);       
        boolean invalidCommandFormat = !matcher.matches();
        
        if (invalidCommandFormat) {
            return MESSAGE_TOOLTIP_INVALID_COMMAND_FORMAT;
        }    
        
        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");
        boolean shouldInterpretAsNoArgs = commandWord.equals(userInput);
         
        return getTooltip(arguments, commandWord, shouldInterpretAsNoArgs, isViewingDoneList);
    }

    /**
     * Returns the list of tooltips that matches the current user's input.
     * 
     * @param toolTips list of tooltips
     * @param commandWord the user input command word
     * @param shouldInterpretAsNoArgs boolean representing whether user input has no arguments
     */
    private String getTooltip(final String arguments, final String commandWord, boolean shouldInterpretAsNoArgs, boolean isViewingDoneList) { 
        if (isViewingDoneList) {
            return getTooltipForDoneList(commandWord, shouldInterpretAsNoArgs);          
        }
        else {
            return getTooltipForUndoneList(arguments, commandWord, shouldInterpretAsNoArgs);
        }
    }
    
    private String getTooltipForUndoneList(final String arguments, final String commandWord, boolean inputHasNoArgs) {
        // tooltip depends on whether the input command has arguments
        if (inputHasNoArgs) {
            return getTooltipForCmdWithNoArgsUndoneList(arguments, commandWord);
        } else {
            return getTooltipForCmdWithArgsUndoneList(arguments, commandWord);
        }
    }


    private String getTooltipForDoneList(final String commandWord, boolean inputHasNoArgs) {
     // tooltip depends on whether the input command has arguments
        if (inputHasNoArgs) {
            return getTooltipForCmdWithNoArgsDoneList(commandWord);
        } else {
            return getTooltipForCmdWithArgsDoneList(commandWord);
        }
    }

    private String getTooltipForCmdWithNoArgsDoneList(String commandWord) {
        List<String> tooltips = new ArrayList<String>();

        if (StringUtils.startsWith(ClearCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ClearCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(DeleteCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(DeleteCommand.TOOL_TIP);
        }   
        if (StringUtils.startsWith(ExitCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ExitCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(FindCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(FindCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(HelpCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(HelpCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(ListCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ListCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(RedoCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(RedoCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(SelectCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(SelectCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(StoreCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(StoreCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(UndoCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(UndoCommand.TOOL_TIP);
        }
        

        boolean hasNoTooltipMatches = tooltips.isEmpty();
        if (hasNoTooltipMatches) {
            return Messages.MESSAGE_DONE_LIST_RESTRICTED_COMMANDS;
        }

        String combinedTooltip = String.join(NEWLINE_STRING, tooltips);
        return combinedTooltip;
    }
    
    private String getTooltipForCmdWithArgsDoneList(String commandWord) {
        
        if (commandWord.equals(ClearCommand.COMMAND_WORD)) {
            return ClearCommand.TOOL_TIP;
            
        } else if (commandWord.equals(DeleteCommand.COMMAND_WORD)) {
            return DeleteCommand.TOOL_TIP;
            
        } else if (commandWord.equals(ExitCommand.COMMAND_WORD)) {
            return ExitCommand.TOOL_TIP;
            
        } else if (commandWord.equals(FindCommand.COMMAND_WORD)) {
            return FindCommand.TOOL_TIP;
            
        } else if (commandWord.equals(HelpCommand.COMMAND_WORD)) {
            return HelpCommand.TOOL_TIP;
            
        } else if (commandWord.equals(ListCommand.COMMAND_WORD)) {
            return ListCommand.TOOL_TIP;
            
        } else if (commandWord.equals(RedoCommand.COMMAND_WORD)) {
            return RedoCommand.TOOL_TIP;
            
        } else if (commandWord.equals(SelectCommand.COMMAND_WORD)) {
            return SelectCommand.TOOL_TIP;
            
        } else if (commandWord.equals(StoreCommand.COMMAND_WORD)) {
            return StoreCommand.TOOL_TIP;
            
        } else if (commandWord.equals(UndoCommand.COMMAND_WORD)) {
            return UndoCommand.TOOL_TIP;
            
        } else {
            return Messages.MESSAGE_DONE_LIST_RESTRICTED_COMMANDS;    
        }
    }

    
    /**
     * Get the tooltip string appropriate for the current user input that has no arguments.
     * 
     * @param commandWord the command part of the user input
     * @return the tooltip
     */
    private String getTooltipForCmdWithNoArgsUndoneList(final String arguments, final String commandWord) {
        List<String> tooltips = new ArrayList<String>();
        
        if (StringUtils.startsWith(AddCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(AddCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(ClearCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ClearCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(DeleteCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(DeleteCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(DoneCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(DoneCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(EditCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(EditCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(ExitCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ExitCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(FindCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(FindCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(HelpCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(HelpCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(ListCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ListCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(RedoCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(RedoCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(SelectCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(SelectCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(StoreCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(StoreCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(UndoCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(UndoCommand.TOOL_TIP);
        }
          
        if (tooltips.isEmpty()) {
            return prepareAddDetailedTooltip(commandWord + arguments);      
        } 
        
        return String.join(NEWLINE_STRING, tooltips);
    }
    
    /**
     * Get the tooltip string appropriate for the current user input that has arguments.
     * 
     * @param commandWord the command part of the user input
     * @return the tooltip
     */
    private String getTooltipForCmdWithArgsUndoneList(final String arguments, final String commandWord) {        
        if (commandWord.equals(AddCommand.COMMAND_WORD)) {
            return prepareAddDetailedTooltip(arguments);
            
        } else if (commandWord.equals(ClearCommand.COMMAND_WORD)) {
            return ClearCommand.TOOL_TIP;
            
        } else if (commandWord.equals(DeleteCommand.COMMAND_WORD)) {
            return DeleteCommand.TOOL_TIP;
            
        } else if (commandWord.equals(DoneCommand.COMMAND_WORD)) {
            return DoneCommand.TOOL_TIP;
            
        } else if (commandWord.equals(EditCommand.COMMAND_WORD)) {
            return prepareEditDetailedTooltip(arguments);
            
        } else if (commandWord.equals(ExitCommand.COMMAND_WORD)) {
            return ExitCommand.TOOL_TIP;
            
        } else if (commandWord.equals(FindCommand.COMMAND_WORD)) {
            return FindCommand.TOOL_TIP;
            
        } else if (commandWord.equals(HelpCommand.COMMAND_WORD)) {
            return HelpCommand.TOOL_TIP;
            
        } else if (commandWord.equals(ListCommand.COMMAND_WORD)) {
            return ListCommand.TOOL_TIP;
            
        } else if (commandWord.equals(RedoCommand.COMMAND_WORD)) {
            return RedoCommand.TOOL_TIP;
            
        } else if (commandWord.equals(SelectCommand.COMMAND_WORD)) {
            return SelectCommand.TOOL_TIP;
            
        } else if (commandWord.equals(StoreCommand.COMMAND_WORD)) {
            return StoreCommand.TOOL_TIP;
            
        } else if (commandWord.equals(UndoCommand.COMMAND_WORD)) {
            return UndoCommand.TOOL_TIP;
            
        } else {
            // default command is an add command
            return prepareAddDetailedTooltip(commandWord + arguments);
            
        }

    }

    /**
     * @param trimmedArgs
     * @return
     * @throws IllegalValueException
     */
    private String generateEditDetailedTooltip(String trimmedArgs) throws IllegalValueException {
        assert trimmedArgs != null;
        
        String[] splitIndexFromOtherArgs = trimmedArgs.split(STRING_REGEX_ONE_OR_MORE_WHITESPACE);
        String indexToEdit = splitIndexFromOtherArgs[ZERO];
        
        try {
            Integer.parseInt(indexToEdit);
        } catch (NumberFormatException e) {
            return EditCommand.TOOL_TIP + "\n" + "Please enter a number for the index.\n";
        }
        
        String argumentsWithoutIndex;
        if (splitIndexFromOtherArgs.length == 1) {
            argumentsWithoutIndex = splitIndexFromOtherArgs[ZERO];
        } else {
            argumentsWithoutIndex = splitIndexFromOtherArgs[ONE];

        }
        
        String resetField = null;
        String[] resetSplit = argumentsWithoutIndex.split(RESET_KEYWORD);
        
        boolean isResettingStartDate = false, isResettingEndDate = false, isResettingRecurrence = false, 
                isResettingPriority = false;
                    
        HashMap<String, Optional<String>> fieldMap = retrieveEditFieldsFromArgs(resetSplit);
        
        Optional<String> name = fieldMap.get(MAP_NAME);
        Optional<String> startDate = fieldMap.get(MAP_START_DATE);
        Optional<String> endDate = fieldMap.get(MAP_END_DATE);
        Optional<String> rate = fieldMap.get(MAP_RECURRENCE_RATE);
        Optional<String> timePeriod = fieldMap.get(MAP_RECURRENCE_TIME_PERIOD);
        Optional<String> priority = fieldMap.get(MAP_PRIORITY);

        if(resetSplit.length == TWO){
            resetField = resetSplit[ONE];
        }
        
        if (resetField != null) {
            String[] resetFieldNames = resetField.split(STRING_REGEX_ONE_OR_MORE_WHITESPACE);
            
            for (String resetFieldStr : resetFieldNames) {
                if (resetFieldStr.equals(RESET_START_KEYWORD)) {
                    isResettingStartDate = true;
                } else if (resetFieldStr.equals(RESET_END_KEYWORD)) {
                    isResettingEndDate = true;
                } else if (resetFieldStr.equals(RESET_RECURRENCE_KEYWORD)) {
                    isResettingRecurrence = true;
                } else if (resetFieldStr.equals(RESET_PRIORITY_KEYWORD)) {
                    isResettingPriority = true;
                }
            }
        }

                    
        StringBuilder sb = new StringBuilder();
        sb.append(EditCommand.TOOL_TIP);
        sb.append("\n\tEditing task at INDEX " + indexToEdit + ": ");

        if (name.isPresent() && trimmedArgs.length()>1 && !name.get().isEmpty()) {
            sb.append(DETAILED_TOOLTIP_NAME_PREFIX + name.get());
        } else {
            sb.append(DETAILED_TOOLTIP_NAME_PREFIX +  DETAILED_TOOLTIP_NO_CHANGE);
        }
        
        if (isResettingStartDate) {
            sb.append(DETAILED_TOOLTIP_START_DATE_PREFIX + DETAILED_TOOLTIP_RESET);
        } else if (startDate.isPresent()) {
            sb.append(DETAILED_TOOLTIP_START_DATE_PREFIX + startDate.get());
        } else {
            sb.append(DETAILED_TOOLTIP_START_DATE_PREFIX + DETAILED_TOOLTIP_NO_CHANGE);
        }
        
        if (isResettingEndDate) {
            sb.append(DETAILED_TOOLTIP_END_DATE_PREFIX + DETAILED_TOOLTIP_RESET);
        } else if (endDate.isPresent()) {
            sb.append(DETAILED_TOOLTIP_END_DATE_PREFIX + endDate.get());
        } else {
            sb.append(DETAILED_TOOLTIP_END_DATE_PREFIX + DETAILED_TOOLTIP_NO_CHANGE);
        }
        
        if (isResettingRecurrence) {
            sb.append(DETAILED_TOOLTIP_RECURRENCE_SPECIAL_PREFIX + DETAILED_TOOLTIP_RESET);
        } else if (timePeriod.isPresent()) {
            if (rate.isPresent()) {
                String recurRate = rate.get();
                sb.append(DETAILED_TOOLTIP_RECURRENCE_PREFIX + recurRate + STRING_ONE_SPACE + timePeriod.get());
            } else {
                sb.append(DETAILED_TOOLTIP_RECURRENCE_PREFIX + timePeriod.get());
            }
        } else {
            sb.append(DETAILED_TOOLTIP_RECURRENCE_SPECIAL_PREFIX + DETAILED_TOOLTIP_NO_CHANGE);
        }
        
        if (isResettingPriority) {
            sb.append(DETAILED_TOOLTIP_PRIORITY_PREFIX + DETAILED_TOOLTIP_RESET);
        } else if (!priority.get().equals("null")) {
            sb.append(DETAILED_TOOLTIP_PRIORITY_PREFIX + priority.get());
        } else {
            sb.append(DETAILED_TOOLTIP_PRIORITY_PREFIX + DETAILED_TOOLTIP_NO_CHANGE);
        }
        
        return sb.toString();
    }

    /**
     * @param resetSplit
     * @return
     * @throws IllegalValueException
     */
    private HashMap<String, Optional<String>> retrieveEditFieldsFromArgs(String[] resetSplit)
            throws IllegalValueException {
        return new CommandParserHelper().prepareEdit(STRING_ONE_SPACE + resetSplit[ZERO]);
    }

    private String prepareAddDetailedTooltip(final String arguments) {
        try {
            if (arguments.isEmpty()) {
                return AddCommand.TOOL_TIP;
            }
            
            String trimmedArgs = arguments.trim();
            return generateAddDetailedTooltip(trimmedArgs);
        } catch (IllegalValueException e) {
            logger.info("Illegal add arguments passed for detailed tooltip, showing regular add tooltip instead");
            return AddCommand.TOOL_TIP;
        }

    }
    
    private String prepareEditDetailedTooltip(final String arguments) {
        try {
            
            // should not use exceptions for this
            if (arguments.isEmpty()) {
                return EditCommand.TOOL_TIP;
            }
            
            String trimmedArgs = arguments.trim();
            return generateEditDetailedTooltip(trimmedArgs);       
        } catch (IllegalValueException e) {
            logger.info("Illegal edit arguments passed for detailed tooltip, showing regular edit tooltip instead");
            return EditCommand.TOOL_TIP;
        }
    }

    /**
     * @param trimmedArgs
     * @return
     * @throws IllegalValueException
     */
    private String generateAddDetailedTooltip(String trimmedArgs) throws IllegalValueException {
        HashMap<String, Optional<String>> fieldMap = retrieveAddFieldsFromArgs(trimmedArgs);
        
        Optional<String> name = fieldMap.get(MAP_NAME);
        Optional<String> startDate = fieldMap.get(MAP_START_DATE);
        Optional<String> endDate = fieldMap.get(MAP_END_DATE);
        Optional<String> rate = fieldMap.get(MAP_RECURRENCE_RATE);
        Optional<String> timePeriod = fieldMap.get(MAP_RECURRENCE_TIME_PERIOD);
        Optional<String> priority = fieldMap.get(MAP_PRIORITY);
        
        StringBuilder sb = generateAddDetailedTooltipHeader();
        generateAddDetailedTooltipName(name, sb);
        generateAddDetailedTooltipStartDate(startDate, sb);
        generateAddDetailedTooltipEndDate(endDate, sb);
        generateAddDetailedTooltipRecurrence(rate, timePeriod, sb);
        generateAddDetailedTooltipPriority(priority, sb);
        return sb.toString();
    }


    /**
     * Generate the add detailed tooltip header and return it as a StringBuilder.
     * 
     * @return the StringBuilder object containing the add detailed tooltip header
     */
    private StringBuilder generateAddDetailedTooltipHeader() {
        StringBuilder sb = new StringBuilder();
        sb.append(AddCommand.TOOL_TIP);
        sb.append(ADD_DETAILED_TOOLTIP_HEADER);
        return sb;
    }

    /**
     * @param name
     * @param sb
     */
    private void generateAddDetailedTooltipName(Optional<String> name, StringBuilder sb) {
        if (name.isPresent()) {
            sb.append(DETAILED_TOOLTIP_NAME_PREFIX + name.get());
        }
    }

    /**
     * @param startDate
     * @param sb
     */
    private void generateAddDetailedTooltipStartDate(Optional<String> startDate, StringBuilder sb) {
        if (startDate.isPresent()) {
            sb.append(DETAILED_TOOLTIP_START_DATE_PREFIX + startDate.get());
        }
    }

    /**
     * @param endDate
     * @param sb
     */
    private void generateAddDetailedTooltipEndDate(Optional<String> endDate, StringBuilder sb) {
        if (endDate.isPresent()) {
            sb.append(DETAILED_TOOLTIP_END_DATE_PREFIX + endDate.get());
        }
    }

    /**
     * @param rate
     * @param timePeriod
     * @param sb
     */
    private void generateAddDetailedTooltipRecurrence(Optional<String> rate, Optional<String> timePeriod,
            StringBuilder sb) {

        if (!timePeriod.isPresent()) {
            return;
        }

        String timePeriodStr = timePeriod.get();
        if (rate.isPresent()) {
            String recurRate = rate.get();
            sb.append(DETAILED_TOOLTIP_RECURRENCE_PREFIX + recurRate + STRING_ONE_SPACE + timePeriodStr);
        } else {
            sb.append(DETAILED_TOOLTIP_RECURRENCE_PREFIX + timePeriodStr);
        }
    }

    /**
     * @param priority
     * @param sb
     */
    private void generateAddDetailedTooltipPriority(Optional<String> priority, StringBuilder sb) {
        if (priority.isPresent()) {
            sb.append(DETAILED_TOOLTIP_PRIORITY_PREFIX + priority.get());
        }
    }

    /**
     * @param trimmedArgs
     * @return
     * @throws IllegalValueException
     */
    private HashMap<String, Optional<String>> retrieveAddFieldsFromArgs(String trimmedArgs)
            throws IllegalValueException {
        CommandParserHelper cmdParserHelper = new CommandParserHelper();
        return cmdParserHelper.prepareAdd(trimmedArgs);
    }
}
```
###### \java\seedu\address\model\item\ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override
     * .equals) All fields must be equal.
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getPriorityValue().equals(this.getPriorityValue())
                && other.getStartDate().equals(this.getStartDate())
                && other.getEndDate().equals(this.getEndDate())
                && other.getRecurrenceRate().equals(this.getRecurrenceRate()));
    }
       
```
###### \java\seedu\address\model\item\Task.java
``` java
    @Override
    public boolean equals(Object other) {

        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instance of handles null
                && this.isSameStateAs((ReadOnlyTask) other));

    }

    @Override
    public int compareTo(Task other) {

        int compareByDateValue = compareByDate(other);
        if (compareByDateValue != 0) {
            return compareByDateValue;
        }

        if (haveDifferentPriority(other)) {
            return compareByPriorityValue(other);
        } else {
            return compareByTaskName(other);
        }

    }

```
###### \java\seedu\address\model\item\Task.java
``` java
    /**
     * Compares this Task with other Task by date chronologically.
     * The result is a negative integer if this Task object chronologically precedes the argument Task.
     * The result is a positive integer if this Task object chronologically follows the argument Task.
     * The result is zero if the Dates of the Tasks are chronologically equal.
     *  
     * Tasks with at least one type of date (start date only, end date only, both start and end date)
     * will always chronologically precede Tasks without any dates.
     * 
     * If both Tasks have at least one type of date, but are chronologically equal 
     * Example: this Task has an end date that is equal to the start date and end date of another Task
     * Example 2: this Task has a start date that is equal to the end date of another Task
     * 
     * Tasks will be ordered in this manner:
     * 1. Tasks with start dates only
     * 2. Tasks with start dates and end dates
     * 3. Tasks with end dates only
     * 
     * @param other the other Task to compare by Date with
     * @return the value 0 if the argument Task is equal to this Task, a value less than 0 if this Task 
     *         chronologically precedes the argument Task and a value more than 0 
     *         if this Task chronologically follows the argument Task
     */
    private int compareByDate(Task other) {
        
        if (hasNoDateForThisTaskOrOtherTask(other)) {
            return compareTasksWhereOneHasNoDates(other);
            
        } else if (hasOnlyOneDateThisTaskAndOtherTask(other)) {
            return compareTasksWhereBothHaveOneDate(other);
            
        } else if (hasOnlyOneDateForOneTaskAndBothDatesForAnotherTask(other)) {
            return compareTasksWhereOneTaskHasOneDateAndAnotherTaskHasBothDates(other);
            
        } else {
            return compareTasksWithBothStartAndEndDates(other);
        }
    } 
    
    private boolean isStartDatePresent(Task task) {
        return task.startDate != null;
    }
    
    private boolean isEndDatePresent(Task task) {
        return task.endDate != null;
    }
    
    private int getNumDatesForTask(Task task) {
        int count = 0;
        
        if (isStartDatePresent(task)) {
            count++;
        }
        
        if (isEndDatePresent(task)) {
            count++;
        } 
        
        assert (count >= 0) && (count <= 2);
        return count;
    }
    
    private boolean hasNoDates(Task other) {
        return getNumDatesForTask(other) == 0;
    }
    
    private boolean hasOneDate(Task other) {
        return getNumDatesForTask(other) == 1;
    }

    private boolean hasTwoDates(Task other) {
        return getNumDatesForTask(other) == 2;
    }
    
    private boolean hasNoDateForThisTaskOrOtherTask(Task other) {
        return hasNoDates(this) 
                || hasNoDates(other);
    }
    
    private boolean hasNoDateForThisTaskAndOtherTask(Task other) {
        return hasNoDates(this) && hasNoDates(other);
    }
    
    private int compareTasksWhereOneHasNoDates(Task other) {
        if (hasNoDateForThisTaskAndOtherTask(other)) {
            return THIS_CHRONOLOGICALLY_EQUAL_TO_OTHER;
            
        } else if (hasNoDates(this)) {
            return THIS_CHRONOLOGICALLY_AFTER_OTHER;
            
        } else {
            return THIS_CHRONOLOGICALLY_BEFORE_OTHER;
        }
    }

    private boolean hasOnlyOneDateThisTaskAndOtherTask(Task other) {
        return hasOneDate(this) && hasOneDate(other);
    }
    
    private boolean hasStartDateOnlyInThisTaskAndStartDateOnlyInOtherTask(Task other) {
        return isStartDatePresent(this) 
                && !isEndDatePresent(this) 
                && isStartDatePresent(other)
                && !isEndDatePresent(other);
    }

    private boolean hasStartDateOnlyInThisTaskAndEndDateOnlyInOtherTask(Task other) {
        return isStartDatePresent(this) 
                && !isEndDatePresent(this) 
                && !isStartDatePresent(other)
                && isEndDatePresent(other);
    }

    private boolean hasEndDateOnlyInThisTaskAndStartDateOnlyInOtherTask(Task other) {
        return !isStartDatePresent(this) 
                && isEndDatePresent(this) 
                && isStartDatePresent(other)
                && !isEndDatePresent(other);
    }
    
    private int compareTasksWhereBothHaveOneDate(Task other) {
        if (hasStartDateOnlyInThisTaskAndStartDateOnlyInOtherTask(other)) {
            return compareThisTaskStartDateToOtherTaskStartDate(other);
            
        } else if (hasStartDateOnlyInThisTaskAndEndDateOnlyInOtherTask(other)) {
            return compareThisTaskStartDateToOtherTaskEndDate(other);
            
        } else if (hasEndDateOnlyInThisTaskAndStartDateOnlyInOtherTask(other)) {
            return compareThisTaskWithEndDateOnlyAndOtherTaskWithStartDateOnly(other);  
            
        } else {
            return compareThisTaskEndDateToOtherTaskEndDate(other);
        }
    }

    private int compareThisTaskStartDateToOtherTaskStartDate(Task other) {
        return startDate.compareTo(other.startDate);
    }
    
    private int compareThisTaskStartDateToOtherTaskEndDate(Task other) {
        return startDate.compareTo(other.endDate);
    }
    
    private int compareThisTaskEndDateToOtherTaskStartDate(Task other) {
        return endDate.compareTo(other.startDate);
    }

    private int compareThisTaskEndDateToOtherTaskEndDate(Task other) {
        return endDate.compareTo(other.endDate);
    }
    
    private int compareThisTaskWithEndDateOnlyAndOtherTaskWithStartDateOnly(Task other) {
        int compareByDateValue = compareThisTaskEndDateToOtherTaskStartDate(other);
        if (compareByDateValue == THIS_CHRONOLOGICALLY_EQUAL_TO_OTHER) {
            // if dates are equal, put the one with start date in front of one with end date
            return THIS_CHRONOLOGICALLY_AFTER_OTHER;
        }
        return compareByDateValue;
    }
    
    private boolean hasOnlyOneDateForOneTaskAndBothDatesForAnotherTask(Task other) {
        return (hasOneDate(this) && hasTwoDates(other)) || (hasTwoDates(this) && hasOneDate(other));
    }
    
    private boolean hasStartAndEndDateInThisTaskAndStartDateOnlyInOtherTask(Task other) {
        return isStartDatePresent(this) 
                && isEndDatePresent(this) 
                && isStartDatePresent(other)
                && !isEndDatePresent(other);
    }

    private boolean hasStartAndEndDateInThisTaskAndEndDateOnlyInOtherTask(Task other) {
        return isStartDatePresent(this) 
                && isEndDatePresent(this) 
                && !isStartDatePresent(other)
                && isEndDatePresent(other);
    }

    private boolean hasStartDateOnlyInThisTaskAndStartAndEndDateInOtherTask(Task other) {
        return isStartDatePresent(this) 
                && !isEndDatePresent(this) 
                && isStartDatePresent(other)
                && isEndDatePresent(other);
    }

    private int compareTasksWhereOneTaskHasOneDateAndAnotherTaskHasBothDates(Task other) {
        if (hasStartAndEndDateInThisTaskAndStartDateOnlyInOtherTask(other)) {
            return compareThisTaskWithStartAndEndDateAndOtherTaskWithStartDateOnly(other);
            
        } else if (hasStartAndEndDateInThisTaskAndEndDateOnlyInOtherTask(other)) {
            return compareThisTaskWithStartAndEndDateAndOtherTaskWithEndDateOnly(other);
            
        } else if (hasStartDateOnlyInThisTaskAndStartAndEndDateInOtherTask(other)) {
            return compareThisTaskWithStartDateOnlyAndOtherTaskWithStartAndEndDate(other);
            
        } else {
            return compareThisTaskWithEndDateOnlyAndOtherTaskWithStartAndEndDate(other);
        }
    }
    
    private int compareThisTaskWithStartAndEndDateAndOtherTaskWithStartDateOnly(Task other) {
        int compareByDateValue = compareThisTaskStartDateToOtherTaskStartDate(other);
        if (compareByDateValue != THIS_CHRONOLOGICALLY_EQUAL_TO_OTHER) {
            return compareByDateValue;
        }
        
        compareByDateValue = compareThisTaskEndDateToOtherTaskStartDate(other);
        if (compareByDateValue == THIS_CHRONOLOGICALLY_EQUAL_TO_OTHER) {
            // if dates are equal, put the one with start date in front of one with end date
            return THIS_CHRONOLOGICALLY_AFTER_OTHER;
        }
        return compareByDateValue;
    }


    private int compareThisTaskWithStartAndEndDateAndOtherTaskWithEndDateOnly(Task other) {
        int compareByDateValue = compareThisTaskStartDateToOtherTaskEndDate(other);
        if (compareByDateValue != THIS_CHRONOLOGICALLY_EQUAL_TO_OTHER) {
            return compareByDateValue;
        }
        return compareThisTaskEndDateToOtherTaskEndDate(other);
    }
    
    private int compareThisTaskWithStartDateOnlyAndOtherTaskWithStartAndEndDate(Task other) {
        int compareByDateValue = compareThisTaskStartDateToOtherTaskStartDate(other);
        if (compareByDateValue != THIS_CHRONOLOGICALLY_EQUAL_TO_OTHER) {
            return compareByDateValue;
        }

        return compareThisTaskStartDateToOtherTaskEndDate(other);
    }

    private int compareThisTaskWithEndDateOnlyAndOtherTaskWithStartAndEndDate(Task other) {
        int compareByDateValue = compareThisTaskEndDateToOtherTaskStartDate(other);
        if (compareByDateValue != THIS_CHRONOLOGICALLY_EQUAL_TO_OTHER) {
            return compareByDateValue;
        }

        compareByDateValue = compareThisTaskEndDateToOtherTaskEndDate(other);
        if (compareByDateValue == THIS_CHRONOLOGICALLY_EQUAL_TO_OTHER) {
            return THIS_CHRONOLOGICALLY_AFTER_OTHER;
        }
        return compareByDateValue;
    }


    private int compareTasksWithBothStartAndEndDates(Task other) {
        int compareByDateValue = compareThisTaskStartDateToOtherTaskStartDate(other);
        if (compareByDateValue != THIS_CHRONOLOGICALLY_EQUAL_TO_OTHER) {
            return compareByDateValue;
        }
        return compareThisTaskEndDateToOtherTaskEndDate(other);
    }

```
###### \java\seedu\address\storage\XmlAdaptedRecurrenceRate.java
``` java
public class XmlAdaptedRecurrenceRate {

    @XmlElement(required = true)
    private String rate;
    @XmlElement(required = true)
    private String timePeriod;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedRecurrenceRate() {
    }

    /**
     * Converts a given RecurrenceRate into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created
     *            XmlAdaptedRecurrenceRate
     */
    public XmlAdaptedRecurrenceRate(RecurrenceRate source) {
        assert source.getRate() != null && source.getTimePeriod() != null;

        rate = source.getRate().toString();
        timePeriod = source.getTimePeriod().toString();

    }

    /**
     * Converts this jaxb-friendly adapted RecurrenceRate object into the
     * model's RecurrenceRate object.
     *
     * @throws IllegalValueException if there were any data constraints violated
     *             in the adapted recurrence rate
     */
    public RecurrenceRate toModelType() throws IllegalValueException {
        return new RecurrenceRate(this.rate, this.timePeriod);
    }
}
```
###### \java\seedu\address\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    private static SimpleDateFormat dateParser = new SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy");

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String priority;
    @XmlElement
    private String startDate;
    @XmlElement
    private String endDate;
    @XmlElement
    private XmlAdaptedRecurrenceRate recurrenceRate;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {
    }

    /**
     * Converts a given Task into this class for JAXB use. Future changes to
     * this will not affect the created XmlAdaptedTask.
     *
     * @param source the task to convert
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        saveName(source);
        savePriority(source);
        saveStartDateIfPresent(source);
        saveEndDateIfPresent(source);
        saveRecurrenceRateIfPresent(source);
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task
     * object.
     *
     * @throws IllegalValueException if there were any data constraints violated
     *             in the adapted task
     * @throws ParseException
     */
    public Task toModelType() throws IllegalValueException, ParseException {
        Name nameForModel = getNameFromStoredTask();
        Priority priorityForModel = getPriorityFromStoredTask();

        Date startDateForModel = getStartDateFromStoredTask();
        Date endDateForModel = getEndDateFromStoredTask();
        RecurrenceRate recurrenceRateForModel = getRecurrenceRateFromStoredTask();

        return new Task(nameForModel, startDateForModel, endDateForModel, recurrenceRateForModel,
                priorityForModel);
    }

    /**
     * Saves the name of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void saveName(ReadOnlyTask source) {
        name = source.getName().toString();
    }

    /**
     * Saves the priority of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void savePriority(ReadOnlyTask source) {
        String priorityString = source.getPriorityValue().toString();
        priority = priorityString.toLowerCase();
    }

    /**
     * Saves the start date of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void saveStartDateIfPresent(ReadOnlyTask source) {
        boolean hasStartDate = source.getStartDate().isPresent();

        if (hasStartDate) {
            startDate = source.getStartDate().get().toString();
        }
    }

    /**
     * Saves the end date of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void saveEndDateIfPresent(ReadOnlyTask source) {
        boolean hasEndDate = source.getEndDate().isPresent();

        if (hasEndDate) {
            endDate = source.getEndDate().get().toString();
        }
    }

    /**
     * Saves the recurrence rate of the source ReadOnlyTask into the
     * XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void saveRecurrenceRateIfPresent(ReadOnlyTask source) {
        boolean hasRecurrenceRate = source.getRecurrenceRate().isPresent();

        if (hasRecurrenceRate) {
            recurrenceRate = new XmlAdaptedRecurrenceRate(source.getRecurrenceRate().get());
        }
    }

    /**
     * Retrieves the Name associated with the stored task.
     * 
     * @return the Name associated with the stored task
     */
    private Name getNameFromStoredTask() {
        assert name != null;

        return new Name(name);
    }

    /**
     * Retrieves the Priority associated with the stored task. If the priority
     * string in the stored task does not match any valid priority strings, the
     * task will be given a default medium priority.
     * 
     * @return the Priority associated with the stored task
     */
    private Priority getPriorityFromStoredTask() {
        //assert priority != null;
        
        return Priority.convertStringToPriority(priority);
    }

    /**
     * Retrieves the start date Date associated with the stored task. Returns
     * null if there is no start date associated with the stored task.
     * 
     * @return the start date Date associated with the task, or null if no start
     *         date is associated with the current stored task.
     * @throws ParseException if the format of the start date does not conform
     *             to the expected format
     */
    private Date getStartDateFromStoredTask() throws ParseException {
        if (startDate == null) {
            return null;
        }
        return dateParser.parse(startDate);
    }

    /**
     * Retrieves the end date Date associated with the stored task. Returns null
     * if there is no end date associated with the stored task.
     * 
     * @return the end date Date associated with the task, or null if no end
     *         date is associated with the current stored task.
     * @throws ParseException if the format of the end date does not conform to
     *             the expected format
     */
    private Date getEndDateFromStoredTask() throws ParseException {
        if (endDate == null) {
            return null;
        }

        return dateParser.parse(endDate);
    }

    /**
     * Retrieves the ReccurenceRate associated with the stored task. Returns
     * null if there is no recurrence rate associated with the stored task.
     * 
     * @return the RecurrenceRate associated with the task, or null if no
     *         recurrence rate is associated with the current stored task.
     * 
     * @throws IllegalValueException
     * @throws ParseException
     */
    private RecurrenceRate getRecurrenceRateFromStoredTask() throws IllegalValueException {
        if (recurrenceRate == null) {
            return null;
        }

        return recurrenceRate.toModelType();
    }

}
```
###### \java\seedu\address\ui\CommandBox.java
``` java
public class CommandBox extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;
    String previousCommandTest;

    private Logic logic;
    private InputHistory inputHistory;

    private static final String BACKSPACE_UNICODE = "\u0008";
    private static final String SPACE_UNICODE = "\u0020";
    private static final String CARRIAGE_RETURN = "\r";
    private static final String NEW_LINE = "\n";
    private static final String STRING_EMPTY = "";
    private static final String STRING_ONE_SPACE = " ";

    @FXML
    private TextField commandTextField;
    private CommandResult mostRecentResult;

    public static CommandBox load(Stage primaryStage, AnchorPane commandBoxPlaceholder, ResultDisplay resultDisplay,
            Logic logic, InputHistory history) {
        CommandBox commandBox = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new CommandBox());
        commandBox.configure(resultDisplay, logic, history);
        commandBox.addToPlaceholder();
        return commandBox;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic, InputHistory history) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        this.inputHistory = history;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);

        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent keyEvent) {
                switch (keyEvent.getCode()) {
                case UP :
                    // Fallthrough
                case DOWN :
                    keyEvent.consume();
                    handleUpDownArrow(keyEvent);
                    break;
                default :
                    break;
                }
            }
        });

    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    /**
     * Handles the event where the user enters an input in the command box.
     */
    @FXML
    private void handleKeyInput(KeyEvent event) {
        String keyInputAsString = event.getCharacter();

        if (isKeyPressedEnter(keyInputAsString)) {
            return;
        }

        setStyleToIndicateCorrectCommand();
        String userInput = getUserInputAfterKeyPressed(keyInputAsString);
        updateTooltipForUser(userInput);

    }

    private boolean isKeyPressedEnter(String keyInputAsString) {
        // Enter is \r\n on windows, \n on unix
        return keyInputAsString.equals(CARRIAGE_RETURN) || keyInputAsString.equals(NEW_LINE);
    }

    private void handleUpDownArrow(KeyEvent event) {
        KeyCode key = event.getCode();

        setStyleToIndicateCorrectCommand();
        handleInputHistoryNavigation(key);
        String userInput = commandTextField.getText();
        updateTooltipForUser(userInput);
    }

    /**
     * Get the complete user input taking into account the current key pressed
     * as key pressed event is triggered before the command box text is updated.
     * key is either a backspace, space, letter or digit key.
     * 
     * @param keyAsString the key that was pressed as string
     * @return the full user input taking into account the key pressed
     */
    private String getUserInputAfterKeyPressed(String keyAsString) {
        String userSelectedText = commandTextField.getSelectedText();

        if (!userSelectedText.isEmpty()) {
            commandTextField.replaceSelection(STRING_EMPTY);
        }

        String userInput = commandTextField.getText();
        int caretPosition = commandTextField.getCaretPosition();

        switch (keyAsString) {
        case BACKSPACE_UNICODE :
            // backspace action occurs before event triggers, just return the
            // user input
            return userInput;
        case SPACE_UNICODE :
            return applySpaceAtPosition(userInput, caretPosition);
        default :
            // is a normal letter/digit
            return applyKeyAtPosition(userInput, keyAsString, caretPosition);
        }

    }

    /**
     * Returns a string with a single whitespace character appended to the back
     * of the given user input string
     * 
     * @param userInput
     * @return
     */
    private String applySpaceAtPosition(String userInput, int position) {
        String stringBeforeCaret = userInput.substring(0, position);
        String stringAfterCaret = userInput.substring(position);
        return String.join(STRING_ONE_SPACE, stringBeforeCaret, stringAfterCaret);
    }

    /**
     * Returns a string that is the result of adding the given key in the
     * specified position of the string.
     * 
     * @param userInput the user input
     * @param keyAsString the key as a string
     * @param position the position to add the key
     * @return string with key at the specified position in the user input
     *         string
     */
    private String applyKeyAtPosition(String userInput, String keyAsString, int position) {
        String stringBeforeCaret = userInput.substring(0, position);
        String stringAfterCaret = userInput.substring(position);
        return String.join(keyAsString, stringBeforeCaret, stringAfterCaret);
    }

    /**
     * Updates the tooltip on the GUI for the user to see.
     */
    private void updateTooltipForUser(String userInput) {
        String toDisplay = logic.generateToolTip(userInput);
        resultDisplay.postMessage(toDisplay);
    }

    /**
     * Handles the event where the user is trying to navigate the input history.
     * keyCode must either be up or down arrow key.
     * 
     * @param keyCode the keycode associated with this event
     */
    private void handleInputHistoryNavigation(KeyCode keyCode) {
        assert (keyCode == KeyCode.UP) || (keyCode == KeyCode.DOWN);

        // if attempt to get next command while at latest command input or prev
        // while at earliest, return
        if (desiredInputHistoryUnavailable(keyCode)) {
            return;
        }

        if (isAttemptingToGetPrevInput(keyCode)) {
            handleGetPreviousInput();
        } else {
            handleGetNextInput();
        }

        updateCaretPosition();
    }

    /**
     * Returns whether the user is trying to access a previous or next input in
     * the input history but is already at the limit (either earliest history or
     * latest history respectively). The caller should ensure that the KeyCode
     * passed into this method is either an UP or DOWN only.
     * 
     * @param keyCode the KeyCode pressed
     * @return boolean representing the above
     */
    private boolean desiredInputHistoryUnavailable(KeyCode keyCode) {
        assert keyCode == KeyCode.UP || keyCode == KeyCode.DOWN;

        return isAtEarliestHistoryButWantPrevInput(keyCode) || isAtLatestHistoryButWantNextInput(keyCode);
    }

    /**
     * Returns whether the user is already at the latest input history state but
     * wants to access a next input.
     * 
     * @param keyCode the KeyCode pressed
     * @return boolean representing the above
     */
    private boolean isAtLatestHistoryButWantNextInput(KeyCode keyCode) {
        return inputHistory.isLatestInput() && isAttemptingToGetNextInput(keyCode);
    }

    /**
     * Returns whether the user is already at the earliest input history state
     * but wants to access a previous input.
     * 
     * @param keyCode the KeyCode pressed
     * @return boolean representing the above
     */
    private boolean isAtEarliestHistoryButWantPrevInput(KeyCode keyCode) {
        return inputHistory.isEarliestInput() && isAttemptingToGetPrevInput(keyCode);
    }

    /**
     * Updates the caret position to the end of the current text input in the
     * command box.
     */
    private void updateCaretPosition() {
        String currentInputShown = commandTextField.getText();
        int positionAtEndOfString = currentInputShown.length();

        commandTextField.positionCaret(positionAtEndOfString);
    }

    /**
     * Handles the event where the user wants to get the next input from input
     * history.
     */
    private void handleGetNextInput() {
        // store the current input into the prev first
        String nextInput = inputHistory.nextStep();

        // get a next command input and replace current input
        commandTextField.setText(nextInput);
    }

    /**
     * Handles the event where the user wants to get the previous input from
     * input history.
     */
    private void handleGetPreviousInput() {
        // store the current input and get prev input
        String currentInput = commandTextField.getText();
        String prevInput = inputHistory.prevStep(currentInput);

        // show user the prev input
        commandTextField.setText(prevInput);
    }

    /**
     * Returns whether the user wants to get the previous input from input
     * history.
     * 
     * @param keyCode the key the user pressed to trigger the event
     * @return boolean representing the above
     */
    private boolean isAttemptingToGetPrevInput(KeyCode keyCode) {
        return keyCode == KeyCode.UP;
    }

    /**
     * Returns whether the user wants to get the next input from input history.
     * 
     * @param keyCode the key the user pressed to trigger the event
     * @return boolean representing the above
     */
    private boolean isAttemptingToGetNextInput(KeyCode keyCode) {
        return keyCode == KeyCode.DOWN;
    }

    @FXML
    private void handleCommandInputEntered() {
        // Take a copy of the command text
        previousCommandTest = commandTextField.getText();

        // first push back all 'next' commands into 'prev' command
        // immediately add it to the history of command inputs
        inputHistory.updateInputHistory(previousCommandTest);

        /*
         * We assume the command is correct. If it is incorrect, the command box
         * will be changed accordingly in the event handling code {@link
         * #handleIncorrectCommandAttempted}
         */
        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        commandTextField.setText(STRING_EMPTY);
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Invalid command: " + previousCommandTest));
        setStyleToIndicateIncorrectCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandTest);
    }

    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }

}
```
###### \java\seedu\address\ui\HelpWindow.java
``` java
/**
 * Controller for a help page
 */
public class HelpWindow extends UiPart {

    private static final Logger logger = LogsCenter.getLogger(HelpWindow.class);
    private static final String ICON = "/images/help_icon.png";
    private static final String FXML = "HelpWindow.fxml";
    private static final String TITLE = "Help";

    private AnchorPane mainPane;

    private Stage dialogStage;

    public static HelpWindow load(Stage primaryStage) {
        logger.fine("Showing help page about the application.");
        HelpWindow helpWindow = UiPartLoader.loadUiPart(primaryStage, new HelpWindow());
        helpWindow.configure();
        return helpWindow;
    }

    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    private void configure() {
        Scene scene = new Scene(mainPane);
        // Null passed as the parent stage to make it non-modal.
        dialogStage = createDialogStage(TITLE, null, scene);
        setIcon(dialogStage, ICON);

        scene.setOnKeyPressed(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                dialogStage.close();
            }
        });
    }

    public void show() {
        dialogStage.show();
    }

}
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    public void swapTaskList(boolean isDoneList) {
        taskListPanel.reloadLists(logic.getFilteredUndoneTaskList(), logic.getFilteredDoneTaskList(), isDoneList);
    }
    
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage);
        helpWindow.show();
    }

    public void show() {
        primaryStage.show();
    }

```
###### \java\seedu\address\ui\ResultDisplay.java
``` java
/**
 * A ui for the status bar that is displayed at the header of the application.
 */
public class ResultDisplay extends UiPart {

    private static final String NEWLINE_STRING = "\n";
    private static final String STRING_EMPTY = "";
    private static final int HEIGHT_PER_EXTRA_NEWLINE = 17;
    private static final int PREF_HEIGHT = 65;

    public static final String RESULT_DISPLAY_ID = "resultDisplay";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    private final StringProperty displayed = new SimpleStringProperty(STRING_EMPTY);

    private static final String FXML = "ResultDisplay.fxml";

    private TextArea resultDisplayArea;

    private AnchorPane placeHolder;

    private AnchorPane mainPane;

    public static ResultDisplay load(Stage primaryStage, AnchorPane placeHolder) {
        ResultDisplay statusBar = UiPartLoader.loadUiPart(primaryStage, placeHolder, new ResultDisplay());
        statusBar.configure();
        return statusBar;
    }

    public void configure() {
        resultDisplayArea = new TextArea();
        resultDisplayArea.setEditable(false);
        resultDisplayArea.setId(RESULT_DISPLAY_ID);
        resultDisplayArea.getStyleClass().removeAll();
        resultDisplayArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        resultDisplayArea.setText(STRING_EMPTY);
        resultDisplayArea.setWrapText(true);
        resultDisplayArea.textProperty().bind(displayed);
        resultDisplayArea.setPrefHeight(PREF_HEIGHT);

        resultDisplayArea.textProperty().addListener(e -> {
            int newHeight = computeNewHeight();
            setNewHeight(newHeight);
        });

        FxViewUtil.applyAnchorBoundaryParameters(resultDisplayArea, 0.0, 0.0, 0.0, 0.0);
        mainPane.getChildren().add(resultDisplayArea);
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);

    }

    /**
     * @param newHeight
     */
    private void setNewHeight(int newHeight) {
        resultDisplayArea.setMinHeight(newHeight);
        resultDisplayArea.setPrefHeight(newHeight);
        resultDisplayArea.setMaxHeight(newHeight);
    }

    /**
     * Computes the new height of the result display area by considering the
     * number of newline characters present in the text of the result display
     * area.
     * 
     * @return
     */
    private int computeNewHeight() {
        return PREF_HEIGHT + getNumberOfNewLines() * HEIGHT_PER_EXTRA_NEWLINE;
    }

    /**
     * Returns 
     * @return
     */
    private int getNumberOfNewLines() {
        String displayedText = resultDisplayArea.getText();
        return StringUtils.countMatches(displayedText, NEWLINE_STRING);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public void postMessage(String message) {
        displayed.setValue(message);
    }

}
```
###### \java\seedu\address\ui\SwitchViewButtons.java
``` java
/**
 * The controller for the buttons used to switch list views between showing
 * undone and done tasks.
 */
public class SwitchViewButtons extends UiPart {
    private final Logger logger = LogsCenter.getLogger(SwitchViewButtons.class);
    private static final String FXML = "SwitchViewButtons.fxml";

    private static final String LIST_UNDONE_COMMAND = "list";
    private static final String LIST_DONE_COMMAND = "list done";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;

    private Logic logic;

    @FXML
    private HBox hb;

    @FXML
    private ToggleButton showListUndone;

    @FXML
    private ToggleButton showListDone;

    public static SwitchViewButtons load(Stage primaryStage, AnchorPane commandBoxPlaceholder,
            ResultDisplay resultDisplay, Logic logic, InputHistory history) {
        SwitchViewButtons switchViewButtons = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder,
                new SwitchViewButtons());
        switchViewButtons.configure(resultDisplay, logic);
        switchViewButtons.addToPlaceholder();
        return switchViewButtons;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(hb);
        FxViewUtil.applyAnchorBoundaryParameters(hb, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);

        final ToggleGroup group = new ToggleGroup();
        showListUndone.setToggleGroup(group);
        showListDone.setToggleGroup(group);
        showListUndone.setSelected(true);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    @FXML
    private void switchToListDoneView() {
        logger.info("Show done tasks button pressed. Switching to list done view.");
        CommandResult cmdRes = logic.execute(LIST_DONE_COMMAND);
        resultDisplay.postMessage(cmdRes.feedbackToUser);
    }

    @FXML
    private void switchToListUndoneView() {
        logger.info("Show undone tasks button pressed. Switching to list undone view.");
        CommandResult cmdRes = logic.execute(LIST_UNDONE_COMMAND);
        resultDisplay.postMessage(cmdRes.feedbackToUser);
    }

    @Subscribe
    private void handleChangeToListDoneViewEvent(ChangeToListDoneViewEvent event) {
        logger.info("Request to switch to list done view detected. Toggling the show done tasks button.");
        showListDone.setSelected(true);
    }

    @Subscribe
    private void handleChangeToListUndoneViewEvent(ChangeToListUndoneViewEvent event) {
        logger.info("Request to switch to list undone view detected. Toggling the show undone tasks button.");
        showListUndone.setSelected(true);
    }

}
```
###### \java\seedu\address\ui\TaskCard.java
``` java
public class TaskCard extends UiPart {

    private static final Paint PAINT_RED = Paint.valueOf("red");
    private static final Paint PAINT_GREEN = Paint.valueOf("green");
    private static final Paint PAINT_YELLOW = Paint.valueOf("yellow");

    private static final String RECURRENCE_RATE_DISPLAY_PREFIX = "Every ";
    private static final String END_DATE_DISPLAY_PREFIX = "End: ";
    private static final String START_DATE_DISPLAY_PREFIX = "Start: ";
    private static final String STRING_PLURAL_POSTFIX = "s";
    private static final String STRING_ONE_SPACE = " ";
    private static final String STRING_EMPTY = "";

    private static final int ONE = 1;
    private static final int ZERO = 0;
    private static final String FXML = "TaskListCard.fxml";
    private static final SimpleDateFormat dateFormatter = new SimpleDateFormat("EEE, d MMM yyyy, h:mm a");

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Rectangle priority;
    @FXML
    private Label startDate;
    @FXML
    private Label endDate;
    @FXML
    private Label recurrenceRate;

    private ReadOnlyTask task;
    private int displayedIndex;

    public TaskCard() {

    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex) {
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        assert task != null && task.getName() != null && task.getPriorityValue() != null;

        setTaskCardIndex();
        setTaskCardName();
        setTaskCardPriority();
        setTaskCardStartDate();
        setTaskCardEndDate();
        setTaskCardRecurrence();
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    // private helper methods below

    /**
     * Sets the task card displayed index to its position in the list.
     */
    private void setTaskCardIndex() {
        assert displayedIndex > 0;

        String taskCardId = displayedIndex + ".";
        id.setText(taskCardId);
    }

    /**
     * Sets the task card name to the name of the task of the task it is
     * displaying.
     */
    private void setTaskCardName() {
        assert task != null && task.getName() != null;

        String taskName = task.getName().toString();
        name.setText(taskName);
    }

    /**
     * Sets the task card priority rectangle to the appropriate color depending
     * on the task priority.
     */
    private void setTaskCardPriority() {
        assert task != null && task.getPriorityValue() != null;

        Priority taskPriority = task.getPriorityValue();

        Paint taskPriorityColour = PAINT_YELLOW;

        switch (taskPriority) {
        case LOW :
            taskPriorityColour = PAINT_GREEN;
            break;
        case MEDIUM :
            taskPriorityColour = PAINT_YELLOW;
            break;
        case HIGH :
            taskPriorityColour = PAINT_RED;
            break;
        default :
            assert false : "priority should only be LOW, MEDIUM, or HIGH";
        }

        priority.setFill(taskPriorityColour);
    }

    /**
     * Sets the task card start date to the start date of the task it is
     * displaying.
     */
    private void setTaskCardStartDate() {
        assert task != null;

        String startDateText = STRING_EMPTY;
        boolean hasStartDate = task.getStartDate().isPresent();

        if (hasStartDate) {
            startDateText = prepareStartDateToDisplay();
        }

        startDate.setText(startDateText);
    }

    /**
     * Sets the task card end date to the end date of the task it is displaying.
     */
    private void setTaskCardEndDate() {
        assert task != null;

        String endDateText = STRING_EMPTY;
        boolean hasEndDate = task.getEndDate().isPresent();

        if (hasEndDate) {
            endDateText = prepareEndDateToDisplay();
        }
        endDate.setText(endDateText);
    }

    /**
     * Sets the task card recurrence rate to the recurrence rate of the task it
     * is displaying.
     */
    private void setTaskCardRecurrence() {
        assert task != null;

        String recurrenceRateText = STRING_EMPTY;
        boolean taskIsRecurring = task.getRecurrenceRate().isPresent();

        if (taskIsRecurring) {
            recurrenceRateText = prepareRecurrenceRateToDisplay();
        }

        recurrenceRate.setText(recurrenceRateText);
    }

    /**
     * Prepares the start date for display by converting it into a pretty format
     * as a String.
     * 
     * @return the String representation of the start date for display on the
     *         task card
     */
    private String prepareStartDateToDisplay() {
        assert task != null && task.getStartDate().isPresent();

        Date startDate = task.getStartDate().get();
        return START_DATE_DISPLAY_PREFIX + dateFormatter.format(startDate);
    }

    /**
     * Prepares the end date for display by converting it into a pretty format
     * as a String.
     * 
     * @return the String representation of the end date for display on the task
     *         card
     */
    private String prepareEndDateToDisplay() {
        assert task != null && task.getEndDate().isPresent();

        Date endDate = task.getEndDate().get();
        return END_DATE_DISPLAY_PREFIX + dateFormatter.format(endDate);
    }

    /**
     * Prepares the recurrence rate for display by converting it into a pretty
     * format as a String.
     * 
     * @return the String representation of the recurrence rate for display on
     *         the task card
     */
    private String prepareRecurrenceRateToDisplay() {
        assert task != null && task.getRecurrenceRate().isPresent();

        String recurrenceRateText = task.getRecurrenceRate().get().toString();
        return recurrenceRateText;
    }

}
```
###### \java\seedu\address\ui\UiManager.java
``` java
    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleHelp();
    }

```
###### \resources\view\MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.MainWindow">
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>

       <AnchorPane fx:id="resultDisplayPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="SOMETIMES">

           <padding>
               <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           </padding>
       </AnchorPane>
      <AnchorPane fx:id="switchViewButtonsPlaceholder" styleClass="anchor-pane-with-border">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
      <SplitPane id="splitPane" fx:id="splitPane" VBox.vgrow="ALWAYS">
         <items>
            <VBox fx:id="personList" minWidth="340" prefWidth="340">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                </padding>
               <children>
                  <AnchorPane fx:id="personListPanelPlaceholder" VBox.vgrow="ALWAYS" />
               </children>
            </VBox>
         </items>
      </SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
###### \resources\view\PersonListPanel.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.TaskListPanel">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
        <ListView fx:id="taskListView" style="-fx-background-color: D3D6DB;" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### \resources\view\ResultDisplay.fxml
``` fxml

<?import javafx.scene.layout.AnchorPane?>
<?import java.net.URL?>
<AnchorPane styleClass="anchor-pane-with-border" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1"
            fx:controller="seedu.address.ui.ResultDisplay">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
</AnchorPane>
```
###### \resources\view\SwitchViewButtons.fxml
``` fxml

<?import javafx.scene.control.ToggleButton?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>

<AnchorPane styleClass="anchor-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.SwitchViewButtons">
   <children>
      <HBox fx:id="hb" prefHeight="25.0" prefWidth="200.0">
         <children>
            <ToggleButton fx:id="showListUndone" mnemonicParsing="false" onMouseClicked="#switchToListUndoneView" text="Show Undone Tasks" />
            <ToggleButton fx:id="showListDone" mnemonicParsing="false" onMouseClicked="#switchToListDoneView" text="Show Done Tasks" />
         </children>
      </HBox>
   </children>
</AnchorPane>
```
