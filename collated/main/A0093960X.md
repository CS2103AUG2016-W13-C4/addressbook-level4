# A0093960X
###### /java/seedu/address/commons/util/StringUtil.java
``` java
    /**
     * Returns a string that is the result of adding the specified stringToAdd
     * String at the specified position in the originalString String. <br>
     * If the position is less than 0, the stringToAdd will be added to the
     * front of originalString. <br>
     * If the position is greater than the length of the originalString, the stringToAdd
     * will be added to the back of the originalString. <br>
     * Asserts that the originalString and stringToAdd are not null.
     * 
     * @param originalString The String to add to
     * @param stringToAdd The String to add to the originalString
     * @param position The position in originalString to add the stringToAdd
     * @return The String with the stringToAdd added to in the given position of
     *         the originalString
     */
    public static String applyStringAtPosition(String originalString, String stringToAdd, int position) {
        assert originalString != null && stringToAdd != null;

        boolean isPositionBelowMinimumPosition = (position < 0);
        boolean isPositionAboveMaximumPosition = (position > originalString.length());

        
        if (isPositionBelowMinimumPosition) {
            position = 0;
        }
        else if (isPositionAboveMaximumPosition) {
            position = originalString.length();
        }

        String stringBeforeCaret = originalString.substring(0, position);
        String stringAfterCaret = originalString.substring(position);
        return String.join(stringToAdd, stringBeforeCaret, stringAfterCaret);
    }

```
###### /java/seedu/address/history/InputHistory.java
``` java
/**
 * API of the InputHistory component
 */
public interface InputHistory {

    /**
     * Updates the input history with the given input and resets the input
     * history to the latest input state
     * 
     * @param input The input to update the input history with
     */
    public void updateInputHistory(String input);

    /**
     * Returns whether we are already at the earliest input state (no more
     * previous input in memory to backtrack to)
     * 
     * @return A boolean representing whether we are already at the
     *         earliest input of the input history
     */
    public boolean isEarliestInput();

    /**
     * Returns whether we are already at the latest input state (no more later
     * input in memory to move forward to)
     * 
     * @return A boolean representing whether we are already at the
     *         latest input of the input history
     */
    public boolean isLatestInput();

    /**
     * Executes the action to get the next input from the input history,
     * returning that next input
     * 
     * @return The next input String from the input history
     */
    public String nextStep();

    /**
     * Executes the action to get the previous input from the input history,
     * storing the current input if currently at the latest input state
     * 
     * @param input The input to store if currently at the latest input state
     * @return The previous input String from the input history
     */
    public String prevStep(String input);
}
```
###### /java/seedu/address/history/InputHistoryManager.java
``` java
/**
 * Stores the history of user inputs for navigating previous and next user
 * inputs.
 */
public class InputHistoryManager implements InputHistory {

    private static InputHistoryManager theInputHistoryManager;

    // command inputs
    private Stack<String> prevInputs;
    private Stack<String> nextInputs;
    private String currentStoredInputShown;

    // Private constructor for Singleton Pattern
    private InputHistoryManager() {
        prevInputs = new Stack<String>();
        nextInputs = new Stack<String>();
        resetCurrentStoredInputShown();
    }

    // Use Singleton Pattern here
    public static InputHistoryManager getInstance() {
        if (theInputHistoryManager == null) {
            theInputHistoryManager = new InputHistoryManager();
        }
        return theInputHistoryManager;
    }

    @Override
    public void updateInputHistory(String userInput) {
        assert prevInputs != null && nextInputs != null && currentStoredInputShown != null;

        if (!isLatestInput()) {
            pushToPrevInput(currentStoredInputShown);
        }

        resetInputHistoryToLatestState();
        pushToPrevInput(userInput);
        resetCurrentStoredInputShown();
    }

    @Override
    public boolean isEarliestInput() {
        assert prevInputs != null;
        return prevInputs.isEmpty();
    }

    @Override
    public boolean isLatestInput() {
        assert nextInputs != null;
        return nextInputs.isEmpty();
    }

    @Override
    public String prevStep(String currentInput) {
        String inputToStore;

        if (isLatestInput()) {
            inputToStore = currentInput;
        } else {
            inputToStore = currentStoredInputShown;
        }

        pushToNextInput(inputToStore);
        return popFromPrevInput();
    }

    @Override
    public String nextStep() {
        pushToPrevInput(currentStoredInputShown);
        return popFromNextInput();
    }

    // private helper methods below

    /**
     * Resets the current stored input shown to an empty string.
     */
    private void resetCurrentStoredInputShown() {
        currentStoredInputShown = StringUtils.EMPTY;
    }

    /**
     * Resets the previous and next input history to the latest state,
     * transferring all the valid next input into the previous input history.
     */
    private void resetInputHistoryToLatestState() {

        boolean isEarliestNextInputValid = isLatestInput();
        String nextInputToTransfer;

        while (!isLatestInput()) {
            nextInputToTransfer = popFromNextInput();
            pushToPrevInput(nextInputToTransfer);
        }

        if (!isEarliestNextInputValid) {
            popFromPrevInput();
        }
    }

    /**
     * Pops and returns the last stored previous input from the previous input
     * history, updating the current stored input shown to that input. <br>
     * Asserts that the previous input history is non-empty.
     * 
     * @return The last stored previous input String
     */
    private String popFromPrevInput() {
        assert prevInputs != null && prevInputs.size() > 0;
        currentStoredInputShown = prevInputs.pop();
        return currentStoredInputShown;
    }

    /**
     * Pops and returns the last stored next input from the next input history,
     * updating the current stored input shown to that input. <br>
     * Asserts that the next input history is non-empty.
     * 
     * @return The last stored next input String
     */
    private String popFromNextInput() {
        assert nextInputs != null && nextInputs.size() > 0;
        currentStoredInputShown = nextInputs.pop();
        return currentStoredInputShown;
    }

    /**
     * Pushes the given input into the previous input history.
     */
    private void pushToPrevInput(String input) {
        assert prevInputs != null;
        prevInputs.push(input);
    }

    /**
     * Pushes the given input into the next input history.
     */
    private void pushToNextInput(String input) {
        assert nextInputs != null;
        nextInputs.push(input);
    }

}
```
###### /java/seedu/address/history/UndoableCommandHistory.java
``` java
/**
 * API of the UndoableCommandHistory Component.
 */
public interface UndoableCommandHistory {

    /**
     * Updates the UndoableCommand history with the given UndoableCommand
     * 
     * @param undoableCommand The UndoableCommand to update the history with
     */
    public void updateCommandHistory(UndoableCommand undoableCommand);

    /**
     * Returns whether we are already at the earliest command state (there is
     * nothing to undo anymore)
     * 
     * @return A boolean representing whether we are already at the earliest
     *         command of the undoable command history
     */
    public boolean isEarliestCommand();

    /**
     * Returns whether we are already at the latest command state (there is
     * nothing to redo anymore)
     * 
     * @return A boolean representing whether we are already at the latest
     *         command of the redoable command history
     */
    public boolean isLatestCommand();

    /**
     * Executes an undo step on the command history, returning the
     * UndoableCommand that was undone
     * 
     * @return The UndoableCommand that was undone
     */
    public UndoableCommand undoStep();

    /**
     * Executes a redo step on the command history, returning the
     * UndoableCommand that was redone
     * 
     * @return The UndoableCommand that was redone
     */
    public UndoableCommand redoStep();

}
```
###### /java/seedu/address/history/UndoableCommandHistoryManager.java
``` java
/**
 * Stores the history of undoable and redoable commands.
 */
public class UndoableCommandHistoryManager implements UndoableCommandHistory {

    private static UndoableCommandHistoryManager theUndoableCommandHistory;

    // command effects
    private Stack<UndoableCommand> undoableCommands;
    private Stack<UndoableCommand> redoableCommands;

    // Private constructor for Singleton Pattern
    private UndoableCommandHistoryManager() {
        undoableCommands = new Stack<UndoableCommand>();
        redoableCommands = new Stack<UndoableCommand>();
    }

    // Use Singleton Pattern here
    public static UndoableCommandHistoryManager getInstance() {
        if (theUndoableCommandHistory == null) {
            theUndoableCommandHistory = new UndoableCommandHistoryManager();
        }
        return theUndoableCommandHistory;
    }

    @Override
    public void updateCommandHistory(UndoableCommand undoableCommand) {
        assert undoableCommands != null;
        undoableCommands.push(undoableCommand);
        resetRedo();
    }

    @Override
    public boolean isEarliestCommand() {
        assert undoableCommands != null;
        return undoableCommands.isEmpty();
    }

    @Override
    public boolean isLatestCommand() {
        assert redoableCommands != null;
        return redoableCommands.isEmpty();
    }

    @Override
    public UndoableCommand undoStep() {
        assert redoableCommands != null && undoableCommands != null;

        UndoableCommand undoneCmd = undoableCommands.pop();
        return redoableCommands.push(undoneCmd);
    }

    @Override
    public UndoableCommand redoStep() {
        assert redoableCommands != null && undoableCommands != null;

        UndoableCommand redoneCmd = redoableCommands.pop();
        return undoableCommands.push(redoneCmd);
    }

    /**
     * Resets the redoable command history, erasing all redoable command history.
     */
    private void resetRedo() {
        redoableCommands = new Stack<UndoableCommand>();
    }

}
```
###### /java/seedu/address/logic/commands/AddCommand.java
``` java
    public static final String MESSAGE_SUCCESS = "New item added: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS = "Undid add item: %1$s";
    private static final String MESSAGE_UNDO_FAILURE = "Failed to undo last add command: add %1$s";

    public static final String TOOL_TIP = "[add] NAME [start DATE_TIME] [end DATE_TIME] [repeat every RECURRING_INTERVAL] [-PRIORITY]";

```
###### /java/seedu/address/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult execute() {
        assert model != null && toAdd != null;

        if (attemptToExecuteAddOnDoneList()) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_DONE_LIST_RESTRICTION);
        }

        model.addTask(toAdd);
        updateHistory();

        String formattedResult = String.format(MESSAGE_SUCCESS, toAdd);
        return new CommandResult(formattedResult);
    }

    private boolean attemptToExecuteAddOnDoneList() {
        return model.isCurrentListDoneList() && (!isRedoAction);
    }

    @Override
    public CommandResult undo() {
        assert model != null && toAdd != null;

        String formattedResult;
        try {
            model.deleteUndoneTask(toAdd);
            formattedResult = String.format(MESSAGE_UNDO_FAILURE, toAdd);
            return new CommandResult(formattedResult);

        } catch (TaskNotFoundException e) {

            formattedResult = String.format(MESSAGE_UNDO_FAILURE, toAdd);
            return new CommandResult(formattedResult);
        }

    }

```
###### /java/seedu/address/logic/commands/ClearCommand.java
``` java
/**
 * Clears the address book.
 */
public class ClearCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ":\n" + "Clears the current view of the task manager.\n\t"
            + "Example: " + COMMAND_WORD;

    public static final String TOOL_TIP = "clear";
    public static final String MESSAGE_SUCCESS_UNDONE_LIST = "Task Manager undone list has been cleared!";
    public static final String MESSAGE_SUCCESS_DONE_LIST = "Task Manager done list has been cleared!";
    public static final String MESSAGE_UNDO_SUCCESS_UNDONE_LIST = "Undid the clear command! Cleared tasks from the undone list have been restored!";
    public static final String MESSAGE_UNDO_SUCCESS_DONE_LIST = "Undid the clear command! Cleared tasks from the undone list have been restored!";

    private ObservableList<Task> clearedTasks;
    private boolean isTargetDoneList;

    public ClearCommand() {
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        if (!isRedoAction) {
            updateTargetList();
        }

        updateHistory();
        if (isTargetDoneList) {
            saveAndClearDoneList();
            return new CommandResult(MESSAGE_SUCCESS_DONE_LIST);
        } else {
            saveAndClearUndoneList();
            return new CommandResult(MESSAGE_SUCCESS_UNDONE_LIST);
        }

    }
    
    @Override
    public CommandResult undo() {
        assert model != null && clearedTasks != null;

        if (isTargetDoneList) {
            model.setTaskManagerDoneList(clearedTasks);
            return new CommandResult(MESSAGE_UNDO_SUCCESS_DONE_LIST);
        } else {
            model.setTaskManagerUndoneList(clearedTasks);
            return new CommandResult(MESSAGE_UNDO_SUCCESS_UNDONE_LIST);
        }

    }

    /**
     * Updates the target list of this clear command to the appropriate list.
     */
    private void updateTargetList() {
        isTargetDoneList = model.isCurrentListDoneList();
    }

    /**
     * Saves the current undone list, and then clears the undone list to an empty list.
     */
    private void saveAndClearUndoneList() {
        clearedTasks = model.getTaskManagerUndoneList();
        model.clearTaskManagerUndoneList();
    }
    
    /**
     * Saves the current done list, and then clears the done list to an empty list.
     */
    private void saveAndClearDoneList() {
        clearedTasks = model.getTaskManagerDoneList();
        model.clearTaskManagerDoneList();
    }

}
```
###### /java/seedu/address/logic/commands/DeleteCommand.java
``` java
    public static final String TOOL_TIP = "delete INDEX [ANOTHER_INDEX ...]";

    public static final String MESSAGE_UNDO_SUCCESS = "Undid delete on tasks! %1$s Tasks restored!";
    
```
###### /java/seedu/address/logic/commands/DeleteCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null && targetTasks != null;    
        
        if (isViewingDoneList) {
            undoDeletedDoneTasks();
        }
        else {
            undoDeletedUndoneTasks();

        }
        
        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, targetTasks));
    }

    /**
     * Undo the deletion of undone tasks by adding them back into the undone list.
     */
    private void undoDeletedUndoneTasks() {
        model.addTasks(targetTasks);
    }


    /**
     * Undo the deletion of done tasks by adding them back into the done list.
     */
    private void undoDeletedDoneTasks() {
        model.addDoneTasks(targetTasks);
    }

```
###### /java/seedu/address/logic/commands/DoneCommand.java
``` java

    public static final String MESSAGE_DONE_TASK_SUCCESS = "Archived Task: %1$s";
    public static final String MESSAGE_DONE_TASKS_SUCCESS = "Archived Tasks: %1$s";
    public static final String MESSAGE_FAILURE = "Failed to archive Task.";

```
###### /java/seedu/address/logic/commands/DoneCommand.java
``` java
    @Override
    public CommandResult undo() {
        doneTasksUndoFail = new ArrayList<Task>();
        
        attemptToDeleteDoneTasksFromDoneList();
        
        attemptToDeleteReaddedRecurTasksFromUndoneList();
        
        readdAllDoneTasksToUndoneList();
        
        if (isSuccessfulInUndoingAllDoneTasks()) {
            return new CommandResult(MESSAGE_DONE_UNDO_SUCCESS);
        }
        else {
            return new CommandResult(String.format(MESSAGE_DONE_UNDO_SOME_FAILURE, doneTasksUndoFail));
        }
    }

    /**
     * Attempt to delete all readded recurring tasks as a result of this done command from the current undone list.
     */
    private void attemptToDeleteReaddedRecurTasksFromUndoneList() {
        for (Task readdedRecurTask : readdedRecurringTasks) { 
            attemptToDeleteReaddedRecurTaskFromUndoneList(readdedRecurTask);
        }
    }

    /**
     * Attempt to delete all done tasks as a result of this done command from the current done list.
     */
    private void attemptToDeleteDoneTasksFromDoneList() {
        for (Task doneTask : targetTasks){
            attemptToDeleteDoneTaskFromDoneList(doneTask);
        }
    }

    /**
     * Readds all the done tasks as a result of this done command back to the current undone list.
     */
    private void readdAllDoneTasksToUndoneList() {
        model.addTasks(targetTasks);

    }

    /**
     * Attempts to delete a readded recurring task from the current undone list.
     * 
     * @param readdedRecurTask The recurring task that was readded to the current undone list as part of this done command
     */
    private void attemptToDeleteReaddedRecurTaskFromUndoneList(Task readdedRecurTask) {
        try {
            model.deleteUndoneTask(readdedRecurTask);
        } catch (TaskNotFoundException e) {
            logger.info("Cannot find task: " + readdedRecurTask + "; adding to list of done task failures to inform user.");
            doneTasksUndoFail.add(readdedRecurTask);
        }
    }

    /**
     * Attempts to delete a done task from the current done list.
     * 
     * @param doneTask The done task that was added to the current done list as part of this done command
     */
    private void attemptToDeleteDoneTaskFromDoneList(Task doneTask) {
        try {
            model.deleteDoneTask(doneTask);
        } catch (TaskNotFoundException e) {
            logger.info("Cannot find task: " + doneTask + "; adding to list of done task failures to inform user.");
            doneTasksUndoFail.add(doneTask);
        }
    }
    
    /**
     * Return whether the undo command was successful in undoing all done tasks.
     * 
     * @return A boolean representing if all done tasks were undone.
     */
    private boolean isSuccessfulInUndoingAllDoneTasks() {
        return doneTasksUndoFail.isEmpty();
    }

}
```
###### /java/seedu/address/logic/commands/EditCommand.java
``` java
    /**
     * Returns true if the edit command is being executed on the done list.
     */
    private boolean attemptToExecuteEditDoneList() {
        return model.isCurrentListDoneList() && (!isRedoAction);
    }
    
```
###### /java/seedu/address/logic/commands/EditCommand.java
``` java
    @Override
    public CommandResult undo() {

        String taskBeforeUndoString = toEdit.toString();

        Name previousTaskName = beforeEdit.getName();
        Priority previousPriority = beforeEdit.getPriorityValue();
        Date previousStartDate = getPreviousStartDateIfPresent();
        Date previousEndDate = getPreviousEndDateIfPresent();
        RecurrenceRate previousRecurrenceRate = getPreviousRecurrenceIfPresent();

        model.editTask(toEdit, previousTaskName, previousStartDate, previousEndDate, previousPriority, previousRecurrenceRate);
        
        String formattedResult = String.format(MESSAGE_UNDO_SUCCESS, taskBeforeUndoString, toEdit);
        return new CommandResult(formattedResult);
    }


    /**
     * Get the previous start date before edit, if present.
     * @return The previous start date if present, otherwise returns null
     */
    private Date getPreviousStartDateIfPresent() {
        Optional<Date> previousStartDate = beforeEdit.getStartDate();
        if (previousStartDate.isPresent()) {
            return previousStartDate.get();
        }
        return null;
    }
    
    /**
     * Gets the previous end date before edit, if present.
     * @return The previous end date if present, otherwise returns null
     */
    private Date getPreviousEndDateIfPresent() {
        Optional<Date> previousEndDate = beforeEdit.getEndDate();
        if (previousEndDate.isPresent()) {
            return previousEndDate.get();
        }
        return null;
    }

    /**
     * Gets the previous recurrence rate before edit, if present.
     * @return The previous recurrence rate if present, otherwise returns null
     */
    private RecurrenceRate getPreviousRecurrenceIfPresent() {
        Optional<RecurrenceRate> previousReccurence = beforeEdit.getRecurrenceRate();
        
        if (previousReccurence.isPresent()) {
            return previousReccurence.get();
        }
        return null;
    }

}
```
###### /java/seedu/address/logic/commands/HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows program usage instructions.\n" + "Example: "
            + COMMAND_WORD;

    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";

    public static final String TOOL_TIP = "help";

    @Override
    public CommandResult execute() {
        postNewHelpEvent();
        return new CommandResult(SHOWING_HELP_MESSAGE);
    }
    
    /**
     * Posts a new help request event
     */
    private void postNewHelpEvent() {
        EventsCenter theEventsCenter = EventsCenter.getInstance();
        ShowHelpRequestEvent newHelpRequest = new ShowHelpRequestEvent();
        theEventsCenter.post(newHelpRequest);
    }
}
```
###### /java/seedu/address/logic/commands/RedoCommand.java
``` java
/**
 * Redoes the latest UndoableCommand that was undone.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Reverses the last undo command, reversing the effect on the task manager.\n" + "Example: "
            + COMMAND_WORD;

    public static final String TOOL_TIP = "redo";

    public static final String MESSAGE_FAILURE = "There is nothing to redo.";

    public RedoCommand() {
    }

    @Override
    public CommandResult execute() {
        assert history != null;

        if (history.isLatestCommand()) {
            return new CommandResult(MESSAGE_FAILURE);
        }

        UndoableCommand cmdToRedo = history.redoStep();
        return cmdToRedo.execute();
    }

}
```
###### /java/seedu/address/logic/commands/UndoableCommand.java
``` java
public abstract class UndoableCommand extends Command {

    protected boolean isRedoAction;

    /**
     * Undoes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult undo();

    /**
     * Updates the history of undoable commands with this undoable command, if
     * this command is not a command that was executed as part of a redo
     * command. <br>
     * If this command was not a redo action, also sets the isRedoAction
     * flag to be true as future executes of this same Command must be a redo action.
     */
    public void updateHistory() {

        if (isRedoAction) {
            return;
        }

        history.updateCommandHistory(this);
        isRedoAction = true;
    }

}
```
###### /java/seedu/address/logic/commands/UndoCommand.java
``` java
/**
 * Undoes the latest UndoableCommand that was recorded in the undoable command
 * history.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undoes the last reversible command, reversing the effect on the task manager.\n" + "Example: "
            + COMMAND_WORD;

    public static final String TOOL_TIP = "undo";

    public static final String MESSAGE_FAILURE = "There is nothing to undo.";

    public UndoCommand() {
    }

    @Override
    public CommandResult execute() {
        assert history != null;

        if (history.isEarliestCommand()) {
            return new CommandResult(MESSAGE_FAILURE);
        }

        UndoableCommand cmdToUndo = history.undoStep();
        return cmdToUndo.undo();

    }

}
```
###### /java/seedu/address/logic/LogicManager.java
``` java
    /**
     * Generates the tool tip for the given user input.<br>
     * Asserts that the userInput is not null.
     * 
     * @param userInput The user input String
     * @return The tooltip appropriate for the given user input String
     */
    @Override
    public String generateToolTip(String userInput) {
        assert userInput != null;

        boolean viewingDoneList = model.isCurrentListDoneList();
        return parser.parseForTooltip(userInput, viewingDoneList);
    }
```
###### /java/seedu/address/logic/parser/CommandParser.java
``` java
    /**
     * Parses a user input to determine the appropriate tooltip to display to
     * the user.<br>
     * Asserts that the specified userInput is not null.
     * 
     * @param userInput The user input String
     * @param isViewingDoneList The boolean representing if the user's current
     *            view is the done task list
     * @return The tooltip String
     */
    public String parseForTooltip(String userInput, boolean isViewingDoneList) {
        assert userInput != null;

        String trimmedUserInput = userInput.trim();
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(trimmedUserInput);
        boolean invalidCommandFormat = !matcher.matches();

        if (invalidCommandFormat) {
            return MESSAGE_TOOLTIP_INVALID_COMMAND_FORMAT;
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");
        boolean shouldInterpretAsNoArgs = commandWord.equals(userInput);

        return getTooltip(arguments, commandWord, shouldInterpretAsNoArgs, isViewingDoneList);
    }
   
    /**
     * Returns the tooltip taking into consideration the arguments String,
     * commandWord String, if the input should be interpreted as no arguments
     * and if the current view is the done list view.
     * 
     * @param arguments The parsed arguments String of the user input
     * @param commandWord The parsed command word String of the user input
     * @param shouldInterpretAsNoArgs A boolean representing if the current
     *            input should be interpreted as not having any arguments
     * @param isViewingDoneList A boolean representing if the current view is
     *            the done list view.
     * @return The tooltip String that is appropriate for the specified
     *         parameters
     */
    private String getTooltip(final String arguments, final String commandWord,
            boolean shouldInterpretAsNoArgs, boolean isViewingDoneList) {

        if (isViewingDoneList) {
            return getTooltipForDoneList(commandWord, shouldInterpretAsNoArgs);
        } else {
            return getTooltipForUndoneList(arguments, commandWord, shouldInterpretAsNoArgs);
        }

    }

    /**
     * Returns the tooltip for the undone list view, taking into consideration
     * the arguments String, commandWord String, if the input should be
     * interpreted as no arguments.
     * 
     * @param arguments The parsed arguments String of the user input
     * @param commandWord The parsed command word String of the user input
     * @param shouldInterpretAsNoArgs A boolean representing if the current
     *            input should be interpreted as not having any arguments
     * @return The tooltip String that is appropriate for the specified
     *         parameters
     */
    private String getTooltipForUndoneList(final String arguments, final String commandWord,
            boolean shouldInterpretAsNoArgs) {

        if (shouldInterpretAsNoArgs) {
            return getTooltipForCmdWithNoArgsUndoneList(arguments, commandWord);
        } else {
            return getTooltipForCmdWithArgsUndoneList(arguments, commandWord);
        }
    }

    /**
     * Returns the tooltip for the done list view, taking into consideration the
     * arguments String, commandWord String, if the input should be interpreted
     * as no arguments.
     * 
     * @param commandWord The parsed command word String of the user input
     * @param shouldInterpretAsNoArgs A boolean representing if the current
     *            input should be interpreted as not having any arguments
     * @return The tooltip String that is appropriate for the specified
     *         parameters
     */
    private String getTooltipForDoneList(final String commandWord, boolean shouldInterpretAsNoArgs) {

        if (shouldInterpretAsNoArgs) {
            return getTooltipForCmdWithNoArgsDoneList(commandWord);
        } else {
            return getTooltipForCmdWithArgsDoneList(commandWord);
        }
    }

    /**
     * Returns the tooltip for the done list view and assuming command has no
     * arguments, appropriate for the specified commandWord.
     * 
     * @param commandWord The parsed command word String of the user input
     * @return The tooltip String that is appropriate for the specified
     *         parameters
     */
    private String getTooltipForCmdWithNoArgsDoneList(String commandWord) {
        List<String> tooltips = new ArrayList<String>();

        if (StringUtils.startsWith(ClearCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ClearCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(DeleteCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(DeleteCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(ExitCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ExitCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(FindCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(FindCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(HelpCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(HelpCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(ListCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ListCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(RedoCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(RedoCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(SelectCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(SelectCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(StoreCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(StoreCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(UndoCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(UndoCommand.TOOL_TIP);
        }

        boolean hasNoTooltipMatches = tooltips.isEmpty();
        if (hasNoTooltipMatches) {
            return Messages.MESSAGE_DONE_LIST_RESTRICTED_COMMANDS;
        }

        String combinedTooltip = String.join(NEWLINE_STRING, tooltips);
        return combinedTooltip;
    }
    
    /**
     * Returns the tooltip for the done list view and assuming command has
     * arguments, appropriate for the specified commandWord.
     * 
     * @param commandWord The parsed command word String of the user input
     * @return The tooltip String that is appropriate for the specified
     *         parameters
     */
    private String getTooltipForCmdWithArgsDoneList(String commandWord) {

        if (commandWord.equals(ClearCommand.COMMAND_WORD)) {
            return ClearCommand.TOOL_TIP;

        } else if (commandWord.equals(DeleteCommand.COMMAND_WORD)) {
            return DeleteCommand.TOOL_TIP;

        } else if (commandWord.equals(ExitCommand.COMMAND_WORD)) {
            return ExitCommand.TOOL_TIP;

        } else if (commandWord.equals(FindCommand.COMMAND_WORD)) {
            return FindCommand.TOOL_TIP;

        } else if (commandWord.equals(HelpCommand.COMMAND_WORD)) {
            return HelpCommand.TOOL_TIP;

        } else if (commandWord.equals(ListCommand.COMMAND_WORD)) {
            return ListCommand.TOOL_TIP;

        } else if (commandWord.equals(RedoCommand.COMMAND_WORD)) {
            return RedoCommand.TOOL_TIP;

        } else if (commandWord.equals(SelectCommand.COMMAND_WORD)) {
            return SelectCommand.TOOL_TIP;

        } else if (commandWord.equals(StoreCommand.COMMAND_WORD)) {
            return StoreCommand.TOOL_TIP;

        } else if (commandWord.equals(UndoCommand.COMMAND_WORD)) {
            return UndoCommand.TOOL_TIP;

        } else {
            return Messages.MESSAGE_DONE_LIST_RESTRICTED_COMMANDS;
        }
    }

    
    /**
     * Returns the tooltip for the undone list view and assuming command has no
     * arguments, appropriate for the specified commandWord and arguments.
     * 
     * @param arguments The parsed arguments String of the user input
     * @param commandWord The parsed command word String of the user input
     * @return The tooltip String that is appropriate for the specified
     *         parameters
     */
    private String getTooltipForCmdWithNoArgsUndoneList(final String arguments, final String commandWord) {
        List<String> tooltips = new ArrayList<String>();

        if (StringUtils.startsWith(AddCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(AddCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(ClearCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ClearCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(DeleteCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(DeleteCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(DoneCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(DoneCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(EditCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(EditCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(ExitCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ExitCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(FindCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(FindCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(HelpCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(HelpCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(ListCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(ListCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(RedoCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(RedoCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(SelectCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(SelectCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(StoreCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(StoreCommand.TOOL_TIP);
        }
        if (StringUtils.startsWith(UndoCommand.COMMAND_WORD, commandWord)) {
            tooltips.add(UndoCommand.TOOL_TIP);
        }

        if (tooltips.isEmpty()) {
            return prepareAddDetailedTooltip(commandWord + arguments);
        }

        return String.join(NEWLINE_STRING, tooltips);
    }
    
    /**
     * Returns the tooltip for the undone list view and assuming command has
     * arguments, appropriate for the specified commandWord and arguments.
     * 
     * @param arguments The parsed arguments String of the user input
     * @param commandWord The parsed command word String of the user input
     * @return The tooltip String that is appropriate for the specified
     *         parameters
     */
    private String getTooltipForCmdWithArgsUndoneList(final String arguments, final String commandWord) {
        if (commandWord.equals(AddCommand.COMMAND_WORD)) {
            return prepareAddDetailedTooltip(arguments);

        } else if (commandWord.equals(ClearCommand.COMMAND_WORD)) {
            return ClearCommand.TOOL_TIP;

        } else if (commandWord.equals(DeleteCommand.COMMAND_WORD)) {
            return DeleteCommand.TOOL_TIP;

        } else if (commandWord.equals(DoneCommand.COMMAND_WORD)) {
            return DoneCommand.TOOL_TIP;

        } else if (commandWord.equals(EditCommand.COMMAND_WORD)) {
            return prepareEditDetailedTooltip(arguments);

        } else if (commandWord.equals(ExitCommand.COMMAND_WORD)) {
            return ExitCommand.TOOL_TIP;

        } else if (commandWord.equals(FindCommand.COMMAND_WORD)) {
            return FindCommand.TOOL_TIP;

        } else if (commandWord.equals(HelpCommand.COMMAND_WORD)) {
            return HelpCommand.TOOL_TIP;

        } else if (commandWord.equals(ListCommand.COMMAND_WORD)) {
            return ListCommand.TOOL_TIP;

        } else if (commandWord.equals(RedoCommand.COMMAND_WORD)) {
            return RedoCommand.TOOL_TIP;

        } else if (commandWord.equals(SelectCommand.COMMAND_WORD)) {
            return SelectCommand.TOOL_TIP;

        } else if (commandWord.equals(StoreCommand.COMMAND_WORD)) {
            return StoreCommand.TOOL_TIP;

        } else if (commandWord.equals(UndoCommand.COMMAND_WORD)) {
            return UndoCommand.TOOL_TIP;

        } else {
            // default command is an add command
            return prepareAddDetailedTooltip(commandWord + arguments);

        }

    }

    /**
     * Generate the detailed tooltip for the edit command using the specified userInput String.
     * 
     * @param userInput The user input String to generate the detailed edit command tooltip with
     * @return The detailed edit tooltip for the given userInput String
     * @throws IllegalValueException If the specified userInput cannot generate a valid detailed edit tooltip
     */
    private String generateEditDetailedTooltip(String userInput) throws IllegalValueException {
        assert userInput != null;
        
        userInput = userInput.trim();
        String[] splitIndexFromOtherArgs = userInput.split(STRING_REGEX_ONE_OR_MORE_WHITESPACE, 2);
        String indexToEdit = splitIndexFromOtherArgs[ZERO];
        
        try {
            Integer.parseInt(indexToEdit);
        } catch (NumberFormatException e) {
            return EditCommand.TOOL_TIP + "\n" + "Please enter a number for the index.\n";
        }
        

        String argumentsWithoutIndex;
        if (splitIndexFromOtherArgs.length == 1) {
            argumentsWithoutIndex = splitIndexFromOtherArgs[ZERO];
        } else {
            argumentsWithoutIndex = splitIndexFromOtherArgs[ONE];

        }
        
        logger.info(argumentsWithoutIndex);
        
        String resetField = null;
        String[] resetSplit = argumentsWithoutIndex.split(RESET_KEYWORD);
        
        logger.info(Arrays.asList(resetSplit).toString());
 
        
        boolean isResettingStartDate = false;
        boolean isResettingEndDate = false;
        boolean isResettingRecurrence = false;
        boolean isResettingPriority = false;
                    
        
        String beforeResetSplit = "";
        if (resetSplit.length != 0) {
            beforeResetSplit = resetSplit[0];
        }
        
        HashMap<String, Optional<String>> fieldMap = retrieveEditFieldsFromArgs(beforeResetSplit);
        
        Optional<String> name = fieldMap.get(MAP_NAME);
        Optional<String> startDate = fieldMap.get(MAP_START_DATE);
        Optional<String> endDate = fieldMap.get(MAP_END_DATE);
        Optional<String> rate = fieldMap.get(MAP_RECURRENCE_RATE);
        Optional<String> timePeriod = fieldMap.get(MAP_RECURRENCE_TIME_PERIOD);
        Optional<String> priority = fieldMap.get(MAP_PRIORITY);

        if(resetSplit.length == TWO){
            resetField = resetSplit[ONE];
        }
        
        if (resetField != null) {
            String[] resetFieldNames = resetField.split(STRING_REGEX_ONE_OR_MORE_WHITESPACE);
            
            for (String resetFieldStr : resetFieldNames) {
                if (resetFieldStr.equals(RESET_START_KEYWORD)) {
                    isResettingStartDate = true;
                } else if (resetFieldStr.equals(RESET_END_KEYWORD)) {
                    isResettingEndDate = true;
                } else if (resetFieldStr.equals(RESET_RECURRENCE_KEYWORD)) {
                    isResettingRecurrence = true;
                } else if (resetFieldStr.equals(RESET_PRIORITY_KEYWORD)) {
                    isResettingPriority = true;
                }
            }
        }

                    
        StringBuilder sb = generateEditDetailedTooltipHeader(indexToEdit);

        genearteEditDetailedTooltipName(userInput, name, sb);
        
        generateEditDetailedTooltipStartDate(isResettingStartDate, startDate, sb);
        
        generateEditDetailedTooltipEndDate(isResettingEndDate, endDate, sb);
        
        generateEditDetailedTooltipRecurrence(isResettingRecurrence, rate, timePeriod, sb);
        
        generateEditDetailedTooltipPriority(isResettingPriority, priority, sb);
        
        return sb.toString();
        
    }

    /**
     * Generate the priority field in the edit detailed tooltip.
     * 
     * @param isResettingPriority A boolean representing if the current edit input wants to reset the priority field
     * @param priority The parsed priority String from the user input
     * @param sb The StringBuilder to build on
     */
    private void generateEditDetailedTooltipPriority(boolean isResettingPriority, Optional<String> priority,
            StringBuilder sb) {
        if (isResettingPriority) {
            sb.append(DETAILED_TOOLTIP_PRIORITY_PREFIX + DETAILED_TOOLTIP_RESET);
        } else if (!priority.get().equals("null")) {
            sb.append(DETAILED_TOOLTIP_PRIORITY_PREFIX + priority.get());
        } else {
            sb.append(DETAILED_TOOLTIP_PRIORITY_PREFIX + DETAILED_TOOLTIP_NO_CHANGE);
        }
    }

    /**
     * Generate the recurrence field in the edit detailed tooltip.
     * 
     * @param isResettingRecurrence A boolean representing if the current edit input wants to reset the recurrence field
     * @param rate The parsed rate String from the user input
     * @param timePeriod The parsed timePeriod String from the user input
     * @param sb The StringBuilder to build on
     */
    private void generateEditDetailedTooltipRecurrence(boolean isResettingRecurrence, Optional<String> rate,
            Optional<String> timePeriod, StringBuilder sb) {
        if (isResettingRecurrence) {
            sb.append(DETAILED_TOOLTIP_RECURRENCE_SPECIAL_PREFIX + DETAILED_TOOLTIP_RESET);
        } else if (timePeriod.isPresent()) {
            if (rate.isPresent()) {
                String recurRate = rate.get();
                sb.append(DETAILED_TOOLTIP_RECURRENCE_PREFIX + recurRate + STRING_ONE_SPACE + timePeriod.get());
            } else {
                sb.append(DETAILED_TOOLTIP_RECURRENCE_PREFIX + timePeriod.get());
            }
        } else {
            sb.append(DETAILED_TOOLTIP_RECURRENCE_SPECIAL_PREFIX + DETAILED_TOOLTIP_NO_CHANGE);
        }
    }

    /**
     * Generate the end date field in the edit detailed tooltip.
     * 
     * @param isResettingEndDate A boolean representing if the current edit input wants to reset the end date field
     * @param endDate The parsed end date String from the user input
     * @param sb The StringBuilder to build on
     */
    private void generateEditDetailedTooltipEndDate(boolean isResettingEndDate, Optional<String> endDate,
            StringBuilder sb) {
        if (isResettingEndDate) {
            sb.append(DETAILED_TOOLTIP_END_DATE_PREFIX + DETAILED_TOOLTIP_RESET);
        } else if (endDate.isPresent()) {
            sb.append(DETAILED_TOOLTIP_END_DATE_PREFIX + endDate.get());
        } else {
            sb.append(DETAILED_TOOLTIP_END_DATE_PREFIX + DETAILED_TOOLTIP_NO_CHANGE);
        }
    }

    /**
     * Generate the start date field in the edit detailed tooltip.
     * 
     * @param isResettingStartDate A boolean representing if the current edit input wants to reset the start date field
     * @param startDate The parsed start date String from the user input
     * @param sb The StringBuilder to build on
     */
    private void generateEditDetailedTooltipStartDate(boolean isResettingStartDate, Optional<String> startDate,
            StringBuilder sb) {
        if (isResettingStartDate) {
            sb.append(DETAILED_TOOLTIP_START_DATE_PREFIX + DETAILED_TOOLTIP_RESET);
        } else if (startDate.isPresent()) {
            sb.append(DETAILED_TOOLTIP_START_DATE_PREFIX + startDate.get());
        } else {
            sb.append(DETAILED_TOOLTIP_START_DATE_PREFIX + DETAILED_TOOLTIP_NO_CHANGE);
        }
    }

    /**
     * Generate the name field in the edit detailed tooltip.
     * 
     * @param trimmedArgs The trimmed user input arguments
     * @param name The parsed name String from the user input
     * @param sb The StringBuilder to build on
     */
    private void genearteEditDetailedTooltipName(String trimmedArgs, Optional<String> name, StringBuilder sb) {
        if (name.isPresent() && trimmedArgs.length()>1 && !name.get().isEmpty()) {
            sb.append(DETAILED_TOOLTIP_NAME_PREFIX + name.get());
        } else {
            sb.append(DETAILED_TOOLTIP_NAME_PREFIX +  DETAILED_TOOLTIP_NO_CHANGE);
        }
    }

    /**
     * Generate the header of the edit detailed tooltip, with the specified indexToEdit.
     * 
     * @param indexToEdit The parsed index the input is trying to edit
     * @return The StringBuilder to build on for the rest of the edit detailed tooltip
     */
    private StringBuilder generateEditDetailedTooltipHeader(String indexToEdit) {
        StringBuilder sb = new StringBuilder();
        sb.append(EditCommand.TOOL_TIP);
        sb.append("\n\tEditing task at INDEX " + indexToEdit + ": ");
        return sb;
    }

    /**
     * Retrieve the edit fields from the user input.
     * 
     * @param beforeResetSplit the user input String arguments before the reset keyword
     * @return the HashMap the maps the edit field to the parsed String matching that field, retrieved from the input
     * @throws IllegalValueException If the specified userInput cannot generate a valid detailed edit tooltip
     */
    private HashMap<String, Optional<String>> retrieveEditFieldsFromArgs(String beforeResetSplit)
            throws IllegalValueException {
        return new CommandParserHelper().prepareEdit(EMPTY_SPACE_FOR_NAME_NO_CHANGE + beforeResetSplit);
    }

    private String prepareAddDetailedTooltip(final String arguments) {
        try {
            if (arguments.isEmpty()) {
                return AddCommand.TOOL_TIP;
            }
            
            String trimmedArgs = arguments.trim();
            return generateAddDetailedTooltip(trimmedArgs);
        } catch (IllegalValueException e) {
            logger.info("Illegal add arguments passed for detailed tooltip, showing regular add tooltip with warning instead");
            return String.join(NEWLINE_STRING, AddCommand.TOOL_TIP, "Instant parser is unable to determine your current input as it does not match a valid command input.");
        }

    }
    
    private String prepareEditDetailedTooltip(final String arguments) {
        try {
            
            // should not use exceptions for this
            if (arguments.isEmpty()) {
                return EditCommand.TOOL_TIP;
            }
            
            return generateEditDetailedTooltip(arguments);       
        } catch (IllegalValueException e) {
            logger.info("Illegal edit arguments passed for detailed tooltip, showing regular edit tooltip with warning instead");
            return String.join(NEWLINE_STRING, EditCommand.TOOL_TIP, "Instant parser is unable to determine your current input as it does not match a valid command input.");
        }
    }

    /**
     * @param trimmedArgs
     * @return
     * @throws IllegalValueException
     */
    private String generateAddDetailedTooltip(String trimmedArgs) throws IllegalValueException {
        HashMap<String, Optional<String>> fieldMap = retrieveAddFieldsFromArgs(trimmedArgs);
        
        Optional<String> name = fieldMap.get(MAP_NAME);
        Optional<String> startDate = fieldMap.get(MAP_START_DATE);
        Optional<String> endDate = fieldMap.get(MAP_END_DATE);
        Optional<String> rate = fieldMap.get(MAP_RECURRENCE_RATE);
        Optional<String> timePeriod = fieldMap.get(MAP_RECURRENCE_TIME_PERIOD);
        Optional<String> priority = fieldMap.get(MAP_PRIORITY);
        
        StringBuilder sb = generateAddDetailedTooltipHeader();
        generateAddDetailedTooltipName(name, sb);
        generateAddDetailedTooltipStartDate(startDate, sb);
        generateAddDetailedTooltipEndDate(endDate, sb);
        generateAddDetailedTooltipRecurrence(rate, timePeriod, sb);
        generateAddDetailedTooltipPriority(priority, sb);
        return sb.toString();
    }


    /**
     * Generate the add detailed tooltip header and return it as a StringBuilder.
     * 
     * @return the StringBuilder object containing the add detailed tooltip header
     */
    private StringBuilder generateAddDetailedTooltipHeader() {
        StringBuilder sb = new StringBuilder();
        sb.append(AddCommand.TOOL_TIP);
        sb.append(ADD_DETAILED_TOOLTIP_HEADER);
        return sb;
    }

    /**
     * @param name
     * @param sb
     */
    private void generateAddDetailedTooltipName(Optional<String> name, StringBuilder sb) {
        if (name.isPresent()) {
            sb.append(DETAILED_TOOLTIP_NAME_PREFIX + name.get());
        }
    }

    /**
     * @param startDate
     * @param sb
     */
    private void generateAddDetailedTooltipStartDate(Optional<String> startDate, StringBuilder sb) {
        if (startDate.isPresent()) {
            sb.append(DETAILED_TOOLTIP_START_DATE_PREFIX + startDate.get());
        }
    }

    /**
     * @param endDate
     * @param sb
     */
    private void generateAddDetailedTooltipEndDate(Optional<String> endDate, StringBuilder sb) {
        if (endDate.isPresent()) {
            sb.append(DETAILED_TOOLTIP_END_DATE_PREFIX + endDate.get());
        }
    }

    /**
     * @param rate
     * @param timePeriod
     * @param sb
     */
    private void generateAddDetailedTooltipRecurrence(Optional<String> rate, Optional<String> timePeriod,
            StringBuilder sb) {

        if (!timePeriod.isPresent()) {
            return;
        }

        String timePeriodStr = timePeriod.get();
        if (rate.isPresent()) {
            String recurRate = rate.get();
            sb.append(DETAILED_TOOLTIP_RECURRENCE_PREFIX + recurRate + STRING_ONE_SPACE + timePeriodStr);
        } else {
            sb.append(DETAILED_TOOLTIP_RECURRENCE_PREFIX + timePeriodStr);
        }
    }

    /**
     * @param priority
     * @param sb
     */
    private void generateAddDetailedTooltipPriority(Optional<String> priority, StringBuilder sb) {
        if (priority.isPresent()) {
            sb.append(DETAILED_TOOLTIP_PRIORITY_PREFIX + priority.get());
        }
    }

    /**
     * @param trimmedArgs
     * @return
     * @throws IllegalValueException
     */
    private HashMap<String, Optional<String>> retrieveAddFieldsFromArgs(String trimmedArgs)
            throws IllegalValueException {
        CommandParserHelper cmdParserHelper = new CommandParserHelper();
        return cmdParserHelper.prepareAdd(trimmedArgs);
    }
    
```
###### /java/seedu/address/model/item/ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override
     * .equals) All fields must be equal.
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getPriorityValue().equals(this.getPriorityValue())
                && other.getStartDate().equals(this.getStartDate())
                && other.getEndDate().equals(this.getEndDate())
                && other.getRecurrenceRate().equals(this.getRecurrenceRate()));
    }
       
```
###### /java/seedu/address/model/item/Task.java
``` java
    @Override
    public boolean equals(Object other) {

        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instance of handles null
                && this.isSameStateAs((ReadOnlyTask) other));

    }
    
```
###### /java/seedu/address/storage/XmlAdaptedRecurrenceRate.java
``` java
public class XmlAdaptedRecurrenceRate {

    @XmlElement(required = true)
    private String rate;
    @XmlElement(required = true)
    private String timePeriod;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedRecurrenceRate() {
    }

    /**
     * Converts a given RecurrenceRate into this class for JAXB use.<br>
     * Future changes to this will not affect the created
     * XmlAdaptedRecurrenceRate.
     *
     * @param source The RecurrenceRate to convert
     */
    public XmlAdaptedRecurrenceRate(RecurrenceRate source) {
        assert source.getRate() != null && source.getTimePeriod() != null;

        rate = source.getRate().toString();
        timePeriod = source.getTimePeriod().toString();

    }

    /**
     * Converts this jaxb-friendly adapted RecurrenceRate object into the
     * model's RecurrenceRate object.
     *
     * @throws IllegalValueException If there were any data constraints violated
     *             in the adapted recurrence rate
     */
    public RecurrenceRate toModelType() throws IllegalValueException {
        return new RecurrenceRate(this.rate, this.timePeriod);
    }
}
```
###### /java/seedu/address/storage/XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    private static SimpleDateFormat dateParser = new SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy");

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String priority;
    @XmlElement
    private String startDate;
    @XmlElement
    private String endDate;
    @XmlElement
    private XmlAdaptedRecurrenceRate recurrenceRate;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {
    }

    /**
     * Converts a given Task into this class for JAXB use. <br>
     * Future changes to this will not affect the created XmlAdaptedTask.
     *
     * @param source The task to convert
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        saveName(source);
        savePriority(source);
        saveStartDateIfPresent(source);
        saveEndDateIfPresent(source);
        saveRecurrenceRateIfPresent(source);
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task
     * object.
     *
     * @throws IllegalValueException If there were any data constraints violated
     *             in the adapted task
     * @throws ParseException If there was a parsing problem for the start and end dates of the stored Task
     */
    public Task toModelType() throws IllegalValueException, ParseException {
        Name nameForModel = getNameFromStoredTask();
        Priority priorityForModel = getPriorityFromStoredTask();

        Date startDateForModel = getStartDateFromStoredTask();
        Date endDateForModel = getEndDateFromStoredTask();
        RecurrenceRate recurrenceRateForModel = getRecurrenceRateFromStoredTask();

        return new Task(nameForModel, startDateForModel, endDateForModel, recurrenceRateForModel,
                priorityForModel);
    }

    /**
     * Saves the name of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source The Task to convert into the XmlAdaptedTask
     */
    private void saveName(ReadOnlyTask source) {
        name = source.getName().toString();
    }

    /**
     * Saves the priority of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source The Task to convert into the XmlAdaptedTask
     */
    private void savePriority(ReadOnlyTask source) {
        String priorityString = source.getPriorityValue().toString();
        priority = priorityString.toLowerCase();
    }

    /**
     * Saves the start date of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source The Task to convert into the XmlAdaptedTask
     */
    private void saveStartDateIfPresent(ReadOnlyTask source) {
        boolean hasStartDate = source.getStartDate().isPresent();

        if (hasStartDate) {
            startDate = source.getStartDate().get().toString();
        }
    }

    /**
     * Saves the end date of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source The Task to convert into the XmlAdaptedTask
     */
    private void saveEndDateIfPresent(ReadOnlyTask source) {
        boolean hasEndDate = source.getEndDate().isPresent();

        if (hasEndDate) {
            endDate = source.getEndDate().get().toString();
        }
    }

    /**
     * Saves the recurrence rate of the source ReadOnlyTask into the
     * XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void saveRecurrenceRateIfPresent(ReadOnlyTask source) {
        boolean hasRecurrenceRate = source.getRecurrenceRate().isPresent();

        if (hasRecurrenceRate) {
            recurrenceRate = new XmlAdaptedRecurrenceRate(source.getRecurrenceRate().get());
        }
    }

    /**
     * Retrieves the Name associated with the stored task.
     * 
     * @return The Name associated with the stored task
     */
    private Name getNameFromStoredTask() {
        assert name != null;

        return new Name(name);
    }

    /**
     * Retrieves the Priority associated with the stored task. If the priority
     * string in the stored task does not match any valid priority strings, the
     * task will be given a default medium priority.
     * 
     * @return The Priority associated with the stored task
     */
    private Priority getPriorityFromStoredTask() {
        // assert priority != null;

        return Priority.convertStringToPriority(priority);
    }

    /**
     * Retrieves the start date Date associated with the stored task. Returns
     * null if there is no start date associated with the stored task.
     * 
     * @return The start date Date associated with the task, or null if no start
     *         date is associated with the current stored task.
     * @throws ParseException If the format of the start date does not conform
     *             to the expected format
     */
    private Date getStartDateFromStoredTask() throws ParseException {
        if (startDate == null) {
            return null;
        }
        return dateParser.parse(startDate);
    }

    /**
     * Retrieves the end date Date associated with the stored task. Returns null
     * if there is no end date associated with the stored task.
     * 
     * @return The end date Date associated with the task, or null if no end
     *         date is associated with the current stored task.
     * @throws ParseException If the format of the end date does not conform to
     *             the expected format
     */
    private Date getEndDateFromStoredTask() throws ParseException {
        if (endDate == null) {
            return null;
        }

        return dateParser.parse(endDate);
    }

    /**
     * Retrieves the ReccurenceRate associated with the stored task. Returns
     * null if there is no recurrence rate associated with the stored task.
     * 
     * @return The RecurrenceRate associated with the task, or null if no
     *         recurrence rate is associated with the current stored task.
     * 
     * @throws IllegalValueException If there were any data constraints violated
     *             in the adapted recurrence rate
     */
    private RecurrenceRate getRecurrenceRateFromStoredTask() throws IllegalValueException {
        if (recurrenceRate == null) {
            return null;
        }

        return recurrenceRate.toModelType();
    }

}
```
###### /java/seedu/address/ui/CommandBox.java
``` java
public class CommandBox extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;
    String previousCommandTest;

    private Logic logic;
    private InputHistory inputHistory;

    private static final String BACKSPACE_UNICODE = "\u0008";
    private static final String SPACE_UNICODE = "\u0020";
    private static final String CARRIAGE_RETURN = "\r";
    private static final String NEW_LINE = "\n";
    private static final String STRING_EMPTY = "";
    private static final String STRING_ONE_SPACE = " ";


    @FXML
    private TextField commandTextField;
    private CommandResult mostRecentResult;

    public static CommandBox load(Stage primaryStage, AnchorPane commandBoxPlaceholder, ResultDisplay resultDisplay,
            Logic logic, InputHistory history) {
        CommandBox commandBox = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new CommandBox());
        commandBox.configure(resultDisplay, logic, history);
        commandBox.addToPlaceholder();
        return commandBox;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic, InputHistory history) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        this.inputHistory = history;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);

        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent keyEvent) {
                switch (keyEvent.getCode()) {
                case UP :
                    // Fallthrough
                case DOWN :
                    keyEvent.consume();
                    handleUpDownArrow(keyEvent);
                    break;
                default :
                    break;
                }
            }
        });

    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    /**
     * Handles the event where the user enters an input in the command box.
     */
    @FXML
    private void handleKeyInput(KeyEvent event) {
        String keyInputAsString = event.getCharacter();

        if (isKeyPressedEnter(keyInputAsString)) {
            return;
        }

        setStyleToIndicateCorrectCommand();
        String userInput = getUserInputAfterKeyPressed(keyInputAsString);
        updateTooltipForUser(userInput);

    }

    private boolean isKeyPressedEnter(String keyInputAsString) {
        // Enter is \r\n on windows, \n on unix
        return keyInputAsString.equals(CARRIAGE_RETURN) || keyInputAsString.equals(NEW_LINE);
    }

    private void handleUpDownArrow(KeyEvent event) {
        KeyCode key = event.getCode();

        setStyleToIndicateCorrectCommand();
        handleInputHistoryNavigation(key);
        String userInput = commandTextField.getText();
        updateTooltipForUser(userInput);
    }

    /**
     * Get the complete user input taking into account the current key pressed
     * as key pressed event is triggered before the command box text is updated.
     * key is either a backspace, space, letter or digit key.
     * 
     * @param keyAsString the key that was pressed as string
     * @return the full user input taking into account the key pressed
     */
    private String getUserInputAfterKeyPressed(String keyAsString) {
        String userSelectedText = commandTextField.getSelectedText();

        if (!userSelectedText.isEmpty()) {
            commandTextField.replaceSelection(STRING_EMPTY);
        }

        String userInput = commandTextField.getText();
        int caretPosition = commandTextField.getCaretPosition();

        switch (keyAsString) {
        case BACKSPACE_UNICODE :
            // backspace action occurs before event triggers, just return the
            // user input
            return userInput;
        case SPACE_UNICODE :
            return StringUtil.applyStringAtPosition(userInput, STRING_ONE_SPACE, caretPosition);
        default :
            // is a normal letter/digit
            return StringUtil.applyStringAtPosition(userInput, keyAsString, caretPosition);
        }

    }

    /**
     * Updates the tooltip on the GUI for the user to see.
     */
    private void updateTooltipForUser(String userInput) {
        String toDisplay = logic.generateToolTip(userInput);
        resultDisplay.postMessage(toDisplay);
    }

    /**
     * Handles the event where the user is trying to navigate the input history.
     * keyCode must either be up or down arrow key.
     * 
     * @param keyCode the keycode associated with this event
     */
    private void handleInputHistoryNavigation(KeyCode keyCode) {
        assert (keyCode == KeyCode.UP) || (keyCode == KeyCode.DOWN);

        // if attempt to get next command while at latest command input or prev
        // while at earliest, return
        if (desiredInputHistoryUnavailable(keyCode)) {
            return;
        }

        if (isAttemptingToGetPrevInput(keyCode)) {
            handleGetPreviousInput();
        } else {
            handleGetNextInput();
        }

        updateCaretPosition();
    }

    /**
     * Returns whether the user is trying to access a previous or next input in
     * the input history but is already at the limit (either earliest history or
     * latest history respectively). The caller should ensure that the KeyCode
     * passed into this method is either an UP or DOWN only.
     * 
     * @param keyCode the KeyCode pressed
     * @return boolean representing the above
     */
    private boolean desiredInputHistoryUnavailable(KeyCode keyCode) {
        assert keyCode == KeyCode.UP || keyCode == KeyCode.DOWN;

        return isAtEarliestHistoryButWantPrevInput(keyCode) || isAtLatestHistoryButWantNextInput(keyCode);
    }

    /**
     * Returns whether the user is already at the latest input history state but
     * wants to access a next input.
     * 
     * @param keyCode the KeyCode pressed
     * @return boolean representing the above
     */
    private boolean isAtLatestHistoryButWantNextInput(KeyCode keyCode) {
        return inputHistory.isLatestInput() && isAttemptingToGetNextInput(keyCode);
    }

    /**
     * Returns whether the user is already at the earliest input history state
     * but wants to access a previous input.
     * 
     * @param keyCode the KeyCode pressed
     * @return boolean representing the above
     */
    private boolean isAtEarliestHistoryButWantPrevInput(KeyCode keyCode) {
        return inputHistory.isEarliestInput() && isAttemptingToGetPrevInput(keyCode);
    }

    /**
     * Updates the caret position to the end of the current text input in the
     * command box.
     */
    private void updateCaretPosition() {
        String currentInputShown = commandTextField.getText();
        int positionAtEndOfString = currentInputShown.length();

        commandTextField.positionCaret(positionAtEndOfString);
    }

    /**
     * Handles the event where the user wants to get the next input from input
     * history.
     */
    private void handleGetNextInput() {
        // store the current input into the prev first
        String nextInput = inputHistory.nextStep();

        // get a next command input and replace current input
        commandTextField.setText(nextInput);
    }

    /**
     * Handles the event where the user wants to get the previous input from
     * input history.
     */
    private void handleGetPreviousInput() {
        // store the current input and get prev input
        String currentInput = commandTextField.getText();
        String prevInput = inputHistory.prevStep(currentInput);

        // show user the prev input
        commandTextField.setText(prevInput);
    }

    /**
     * Returns whether the user wants to get the previous input from input
     * history.
     * 
     * @param keyCode the key the user pressed to trigger the event
     * @return boolean representing the above
     */
    private boolean isAttemptingToGetPrevInput(KeyCode keyCode) {
        return keyCode == KeyCode.UP;
    }

    /**
     * Returns whether the user wants to get the next input from input history.
     * 
     * @param keyCode the key the user pressed to trigger the event
     * @return boolean representing the above
     */
    private boolean isAttemptingToGetNextInput(KeyCode keyCode) {
        return keyCode == KeyCode.DOWN;
    }

    @FXML
    private void handleCommandInputEntered() {
        // Take a copy of the command text
        previousCommandTest = commandTextField.getText();

        // first push back all 'next' commands into 'prev' command
        // immediately add it to the history of command inputs
        inputHistory.updateInputHistory(previousCommandTest);

        /*
         * We assume the command is correct. If it is incorrect, the command box
         * will be changed accordingly in the event handling code {@link
         * #handleIncorrectCommandAttempted}
         */
        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        commandTextField.setText(STRING_EMPTY);
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Invalid command: " + previousCommandTest));
        setStyleToIndicateIncorrectCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandTest);
    }

    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }

}
```
###### /java/seedu/address/ui/HelpWindow.java
``` java
/**
 * Controller for a help page
 */
public class HelpWindow extends UiPart {

    private static final Logger logger = LogsCenter.getLogger(HelpWindow.class);
    private static final String ICON = "/images/help_icon.png";
    private static final String FXML = "HelpWindow.fxml";
    private static final String TITLE = "Help";

    private AnchorPane mainPane;

    private Stage dialogStage;

    public static HelpWindow load(Stage primaryStage) {
        logger.fine("Showing help page about the application.");
        HelpWindow helpWindow = UiPartLoader.loadUiPart(primaryStage, new HelpWindow());
        helpWindow.configure();
        return helpWindow;
    }

    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    private void configure() {
        Scene scene = new Scene(mainPane);
        // Null passed as the parent stage to make it non-modal.
        dialogStage = createDialogStage(TITLE, null, scene);
        setIcon(dialogStage, ICON);

        scene.setOnKeyPressed(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                dialogStage.close();
            }
        });
    }

    public void show() {
        dialogStage.show();
    }

}
```
###### /java/seedu/address/ui/MainWindow.java
``` java
    public void swapTaskList(boolean isDoneList) {
        taskListPanel.reloadLists(logic.getFilteredUndoneTaskList(), logic.getFilteredDoneTaskList(), isDoneList);
    }
    
```
###### /java/seedu/address/ui/MainWindow.java
``` java
    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage);
        helpWindow.show();
    }

    public void show() {
        primaryStage.show();
    }

```
###### /java/seedu/address/ui/ResultDisplay.java
``` java
/**
 * A ui for the status bar that is displayed at the header of the application.
 */
public class ResultDisplay extends UiPart {

    private static final String NEWLINE_STRING = "\n";
    private static final String STRING_EMPTY = "";
    private static final int HEIGHT_PER_EXTRA_NEWLINE = 17;
    private static final int PREF_HEIGHT = 65;

    public static final String RESULT_DISPLAY_ID = "resultDisplay";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    private final StringProperty displayed = new SimpleStringProperty(STRING_EMPTY);

    private static final String FXML = "ResultDisplay.fxml";

    private TextArea resultDisplayArea;

    private AnchorPane placeHolder;

    private AnchorPane mainPane;

    public static ResultDisplay load(Stage primaryStage, AnchorPane placeHolder) {
        ResultDisplay statusBar = UiPartLoader.loadUiPart(primaryStage, placeHolder, new ResultDisplay());
        statusBar.configure();
        return statusBar;
    }

    public void configure() {
        resultDisplayArea = new TextArea();
        resultDisplayArea.setEditable(false);
        resultDisplayArea.setId(RESULT_DISPLAY_ID);
        resultDisplayArea.getStyleClass().removeAll();
        resultDisplayArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        resultDisplayArea.setText(STRING_EMPTY);
        resultDisplayArea.setWrapText(true);
        resultDisplayArea.textProperty().bind(displayed);
        resultDisplayArea.setPrefHeight(PREF_HEIGHT);

        resultDisplayArea.textProperty().addListener(e -> {
            int newHeight = computeNewHeight();
            setNewHeight(newHeight);
        });

        FxViewUtil.applyAnchorBoundaryParameters(resultDisplayArea, 0.0, 0.0, 0.0, 0.0);
        mainPane.getChildren().add(resultDisplayArea);
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);

    }

    /**
     * Sets the height of the result display to the specified newHeight
     * @param newHeight The new height to set the result display area to
     */
    private void setNewHeight(int newHeight) {
        resultDisplayArea.setMinHeight(newHeight);
        resultDisplayArea.setPrefHeight(newHeight);
        resultDisplayArea.setMaxHeight(newHeight);
    }

    /**
     * Computes the new height of the result display area by considering the
     * number of newline characters present in the text of the result display
     * area.
     * 
     * @return The size of the new height
     */
    private int computeNewHeight() {
        return PREF_HEIGHT + getNumberOfNewLines() * HEIGHT_PER_EXTRA_NEWLINE;
    }

    /**
     * Returns the number of newlines characters in the result display text.
     * @return The number of newline characters
     */
    private int getNumberOfNewLines() {
        String displayedText = resultDisplayArea.getText();
        return StringUtils.countMatches(displayedText, NEWLINE_STRING);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public void postMessage(String message) {
        displayed.setValue(message);
    }

}
```
###### /java/seedu/address/ui/SwitchViewButtons.java
``` java
/**
 * The controller for the buttons used to switch list views between showing
 * undone and done tasks.
 */
public class SwitchViewButtons extends UiPart {
    private final Logger logger = LogsCenter.getLogger(SwitchViewButtons.class);
    private static final String FXML = "SwitchViewButtons.fxml";

    private static final String LIST_UNDONE_COMMAND = "list";
    private static final String LIST_DONE_COMMAND = "list done";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;

    private Logic logic;

    @FXML
    private HBox hbox;

    @FXML
    private ToggleButton showListUndone;

    @FXML
    private ToggleButton showListDone;

    public static SwitchViewButtons load(Stage primaryStage, AnchorPane commandBoxPlaceholder,
            ResultDisplay resultDisplay, Logic logic, InputHistory history) {
        SwitchViewButtons switchViewButtons = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder,
                new SwitchViewButtons());
        switchViewButtons.configure(resultDisplay, logic);
        switchViewButtons.addToPlaceholder();
        return switchViewButtons;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(hbox);
        FxViewUtil.applyAnchorBoundaryParameters(hbox, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);

        final ToggleGroup group = new ToggleGroup();
        showListUndone.setToggleGroup(group);
        showListDone.setToggleGroup(group);
        showListUndone.setSelected(true);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    @FXML
    private void switchToListDoneView() {
        logger.info("Show done tasks button pressed. Switching to list done view.");
        CommandResult cmdRes = logic.execute(LIST_DONE_COMMAND);
        resultDisplay.postMessage(cmdRes.feedbackToUser);
    }

    @FXML
    private void switchToListUndoneView() {
        logger.info("Show undone tasks button pressed. Switching to list undone view.");
        CommandResult cmdRes = logic.execute(LIST_UNDONE_COMMAND);
        resultDisplay.postMessage(cmdRes.feedbackToUser);
    }

    @Subscribe
    private void handleChangeToListDoneViewEvent(ChangeToListDoneViewEvent event) {
        logger.info("Request to switch to list done view detected. Toggling the show done tasks button.");
        showListDone.setSelected(true);
    }

    @Subscribe
    private void handleChangeToListUndoneViewEvent(ChangeToListUndoneViewEvent event) {
        logger.info("Request to switch to list undone view detected. Toggling the show undone tasks button.");
        showListUndone.setSelected(true);
    }

}
```
###### /java/seedu/address/ui/TaskCard.java
``` java
public class TaskCard extends UiPart {

    private static final Paint PAINT_RED = Paint.valueOf("red");
    private static final Paint PAINT_GREEN = Paint.valueOf("green");
    private static final Paint PAINT_YELLOW = Paint.valueOf("yellow");

    private static final String END_DATE_DISPLAY_PREFIX = "End: ";
    private static final String START_DATE_DISPLAY_PREFIX = "Start: ";
    private static final String STRING_EMPTY = "";

    private static final String FXML = "TaskListCard.fxml";
    private static final SimpleDateFormat dateFormatter = new SimpleDateFormat("EEE, d MMM yyyy, h:mm a");

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Rectangle priority;
    @FXML
    private Label startDate;
    @FXML
    private Label endDate;
    @FXML
    private Label recurrenceRate;

    private ReadOnlyTask task;
    private int displayedIndex;

    public TaskCard() {

    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex) {
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        assert task != null && task.getName() != null && task.getPriorityValue() != null;

        setTaskCardIndex();
        setTaskCardName();
        setTaskCardPriority();
        setTaskCardStartDate();
        setTaskCardEndDate();
        setTaskCardRecurrence();
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    // private helper methods below

    /**
     * Sets the task card displayed index to its position in the list.
     */
    private void setTaskCardIndex() {
        assert displayedIndex > 0;

        String taskCardId = displayedIndex + ".";
        id.setText(taskCardId);
    }

    /**
     * Sets the task card name to the name of the task of the task it is
     * displaying.
     */
    private void setTaskCardName() {
        assert task != null && task.getName() != null;

        String taskName = task.getName().toString();
        name.setText(taskName);
    }

    /**
     * Sets the task card priority rectangle to the appropriate color depending
     * on the task priority.
     */
    private void setTaskCardPriority() {
        assert task != null && task.getPriorityValue() != null;

        Priority taskPriority = task.getPriorityValue();

        Paint taskPriorityColour = PAINT_YELLOW;

        taskPriorityColour = getPaintForPriority(taskPriority);

        priority.setFill(taskPriorityColour);
    }

    /**
     * Gets the appropriate Paint given the Priority.
     * 
     * @param priority The priority to retrieve the Paint for
     * @return The Paint for the specified priority
     */
    private Paint getPaintForPriority(Priority priority) {
        switch (priority) {
        case LOW :
            return PAINT_GREEN;
        case MEDIUM :
            return PAINT_YELLOW;
        case HIGH :
            return PAINT_RED;
        default :
            assert false : "priority should only be LOW, MEDIUM, or HIGH";
            return PAINT_YELLOW;
        }
    }

    /**
     * Sets the task card start date to the start date of the task it is
     * displaying.
     */
    private void setTaskCardStartDate() {
        assert task != null;

        String startDateText = STRING_EMPTY;
        boolean hasStartDate = task.getStartDate().isPresent();

        if (hasStartDate) {
            startDateText = prepareStartDateToDisplay();
        }

        startDate.setText(startDateText);
    }

    /**
     * Sets the task card end date to the end date of the task it is displaying.
     */
    private void setTaskCardEndDate() {
        assert task != null;

        String endDateText = STRING_EMPTY;
        boolean hasEndDate = task.getEndDate().isPresent();

        if (hasEndDate) {
            endDateText = prepareEndDateToDisplay();
        }
        endDate.setText(endDateText);
    }

    /**
     * Sets the task card recurrence rate to the recurrence rate of the task it
     * is displaying.
     */
    private void setTaskCardRecurrence() {
        assert task != null;

        String recurrenceRateText = STRING_EMPTY;
        boolean taskIsRecurring = task.getRecurrenceRate().isPresent();

        if (taskIsRecurring) {
            recurrenceRateText = prepareRecurrenceRateToDisplay();
        }

        recurrenceRate.setText(recurrenceRateText);
    }

    /**
     * Prepares the start date for display by converting it into a pretty format
     * as a String.
     * 
     * @return The String representation of the start date for display on the
     *         task card
     */
    private String prepareStartDateToDisplay() {
        assert task != null && task.getStartDate().isPresent();

        Date startDate = task.getStartDate().get();
        return START_DATE_DISPLAY_PREFIX + dateFormatter.format(startDate);
    }

    /**
     * Prepares the end date for display by converting it into a pretty format
     * as a String.
     * 
     * @return The String representation of the end date for display on the task
     *         card
     */
    private String prepareEndDateToDisplay() {
        assert task != null && task.getEndDate().isPresent();

        Date endDate = task.getEndDate().get();
        return END_DATE_DISPLAY_PREFIX + dateFormatter.format(endDate);
    }

    /**
     * Prepares the recurrence rate for display by converting it into a pretty
     * format as a String.
     * 
     * @return The String representation of the recurrence rate for display on
     *         the task card
     */
    private String prepareRecurrenceRateToDisplay() {
        assert task != null && task.getRecurrenceRate().isPresent();

        String recurrenceRateText = task.getRecurrenceRate().get().toString();
        return recurrenceRateText;
    }

}
```
###### /java/seedu/address/ui/UiManager.java
``` java
    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleHelp();
    }

```
###### /resources/view/MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.MainWindow">
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>

       <AnchorPane fx:id="resultDisplayPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="SOMETIMES">

           <padding>
               <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           </padding>
       </AnchorPane>
      <AnchorPane fx:id="switchViewButtonsPlaceholder" styleClass="anchor-pane-with-border">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
      <SplitPane id="splitPane" fx:id="splitPane" VBox.vgrow="ALWAYS">
         <items>
            <VBox fx:id="personList" minWidth="340" prefWidth="340">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                </padding>
               <children>
                  <AnchorPane fx:id="personListPanelPlaceholder" VBox.vgrow="ALWAYS" />
               </children>
            </VBox>
         </items>
      </SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
###### /resources/view/ResultDisplay.fxml
``` fxml

<?import javafx.scene.layout.AnchorPane?>
<?import java.net.URL?>
<AnchorPane styleClass="anchor-pane-with-border" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1"
            fx:controller="seedu.address.ui.ResultDisplay">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
</AnchorPane>
```
###### /resources/view/SwitchViewButtons.fxml
``` fxml

<?import javafx.scene.control.ToggleButton?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>

<AnchorPane styleClass="anchor-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.SwitchViewButtons">
   <children>
      <HBox fx:id="hbox" prefHeight="25.0" prefWidth="200.0">
         <children>
            <ToggleButton fx:id="showListUndone" mnemonicParsing="false" onMouseClicked="#switchToListUndoneView" text="Show Undone Tasks" />
            <ToggleButton fx:id="showListDone" mnemonicParsing="false" onMouseClicked="#switchToListDoneView" text="Show Done Tasks" />
         </children>
      </HBox>
   </children>
</AnchorPane>
```
###### /resources/view/TaskListPanel.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.TaskListPanel">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
        <ListView fx:id="taskListView" style="-fx-background-color: D3D6DB;" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
