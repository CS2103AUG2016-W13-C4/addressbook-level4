# A0093960X
###### \java\seedu\address\history\InputHistory.java
``` java
/**
 * API of the InputHistory component
 */
public interface InputHistory {

    /**
     * Updates the input history with the given userInput String and resets the
     * input history to the latest input state
     * 
     * @param input the input to update the input history with
     */
    public void updateInputHistory(String input);

    /**
     * Returns whether we are already at the earliest input state (no more
     * previous input in memory to backtrack to)
     * 
     * @return boolean representing whether we are already at the earliest input
     *         of the input history
     */
    public boolean isEarliestInput();

    /**
     * Returns whether we are already at the latest input state (no more later
     * input in memory to move forward to)
     * 
     * @return boolean representing whether we are already at the latest input
     *         of the input history
     */
    public boolean isLatestInput();

    /**
     * Executes the action to get the next input from the input history
     * 
     * @return the next input String from the input history
     */
    public String nextStep();

    /**
     * Executes the action to get the previous input from the input history,
     * storing the current input if currently at the latest input state
     * 
     * @param currentInput the current input
     * @return the previous input String from the input history
     */
    public String prevStep(String currentInput);
}
```
###### \java\seedu\address\history\InputHistoryManager.java
``` java
/**
 * Stores the history of user inputs for navigating previous and next user
 * inputs.
 */
public class InputHistoryManager implements InputHistory {

    private static InputHistoryManager theInputHistoryManager;

    // command inputs
    private Stack<String> prevInputs;
    private Stack<String> nextInputs;
    private String currentStoredInputShown;
    
    private static final String STRING_EMPTY = "";


    // Private constructor for Singleton Pattern
    private InputHistoryManager() {
        prevInputs = new Stack<String>();
        nextInputs = new Stack<String>();
        currentStoredInputShown = STRING_EMPTY;
    }

    // Use Singleton Pattern here
    public static InputHistoryManager getInstance() {
        if (theInputHistoryManager == null) {
            theInputHistoryManager = new InputHistoryManager();
        }
        return theInputHistoryManager;
    }

    @Override
    public void updateInputHistory(String userInput) {
        assert prevInputs != null && nextInputs != null && currentStoredInputShown != null;

        if (!isLatestInput()) {
            pushToPrevInput(currentStoredInputShown);
        }

        resetInputHistoryToLatestState();
        pushToPrevInput(userInput);
        currentStoredInputShown = STRING_EMPTY;
    }

    @Override
    public boolean isEarliestInput() {
        assert prevInputs != null;
        return prevInputs.isEmpty();
    }

    @Override
    public boolean isLatestInput() {
        assert nextInputs != null;
        return nextInputs.isEmpty();
    }

    @Override
    public String prevStep(String currentInput) {
        String inputToStore;

        if (isLatestInput()) {
            inputToStore = currentInput;
        } else {
            inputToStore = currentStoredInputShown;
        }

        pushToNextInput(inputToStore);
        return popFromPrevInput();
    }

    @Override
    public String nextStep() {
        pushToPrevInput(currentStoredInputShown);
        return popFromNextInput();
    }

    // private helper methods below

    /**
     * Resets the previous and next input history to the latest state,
     * transferring all the valid next input into the previous input history.
     */
    private void resetInputHistoryToLatestState() {

        boolean isEarliestNextInputValid = isLatestInput();
        String nextInputToTransfer;

        while (!isLatestInput()) {
            nextInputToTransfer = popFromNextInput();
            pushToPrevInput(nextInputToTransfer);
        }

        if (!isEarliestNextInputValid) {
            popFromPrevInput();
        }
    }

    /**
     * Pops and returns the last stored previous input from the previous input
     * history. The caller should ensure that the previous input history is not
     * empty.
     * 
     * @return the last stored previous input String
     */
    private String popFromPrevInput() {
        assert prevInputs != null && prevInputs.size() > 0;
        currentStoredInputShown = prevInputs.pop();
        return currentStoredInputShown;
    }

    /**
     * Pops and returns the last stored next input from the next input history.
     * The caller should ensure that the next input history is not empty.
     * 
     * @return the last stored next input String
     */
    private String popFromNextInput() {
        assert nextInputs != null && nextInputs.size() > 0;
        currentStoredInputShown = nextInputs.pop();
        return currentStoredInputShown;
    }

    /**
     * Pushes the given input into the previous input history.
     */
    private void pushToPrevInput(String input) {
        assert prevInputs != null;
        prevInputs.push(input);
    }

    /**
     * Pushes the given input into the next input history.
     */
    private void pushToNextInput(String input) {
        assert nextInputs != null;
        nextInputs.push(input);
    }

}
```
###### \java\seedu\address\history\UndoableCommandHistory.java
``` java
/**
 * API of the UndoableCommandHistory Component.
 */
public interface UndoableCommandHistory {

    /**
     * Updates the UndoableCommand history with the given UndoableCommand
     * 
     * @param undoableCommand the UndoableCommand to update the history with
     */
    public void updateCommandHistory(UndoableCommand undoableCommand);

    /**
     * Returns whether we are already at the earliest command state (there is
     * nothing to undo anymore)
     * 
     * @return boolean representing whether we are already at the earliest
     *         command of the undoable command history
     */
    public boolean isEarliestCommand();

    /**
     * Returns whether we are already at the latest command state (there is
     * nothing to redo anymore)
     * 
     * @return boolean representing whether we are already at the latest command
     *         of the redoable command history
     */
    public boolean isLatestCommand();

    /**
     * Executes an undo step on the command history, returning the
     * UndoableCommand that was undone
     * 
     * @return the UndoableCommand that was undone
     */
    public UndoableCommand undoStep();

    /**
     * Executes a redo step on the command history, returning the
     * UndoableCommand that was redone
     * 
     * @return the UndoableCommand that was redone
     */
    public UndoableCommand redoStep();

}
```
###### \java\seedu\address\history\UndoableCommandHistoryManager.java
``` java
/**
 * Stores the history of undoable and redoable commands.
 */
public class UndoableCommandHistoryManager implements UndoableCommandHistory {

    private static UndoableCommandHistoryManager theUndoableCommandHistory;

    // command effects
    private Stack<UndoableCommand> undoableCommands;
    private Stack<UndoableCommand> redoableCommands;

    // Private constructor for Singleton Pattern
    private UndoableCommandHistoryManager() {
        undoableCommands = new Stack<UndoableCommand>();
        redoableCommands = new Stack<UndoableCommand>();
    }

    // Use Singleton Pattern here
    public static UndoableCommandHistoryManager getInstance() {
        if (theUndoableCommandHistory == null) {
            theUndoableCommandHistory = new UndoableCommandHistoryManager();
        }
        return theUndoableCommandHistory;
    }

    @Override
    public void updateCommandHistory(UndoableCommand undoableCommand) {
        assert undoableCommands != null;
        undoableCommands.push(undoableCommand);
        resetRedo();
    }

    @Override
    public boolean isEarliestCommand() {
        assert undoableCommands != null;
        return undoableCommands.isEmpty();
    }

    @Override
    public boolean isLatestCommand() {
        assert redoableCommands != null;
        return redoableCommands.isEmpty();
    }

    @Override
    public UndoableCommand undoStep() {
        assert redoableCommands != null && undoableCommands != null;
        return redoableCommands.push(undoableCommands.pop());
    }

    @Override
    public UndoableCommand redoStep() {
        assert redoableCommands != null && undoableCommands != null;
        return undoableCommands.push(redoableCommands.pop());
    }

    /**
     * Resets the redoable command history
     */
    private void resetRedo() {
        redoableCommands = new Stack<UndoableCommand>();
    }

}
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null && toAdd != null;

        try {
            model.deleteTask(toAdd);
        } catch (TaskNotFoundException e) {
            return new CommandResult(String.format(MESSAGE_UNDO_FAILURE, toAdd));
        }

        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, toAdd));

    }
    
```
###### \java\seedu\address\logic\commands\ClearCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null && clearedTasks != null;
           
        // attempt to undo the clear by adding back the list of tasks that was cleared
        // add back to the list the user was viewing when clear was executed
        if (viewingDoneList) {
            model.setTaskManagerDoneList(clearedTasks);

        }
        else {
            model.setTaskManagerUndoneList(clearedTasks);

        }
        
        return new CommandResult(MESSAGE_UNDO_SUCCESS);
    }
    
```
###### \java\seedu\address\logic\commands\DeleteCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null && deletedTasks != null;    
        
        // attempt to undo the delete by adding back the list of tasks that was deleted
        // add back to the list the user was viewing when clear was executed
        if (isViewingDoneList) {
            model.addDoneTasks(deletedTasks);
        }
        else {
            model.addTasks(deletedTasks);
        }
        
        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, deletedTasks));
    }
```
###### \java\seedu\address\logic\commands\DoneCommand.java
``` java
    @Override
    public CommandResult undo() {
        doneTasksUndoFail = new ArrayList<Task>();
        
        for (Task doneTask : doneTasks){
            try {
                model.deleteDoneTask(doneTask);
            } catch (TaskNotFoundException e) {
                doneTasksUndoFail.add(doneTask);
            }
        }
        
        for (Task readdedRecurTask : readdedRecurringTasks) { 
            try {
                model.deleteTask(readdedRecurTask);
            } catch (TaskNotFoundException e) {
                doneTasksUndoFail.add(readdedRecurTask);
            }
        }
        
        model.addTasks(doneTasks);
        return new CommandResult(MESSAGE_DONE_UNDO_SUCCESS);
    }

```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
    @Override
    public CommandResult undo() {
        // edit all the fields back to the state before the edit took place
        
        // save this for printing purposes
        Task toUndoForPrint = new Task(toEdit);
        
        Task toUndo = toEdit;
        
        System.out.println(toUndo);
        
        Name previousTaskName = beforeEdit.getName();
        Optional<Date> previousStartDate = beforeEdit.getStartDate();
        Optional<Date> previousEndDate = beforeEdit.getEndDate();
        Priority previousPriority = beforeEdit.getPriorityValue();
        Optional<RecurrenceRate> previousReccurence = beforeEdit.getRecurrenceRate();
        
        Date undoStartDate = null;
        Date undoEndDate = null;
        RecurrenceRate undoRecurrenceRate = null;
       
        // edit back the start date
        if (previousStartDate.isPresent()) {
            undoStartDate = previousStartDate.get();
        }
       
        // edit back the end date
        if (previousEndDate.isPresent()) {
            undoEndDate = previousEndDate.get();
        }
        
        // edit back the recurrence rate
        if (previousReccurence.isPresent()) {
            undoRecurrenceRate = previousReccurence.get();
        }
                   
        model.editTask(toUndo, previousTaskName, undoStartDate, undoEndDate, previousPriority, undoRecurrenceRate);      
        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, toUndoForPrint, toUndo));
    }
```
###### \java\seedu\address\logic\commands\HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows program usage instructions.\n"
            + "Example: " + COMMAND_WORD;

    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";
    
    public static final String TOOL_TIP = "help";

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ShowHelpRequestEvent());
        return new CommandResult(SHOWING_HELP_MESSAGE);
    }
}
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
/**
 * Redoes the latest UndoableCommand that was undone.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Reverses the last undo command, reversing the effect on the task manager.\n" + "Example: "
            + COMMAND_WORD;

    public static final String TOOL_TIP = "redo";

    public static final String MESSAGE_FAILURE = "There is nothing to redo.";

    public RedoCommand() {
    }

    @Override
    public CommandResult execute() {
        assert history != null;

        if (history.isLatestCommand()) {
            return new CommandResult(MESSAGE_FAILURE);
        }

        UndoableCommand cmdToRedo = history.redoStep();
        return cmdToRedo.execute();
    }

}
```
###### \java\seedu\address\logic\commands\UndoableCommand.java
``` java
public abstract class UndoableCommand extends Command {

    protected boolean isRedoAction;

    /**
     * Undoes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult undo();

    /**
     * Updates the history of undoable commands with this undoable command, if this
     * command is not a command that was executed as part of a redo command.
     */
    public void updateHistory() {

        if (isRedoAction) {
            return;
        }

        history.updateCommandHistory(this);
        isRedoAction = true;
    }

}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
/**
 * Undoes the latest UndoableCommand that was recorded in the undoable command
 * history.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undoes the last reversible command, reversing the effect on the task manager.\n" + "Example: "
            + COMMAND_WORD;

    public static final String TOOL_TIP = "undo";

    public static final String MESSAGE_FAILURE = "There is nothing to undo.";

    public UndoCommand() {
    }

    @Override
    public CommandResult execute() {
        assert history != null;

        if (history.isEarliestCommand()) {
            return new CommandResult(MESSAGE_FAILURE);
        }

        UndoableCommand cmdToUndo = history.undoStep();
        return cmdToUndo.undo();

    }

}
```
###### \java\seedu\address\model\item\ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override
     * .equals) All fields must be equal.
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getPriorityValue().equals(this.getPriorityValue())
                && other.getStartDate().equals(this.getStartDate())
                && other.getEndDate().equals(this.getEndDate())
                && other.getRecurrenceRate().equals(this.getRecurrenceRate()));
    }
       
```
###### \java\seedu\address\model\item\Task.java
``` java
    @Override
    public boolean equals(Object other) {

        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instance of handles null
                && this.isSameStateAs((ReadOnlyTask) other));

    }

    @Override
    public int compareTo(Task other) {

        int compareByDateValue = compareByDate(other);
        if (compareByDateValue != 0) {
            return compareByDateValue;
        }

        if (haveDifferentPriority(other)) {
            return compareByPriorityValue(other);
        } else {
            return compareByTaskName(other);
        }

    }

```
###### \java\seedu\address\model\item\Task.java
``` java
    /**
     * Compares this Task with other Task by date chronologically.
     * The result is a negative integer if this Task object chronologically precedes the argument Task.
     * The result is a positive integer if this Task object chronologically follows the argument Task.
     * The result is zero if the Dates of the Tasks are chronologically equal.
     *  
     * Tasks with at least one type of date (start date only, end date only, both start and end date)
     * will always chronologically precede Tasks without any dates.
     * 
     * If both Tasks have at least one type of date, but are chronologically equal 
     * Example: this Task has an end date that is equal to the start date and end date of another Task
     * Example 2: this Task has a start date that is equal to the end date of another Task
     * 
     * Tasks will be ordered in this manner:
     * 1. Tasks with start dates only
     * 2. Tasks with start dates and end dates
     * 3. Tasks with end dates only
     * 
     * @param other the other Task to compare by Date with
     * @return the value 0 if the argument Task is equal to this Task, a value less than 0 if this Task 
     *         chronologically precedes the argument Task and a value more than 0 
     *         if this Task chronologically follows the argument Task
     */
    private int compareByDate(Task other) {

        boolean hasStartDate = isStartDatePresent(this);
        boolean hasEndDate = isEndDatePresent(this);
        boolean hasStartDateOther = isStartDatePresent(other); 
        boolean hasEndDateOther = isEndDatePresent(other);
        
        boolean hasNoDates = !hasDate(this);
        boolean hasNoDatesOther = !hasDate(other);
        int compareByDateValue;
        
        if (hasNoDates && hasNoDatesOther) {
            return CHRONOLOGICALLY_EQUAL;
        } else if (hasNoDates) {
            return CHRONOLOGICALLY_AFTER;
        } else if (hasNoDatesOther) {
            return CHRONOLOGICALLY_BEFORE;
        }

        // Easy case 1
        if (!hasStartDate && hasEndDate && !hasStartDateOther && hasEndDateOther) {
            return endDate.compareTo(other.endDate);
        }
        
        // Easy case 3
        if (hasStartDate && !hasEndDate && !hasStartDateOther && hasEndDateOther) {
            return startDate.compareTo(other.endDate);
        }

        // Easy case 4
        if (hasStartDate && !hasEndDate && hasStartDateOther && !hasEndDateOther) {
            return startDate.compareTo(other.startDate);
        }

        // Easy case 2
        if (!hasStartDate && hasEndDate && hasStartDateOther && !hasEndDateOther) {
            compareByDateValue = endDate.compareTo(other.startDate);
            if (compareByDateValue == CHRONOLOGICALLY_EQUAL) {
                return CHRONOLOGICALLY_AFTER;
            }
            return compareByDateValue;
        }

        // Medium case 1
        if (!hasStartDate && hasEndDate && hasStartDateOther && hasEndDateOther) {
            compareByDateValue = endDate.compareTo(other.startDate);
            if (compareByDateValue != CHRONOLOGICALLY_EQUAL) {
                return compareByDateValue;
            }

            compareByDateValue = endDate.compareTo(other.endDate);
            if (compareByDateValue == CHRONOLOGICALLY_EQUAL) {
                return CHRONOLOGICALLY_AFTER;
            }
            return compareByDateValue;
        }

        // Medium case 2
        if (hasStartDate && !hasEndDate && hasStartDateOther && hasEndDateOther) {
            compareByDateValue = startDate.compareTo(other.startDate);
            if (compareByDateValue != CHRONOLOGICALLY_EQUAL) {
                return compareByDateValue;
            }

            compareByDateValue = startDate.compareTo(other.endDate);
            return compareByDateValue;
        }

        // Medium case 3
        if (hasStartDate && hasEndDate && !hasStartDateOther && hasEndDateOther) {
            compareByDateValue = startDate.compareTo(other.endDate);
            if (compareByDateValue != CHRONOLOGICALLY_EQUAL) {
                return compareByDateValue;
            }

            compareByDateValue = endDate.compareTo(other.endDate);
            return compareByDateValue;
        }

        // Medium case 4
        if (hasStartDate && hasEndDate && hasStartDateOther && !hasEndDateOther) {
            compareByDateValue = startDate.compareTo(other.startDate);
            if (compareByDateValue != CHRONOLOGICALLY_EQUAL) {
                return compareByDateValue;
            }

            compareByDateValue = endDate.compareTo(other.startDate);
            if (compareByDateValue == CHRONOLOGICALLY_EQUAL) {
                return CHRONOLOGICALLY_AFTER;
            }
            return compareByDateValue;
        }

        // Final case
        // compare start first
        compareByDateValue = startDate.compareTo(other.startDate);
        if (compareByDateValue != CHRONOLOGICALLY_EQUAL) {
            return compareByDateValue;
        }
        // compare the end dates
        return endDate.compareTo(other.endDate);

    }

    private boolean hasDate(Task task) {
        return task.isStartDatePresent(task) || task.isEndDatePresent(task);
    }

    private boolean isEndDatePresent(Task task) {
        return task.endDate != null;
    }

    private boolean isStartDatePresent(Task task) {
        return task.startDate != null;
    }
    
```
###### \java\seedu\address\storage\XmlAdaptedRecurrenceRate.java
``` java
public class XmlAdaptedRecurrenceRate {

    @XmlElement(required = true)
    private String rate;
    @XmlElement(required = true)
    private String timePeriod;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedRecurrenceRate() {
    }

    /**
     * Converts a given RecurrenceRate into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created
     *            XmlAdaptedRecurrenceRate
     */
    public XmlAdaptedRecurrenceRate(RecurrenceRate source) {
        assert source.getRate() != null && source.getTimePeriod() != null;

        rate = source.getRate().toString();
        timePeriod = source.getTimePeriod().toString();

    }

    /**
     * Converts this jaxb-friendly adapted RecurrenceRate object into the
     * model's RecurrenceRate object.
     *
     * @throws IllegalValueException if there were any data constraints violated
     *             in the adapted recurrence rate
     */
    public RecurrenceRate toModelType() throws IllegalValueException {
        return new RecurrenceRate(this.rate, this.timePeriod);
    }
}
```
###### \java\seedu\address\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    private static SimpleDateFormat dateParser = new SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy");

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String priority;
    @XmlElement
    private String startDate;
    @XmlElement
    private String endDate;
    @XmlElement
    private XmlAdaptedRecurrenceRate recurrenceRate;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {
    }

    /**
     * Converts a given Task into this class for JAXB use. Future changes to
     * this will not affect the created XmlAdaptedTask.
     *
     * @param source the task to convert
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        saveName(source);
        savePriority(source);
        saveStartDateIfPresent(source);
        saveEndDateIfPresent(source);
        saveRecurrenceRateIfPresent(source);
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task
     * object.
     *
     * @throws IllegalValueException if there were any data constraints violated
     *             in the adapted task
     * @throws ParseException
     */
    public Task toModelType() throws IllegalValueException, ParseException {
        Name nameForModel = getNameFromStoredTask();
        Priority priorityForModel = getPriorityFromStoredTask();

        Date startDateForModel = getStartDateFromStoredTask();
        Date endDateForModel = getEndDateFromStoredTask();
        RecurrenceRate recurrenceRateForModel = getRecurrenceRateFromStoredTask();

        return new Task(nameForModel, startDateForModel, endDateForModel, recurrenceRateForModel,
                priorityForModel);
    }

    /**
     * Saves the name of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void saveName(ReadOnlyTask source) {
        name = source.getName().getTaskName();
    }

    /**
     * Saves the priority of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void savePriority(ReadOnlyTask source) {
        String priorityString = source.getPriorityValue().toString();
        priority = priorityString.toLowerCase();
    }

    /**
     * Saves the start date of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void saveStartDateIfPresent(ReadOnlyTask source) {
        boolean hasStartDate = source.getStartDate().isPresent();

        if (hasStartDate) {
            startDate = source.getStartDate().get().toString();
        }
    }

    /**
     * Saves the end date of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void saveEndDateIfPresent(ReadOnlyTask source) {
        boolean hasEndDate = source.getEndDate().isPresent();

        if (hasEndDate) {
            endDate = source.getEndDate().get().toString();
        }
    }

    /**
     * Saves the recurrence rate of the source ReadOnlyTask into the
     * XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void saveRecurrenceRateIfPresent(ReadOnlyTask source) {
        boolean hasRecurrenceRate = source.getRecurrenceRate().isPresent();

        if (hasRecurrenceRate) {
            recurrenceRate = new XmlAdaptedRecurrenceRate(source.getRecurrenceRate().get());
        }
    }

    /**
     * Retrieves the Name associated with the stored task.
     * 
     * @return the Name associated with the stored task
     */
    private Name getNameFromStoredTask() {
        assert name != null;

        return new Name(name);
    }

    /**
     * Retrieves the Priority associated with the stored task. If the priority
     * string in the stored task does not match any valid priority strings, the
     * task will be given a default medium priority.
     * 
     * @return the Priority associated with the stored task
     */
    private Priority getPriorityFromStoredTask() {
        //assert priority != null;
        
        return Priority.convertStringToPriority(priority);
    }

    /**
     * Retrieves the start date Date associated with the stored task. Returns
     * null if there is no start date associated with the stored task.
     * 
     * @return the start date Date associated with the task, or null if no start
     *         date is associated with the current stored task.
     * @throws ParseException if the format of the start date does not conform
     *             to the expected format
     */
    private Date getStartDateFromStoredTask() throws ParseException {
        if (startDate == null) {
            return null;
        }
        return dateParser.parse(startDate);
    }

    /**
     * Retrieves the end date Date associated with the stored task. Returns null
     * if there is no end date associated with the stored task.
     * 
     * @return the end date Date associated with the task, or null if no end
     *         date is associated with the current stored task.
     * @throws ParseException if the format of the end date does not conform to
     *             the expected format
     */
    private Date getEndDateFromStoredTask() throws ParseException {
        if (endDate == null) {
            return null;
        }

        return dateParser.parse(endDate);
    }

    /**
     * Retrieves the ReccurenceRate associated with the stored task. Returns
     * null if there is no recurrence rate associated with the stored task.
     * 
     * @return the RecurrenceRate associated with the task, or null if no
     *         recurrence rate is associated with the current stored task.
     * 
     * @throws IllegalValueException
     * @throws ParseException
     */
    private RecurrenceRate getRecurrenceRateFromStoredTask() throws IllegalValueException {
        if (recurrenceRate == null) {
            return null;
        }

        return recurrenceRate.toModelType();
    }

}
```
###### \java\seedu\address\ui\CommandBox.java
``` java
public class CommandBox extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;
    String previousCommandTest;

    private Logic logic;
    private InputHistory inputHistory;

    private static final String BACKSPACE_UNICODE = "\u0008";
    private static final String SPACE_UNICODE = "\u0020";
    private static final String CARRIAGE_RETURN = "\r";
    private static final String NEW_LINE = "\n";
    private static final String STRING_EMPTY = "";

    @FXML
    private TextField commandTextField;
    private CommandResult mostRecentResult;

    public static CommandBox load(Stage primaryStage, AnchorPane commandBoxPlaceholder, ResultDisplay resultDisplay,
            Logic logic, InputHistory history) {
        CommandBox commandBox = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new CommandBox());
        commandBox.configure(resultDisplay, logic, history);
        commandBox.addToPlaceholder();
        return commandBox;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic, InputHistory history) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        this.inputHistory = history;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);

        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent keyEvent) {
                switch (keyEvent.getCode()) {
                case UP:
                    // Fallthrough
                case DOWN:
                    keyEvent.consume();
                    handleUpDownArrow(keyEvent);
                default:
                    break;
                }
            }
        });

    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    /**
     * Handles the event where the user presses a key in the command box.
     */
    @FXML
    private void handleKeyInput(KeyEvent event) {
        String keyInputAsString = event.getCharacter();

        boolean keyIsEnter = checkIfEnterPressed(keyInputAsString);

        if (keyIsEnter) {
            return;
        }

        // reset incorrect command style on command box
        setStyleToIndicateCorrectCommand();

        String userInput = getUserInputAfterKeyPressed(keyInputAsString);
        updateTooltipForUser(userInput);

    }

    private boolean checkIfEnterPressed(String keyInputAsString) {
        // Enter is \r\n on windows, \n on unix
        return keyInputAsString.equals(CARRIAGE_RETURN) || keyInputAsString.equals(NEW_LINE);
    }

    private void handleUpDownArrow(KeyEvent event) {
        KeyCode key = getKeyCodeFromEvent(event);

        setStyleToIndicateCorrectCommand();
        handleInputHistoryNavigation(key);
        /*
         * String userInput = getUserInputAfterKeyPressed(key);
         */
        String userInput = commandTextField.getText();
        updateTooltipForUser(userInput);
    }

    /**
     * Get the complete user input taking into account the current key pressed
     * as key pressed event is triggered before the command box text is updated.
     * key is either a backspace, space, letter or digit key.
     * 
     * @param keyAsString the key that was pressed as string
     * @return the full user input taking into account the key pressed
     */
    private String getUserInputAfterKeyPressed(String keyAsString) {
        String userSelectedText = commandTextField.getSelectedText();

        if (!userSelectedText.isEmpty()) {
            commandTextField.replaceSelection(STRING_EMPTY);
        }

        String userInput = commandTextField.getText();
        int caretPosition = commandTextField.getCaretPosition();

        switch (keyAsString) {
        case BACKSPACE_UNICODE:
            // backspace action occurs before event triggers, just return the
            // user input
            return userInput;
        case SPACE_UNICODE:
            return applySpaceAtPosition(userInput, caretPosition);
        default:
            // is a normal letter/digit
            return applyKeyAtPosition(userInput, keyAsString, caretPosition);
        }

    }

    /**
     * Returns a string that is the result of adding the given key in the
     * specified position of the string.
     * 
     * @param userInput the user input
     * @param keyString the key as a string
     * @param position the position to add the key
     * @return string with key at the specified position in the user input
     *         string
     */
    private String applyKeyAtPosition(String userInput, String keyString, int position) {
        return userInput.substring(0, position) + keyString + userInput.substring(position);
    }

    /**
     * Returns the key code associated with the Key Event
     * 
     * @param event the KeyEvent
     * @return the key code associated
     */
    private KeyCode getKeyCodeFromEvent(KeyEvent event) {
        return event.getCode();
    }

    /**
     * Updates the tooltip on the GUI for the user to see.
     */
    private void updateTooltipForUser(String userInput) {
        String toDisplay = logic.generateToolTip(userInput);
        resultDisplay.postMessage(toDisplay);
    }

    /**
     * Returns a string with a single whitespace character appended to the back
     * of the given user input string
     * 
     * @param userInput
     * @return
     */
    private String applySpaceAtPosition(String userInput, int position) {
        return userInput.substring(0, position) + " " + userInput.substring(position);
    }

    /**
     * Handles the event where the user is trying to navigate the input history.
     * keyCode must either be up or down arrow key.
     * 
     * @param keyCode the keycode associated with this event
     */
    private void handleInputHistoryNavigation(KeyCode keyCode) {
        assert keyCode == KeyCode.UP || keyCode == KeyCode.DOWN;

        boolean wantPrev = checkIfWantPrevInput(keyCode);

        // if attempt to get next command while at latest command input or prev
        // while at earliest, return
        if (desiredInputHistoryUnavailable(wantPrev)) {
            return;
        }

        if (wantPrev) {
            handleGetPreviousInput();
        } else {
            // else the user wants next
            handleGetNextInput();
        }

        updateCaretPosition();
    }

    /**
     * Returns whether the user is trying to access a previous or next input in
     * the input history but is already at the limit (either earliest history or
     * latest history respectively).
     * 
     * @param wantPrev boolean representing if the user wants the previous input
     * @return
     */
    private boolean desiredInputHistoryUnavailable(boolean wantPrev) {
        boolean wantNext = !wantPrev;
        boolean atEarliestHistoryButWantPrevInput = inputHistory.isEarliestInput() && wantPrev;
        boolean atLatestHistoryButWantNextInput = inputHistory.isLatestInput() && wantNext;

        return atEarliestHistoryButWantPrevInput || atLatestHistoryButWantNextInput;
    }

    /**
     * Updates the caret position to the end of the current text input in the
     * command box.
     */
    private void updateCaretPosition() {
        String currentInputShown = commandTextField.getText();
        int positionAtEndOfString = currentInputShown.length();

        commandTextField.positionCaret(positionAtEndOfString);
    }

    /**
     * Handles the event where the user wants to get the next input from input
     * history.
     */
    private void handleGetNextInput() {
        // store the current input into the prev first
        String nextInput = inputHistory.nextStep();

        // get a next command input and replace current input
        commandTextField.setText(nextInput);
    }

    /**
     * Handles the event where the user wants to get the previous input from
     * input history.
     */
    private void handleGetPreviousInput() {
        // store the current input and get prev input
        String currentInput = commandTextField.getText();
        String prevInput = inputHistory.prevStep(currentInput);

        // show user the prev input
        commandTextField.setText(prevInput);
    }

    /**
     * Returns whether the user wants to get the previous input from input
     * history.
     * 
     * @param keyCode the key the user pressed to trigger the event
     * @return boolean representing the above
     */
    private boolean checkIfWantPrevInput(KeyCode keyCode) {
        return keyCode == KeyCode.UP;
    }

    @FXML
    private void handleCommandInputEntered() {
        // Take a copy of the command text
        previousCommandTest = commandTextField.getText();

        // first push back all 'next' commands into 'prev' command
        // immediately add it to the history of command inputs
        inputHistory.updateInputHistory(previousCommandTest);

        /*
         * We assume the command is correct. If it is incorrect, the command box
         * will be changed accordingly in the event handling code {@link
         * #handleIncorrectCommandAttempted}
         */
        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        commandTextField.setText(STRING_EMPTY);
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Invalid command: " + previousCommandTest));
        setStyleToIndicateIncorrectCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandTest);
    }

    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }

}
```
###### \java\seedu\address\ui\HelpWindow.java
``` java
/**
 * Controller for a help page
 */
public class HelpWindow extends UiPart {

    private static final Logger logger = LogsCenter.getLogger(HelpWindow.class);
    private static final String ICON = "/images/help_icon.png";
    private static final String FXML = "HelpWindow.fxml";
    private static final String TITLE = "Help";

    private AnchorPane mainPane;

    private Stage dialogStage;

    public static HelpWindow load(Stage primaryStage) {
        logger.fine("Showing help page about the application.");
        HelpWindow helpWindow = UiPartLoader.loadUiPart(primaryStage, new HelpWindow());
        helpWindow.configure();
        return helpWindow;
    }

    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    private void configure() {
        Scene scene = new Scene(mainPane);
        // Null passed as the parent stage to make it non-modal.
        dialogStage = createDialogStage(TITLE, null, scene);
        setIcon(dialogStage, ICON);

        scene.setOnKeyPressed(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                dialogStage.close();
            }
        });
    }

    public void show() {
        dialogStage.show();
    }

}
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    public void swapTaskList(boolean isDoneList) {
        taskListPanel.reloadLists(logic.getFilteredUndoneTaskList(), logic.getFilteredDoneTaskList(), isDoneList);
    }
    
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage);
        helpWindow.show();
    }

    public void show() {
        primaryStage.show();
    }

```
###### \java\seedu\address\ui\ResultDisplay.java
``` java
/**
 * A ui for the status bar that is displayed at the header of the application.
 */
public class ResultDisplay extends UiPart {

    private static final String NEWLINE_STRING = "\n";
    private static final String STRING_EMPTY = "";
    private static final int HEIGHT_PER_EXTRA_NEWLINE = 17;
    private static final int PREF_HEIGHT = 65;

    public static final String RESULT_DISPLAY_ID = "resultDisplay";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    private final StringProperty displayed = new SimpleStringProperty(STRING_EMPTY);

    private static final String FXML = "ResultDisplay.fxml";

    private TextArea resultDisplayArea;

    private AnchorPane placeHolder;

    private AnchorPane mainPane;

    public static ResultDisplay load(Stage primaryStage, AnchorPane placeHolder) {
        ResultDisplay statusBar = UiPartLoader.loadUiPart(primaryStage, placeHolder, new ResultDisplay());
        statusBar.configure();
        return statusBar;
    }

    public void configure() {
        resultDisplayArea = new TextArea();
        resultDisplayArea.setEditable(false);
        resultDisplayArea.setId(RESULT_DISPLAY_ID);
        resultDisplayArea.getStyleClass().removeAll();
        resultDisplayArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        resultDisplayArea.setText(STRING_EMPTY);
        resultDisplayArea.setWrapText(true);
        resultDisplayArea.textProperty().bind(displayed);
        resultDisplayArea.setPrefHeight(PREF_HEIGHT);

        resultDisplayArea.textProperty().addListener(e -> {
            int newHeight = computeNewHeight();
            setNewHeight(newHeight);
        });

        FxViewUtil.applyAnchorBoundaryParameters(resultDisplayArea, 0.0, 0.0, 0.0, 0.0);
        mainPane.getChildren().add(resultDisplayArea);
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);

    }

    /**
     * @param newHeight
     */
    private void setNewHeight(int newHeight) {
        resultDisplayArea.setMinHeight(newHeight);
        resultDisplayArea.setPrefHeight(newHeight);
        resultDisplayArea.setMaxHeight(newHeight);
    }

    /**
     * Computes the new height of the result display area by considering the
     * number of newline characters present in the text of the result display
     * area.
     * 
     * @return
     */
    private int computeNewHeight() {
        return PREF_HEIGHT + getNumberOfNewLines() * HEIGHT_PER_EXTRA_NEWLINE;
    }

    /**
     * Returns 
     * @return
     */
    private int getNumberOfNewLines() {
        String displayedText = resultDisplayArea.getText();
        return StringUtils.countMatches(displayedText, NEWLINE_STRING);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public void postMessage(String message) {
        displayed.setValue(message);
    }

}
```
###### \java\seedu\address\ui\SwitchViewButtons.java
``` java
/**
 * The controller for the buttons used to switch list views between showing
 * undone and done tasks.
 */
public class SwitchViewButtons extends UiPart {
    private final Logger logger = LogsCenter.getLogger(SwitchViewButtons.class);
    private static final String FXML = "SwitchViewButtons.fxml";

    private static final String LIST_UNDONE_COMMAND = "list";
    private static final String LIST_DONE_COMMAND = "list done";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;

    private Logic logic;

    @FXML
    private HBox hb;

    @FXML
    private ToggleButton showListUndone;

    @FXML
    private ToggleButton showListDone;

    public static SwitchViewButtons load(Stage primaryStage, AnchorPane commandBoxPlaceholder,
            ResultDisplay resultDisplay, Logic logic, InputHistory history) {
        SwitchViewButtons switchViewButtons = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder,
                new SwitchViewButtons());
        switchViewButtons.configure(resultDisplay, logic);
        switchViewButtons.addToPlaceholder();
        return switchViewButtons;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(hb);
        FxViewUtil.applyAnchorBoundaryParameters(hb, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);

        final ToggleGroup group = new ToggleGroup();
        showListUndone.setToggleGroup(group);
        showListDone.setToggleGroup(group);
        showListUndone.setSelected(true);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    @FXML
    private void switchToListDoneView() {
        logger.info("Show done tasks button pressed. Switching to list done view.");
        CommandResult cmdRes = logic.execute(LIST_DONE_COMMAND);
        resultDisplay.postMessage(cmdRes.feedbackToUser);
    }

    @FXML
    private void switchToListUndoneView() {
        logger.info("Show undone tasks button pressed. Switching to list undone view.");
        CommandResult cmdRes = logic.execute(LIST_UNDONE_COMMAND);
        resultDisplay.postMessage(cmdRes.feedbackToUser);
    }

    @Subscribe
    private void handleChangeToListDoneViewEvent(ChangeToListDoneViewEvent event) {
        logger.info("Request to switch to list done view detected. Toggling the show done tasks button.");
        showListDone.setSelected(true);
    }

    @Subscribe
    private void handleChangeToListUndoneViewEvent(ChangeToListUndoneViewEvent event) {
        logger.info("Request to switch to list undone view detected. Toggling the show undone tasks button.");
        showListUndone.setSelected(true);
    }

}
```
###### \java\seedu\address\ui\TaskCard.java
``` java
public class TaskCard extends UiPart {

    private static final Paint PAINT_RED = Paint.valueOf("red");
    private static final Paint PAINT_GREEN = Paint.valueOf("green");
    private static final Paint PAINT_YELLOW = Paint.valueOf("yellow");

    private static final String RECURRENCE_RATE_DISPLAY_PREFIX = "Every ";
    private static final String END_DATE_DISPLAY_PREFIX = "End: ";
    private static final String START_DATE_DISPLAY_PREFIX = "Start: ";
    private static final String STRING_PLURAL_POSTFIX = "s";
    private static final String STRING_ONE_SPACE = " ";
    private static final String STRING_EMPTY = "";

    private static final int ONE = 1;
    private static final int ZERO = 0;
    private static final String FXML = "TaskListCard.fxml";
    private static final SimpleDateFormat dateFormatter = new SimpleDateFormat("EEE, d MMM yyyy, h:mm a");

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Rectangle priority;
    @FXML
    private Label startDate;
    @FXML
    private Label endDate;
    @FXML
    private Label recurrenceRate;
    @FXML
    private Label tags;

    private ReadOnlyTask task;
    private int displayedIndex;

    public TaskCard() {

    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex) {
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        assert task != null && task.getName() != null && task.getPriorityValue() != null;

        setTaskCardIndex();
        setTaskCardName();
        setTaskCardPriority();
        setTaskCardStartDate();
        setTaskCardEndDate();
        setTaskCardRecurrence();
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    // private helper methods below

    /**
     * Sets the task card displayed index to its position in the list.
     */
    private void setTaskCardIndex() {
        assert displayedIndex > 0;

        String taskCardId = displayedIndex + ".";
        id.setText(taskCardId);
    }

    /**
     * Sets the task card name to the name of the task of the task it is
     * displaying.
     */
    private void setTaskCardName() {
        assert task != null && task.getName() != null;

        String taskName = task.getName().toString();
        name.setText(taskName);
    }

    /**
     * Sets the task card priority rectangle to the appropriate color depending
     * on the task priority.
     */
    private void setTaskCardPriority() {
        assert task != null && task.getPriorityValue() != null;

        Priority taskPriority = task.getPriorityValue();

        Paint taskPriorityColour = PAINT_YELLOW;

        switch (taskPriority) {
        case LOW:
            taskPriorityColour = PAINT_GREEN;
            break;
        case MEDIUM:
            taskPriorityColour = PAINT_YELLOW;
            break;
        case HIGH:
            taskPriorityColour = PAINT_RED;
            break;
        default:
            assert false : "priority should only be LOW, MEDIUM, or HIGH";
        }

        priority.setFill(taskPriorityColour);
    }

    /**
     * Sets the task card start date to the start date of the task it is
     * displaying.
     */
    private void setTaskCardStartDate() {
        assert task != null;

        String startDateText = STRING_EMPTY;
        boolean hasStartDate = task.getStartDate().isPresent();

        if (hasStartDate) {
            startDateText = prepareStartDateToDisplay();
        }

        startDate.setText(startDateText);
    }

    /**
     * Sets the task card end date to the end date of the task it is displaying.
     */
    private void setTaskCardEndDate() {
        assert task != null;

        String endDateText = STRING_EMPTY;
        boolean hasEndDate = task.getEndDate().isPresent();

        if (hasEndDate) {
            endDateText = prepareEndDateToDisplay();
        }
        endDate.setText(endDateText);
    }

    /**
     * Sets the task card recurrence rate to the recurrence rate of the task it
     * is displaying.
     */
    private void setTaskCardRecurrence() {
        assert task != null;

        String recurrenceRateText = STRING_EMPTY;
        boolean taskIsRecurring = task.getRecurrenceRate().isPresent();

        if (taskIsRecurring) {
            recurrenceRateText = prepareRecurrenceRateToDisplay();
        }

        recurrenceRate.setText(recurrenceRateText);
    }

    /**
     * Prepares the start date for display by converting it into a pretty format
     * as a String.
     * 
     * @return the String representation of the start date for display on the
     *         task card
     */
    private String prepareStartDateToDisplay() {
        assert task != null && task.getStartDate().isPresent();

        Date startDate = task.getStartDate().get();
        return START_DATE_DISPLAY_PREFIX + dateFormatter.format(startDate);
    }

    /**
     * Prepares the end date for display by converting it into a pretty format
     * as a String.
     * 
     * @return the String representation of the end date for display on the task
     *         card
     */
    private String prepareEndDateToDisplay() {
        assert task != null && task.getEndDate().isPresent();

        Date endDate = task.getEndDate().get();
        return END_DATE_DISPLAY_PREFIX + dateFormatter.format(endDate);
    }

    /**
     * Prepares the recurrence rate for display by converting it into a pretty
     * format as a String.
     * 
     * @return the String representation of the recurrence rate for display on
     *         the task card
     */
    private String prepareRecurrenceRateToDisplay() {
        assert task != null && task.getRecurrenceRate().isPresent();

        String recurrenceRateText = task.getRecurrenceRate().get().toString();
        return recurrenceRateText;
    }

    /**
     * Get the recurrence rate string for display, given the recurrence rate
     * integer and the time period associated with the recurrence rate.
     * 
     * @param recurrenceRateInteger the integer associated with the recurrence
     *            rate
     * @param timePeriod the time period associated with the recurrence rate
     * @return the String representation of the recurrence rate for display on
     *         the task card
     */
    private String getRecurrenceRateString(Integer recurrenceRateInteger, TimePeriod timePeriod) {
        boolean isRecurrenceRateOne = (recurrenceRateInteger == ONE);

        return RECURRENCE_RATE_DISPLAY_PREFIX
                + ((isRecurrenceRateOne) ? STRING_EMPTY : recurrenceRateInteger.toString() + STRING_ONE_SPACE)
                + timePeriod.toString().substring(ZERO, ONE).toUpperCase()
                + timePeriod.toString().substring(ONE).toLowerCase()
                + (recurrenceRateInteger.intValue() > ONE ? STRING_PLURAL_POSTFIX : STRING_EMPTY);
    }

}
```
###### \java\seedu\address\ui\UiManager.java
``` java
    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleHelp();
    }

```
###### \resources\view\MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Menu?>
<?import javafx.scene.control.MenuBar?>
<?import javafx.scene.control.MenuItem?>
<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.MainWindow">
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <MenuBar maxHeight="0.0" minHeight="0.0" prefHeight="0.0" VBox.vgrow="NEVER">
         <menus>
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem mnemonicParsing="false" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" text="Help" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>

       <AnchorPane fx:id="resultDisplayPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="SOMETIMES">

           <padding>
               <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           </padding>
       </AnchorPane>
      <AnchorPane fx:id="switchViewButtonsPlaceholder" styleClass="anchor-pane-with-border">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
      <SplitPane id="splitPane" fx:id="splitPane" VBox.vgrow="ALWAYS">
         <items>
            <VBox fx:id="personList" minWidth="340" prefWidth="340">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                </padding>
               <children>
                  <AnchorPane fx:id="personListPanelPlaceholder" VBox.vgrow="ALWAYS" />
               </children>
            </VBox>
         </items>
      </SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
###### \resources\view\PersonListPanel.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.TaskListPanel">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
        <ListView fx:id="taskListView" style="-fx-background-color: D3D6DB;" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### \resources\view\ResultDisplay.fxml
``` fxml

<?import javafx.scene.layout.AnchorPane?>
<?import java.net.URL?>
<AnchorPane styleClass="anchor-pane-with-border" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1"
            fx:controller="seedu.address.ui.ResultDisplay">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
</AnchorPane>
```
###### \resources\view\SwitchViewButtons.fxml
``` fxml

<?import javafx.scene.control.ToggleButton?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>

<AnchorPane styleClass="anchor-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.SwitchViewButtons">
   <children>
      <HBox fx:id="hb" prefHeight="25.0" prefWidth="200.0">
         <children>
            <ToggleButton fx:id="showListUndone" mnemonicParsing="false" onMouseClicked="#switchToListUndoneView" text="Show Undone Tasks" />
            <ToggleButton fx:id="showListDone" mnemonicParsing="false" onMouseClicked="#switchToListDoneView" text="Show Done Tasks" />
         </children>
      </HBox>
   </children>
</AnchorPane>
```
