# A0093960X
###### \java\seedu\address\commons\util\StringUtil.java
``` java
    /**
     * Returns true if query is a valid substring of source (beginning at the first character of source)
     * Will return false if either source or query is null
     * Will also return false if the substring of query found in source is different capitalization
     * 
     * @param source the base/source string to check on
     * @param query the query string that you want to check if is substring and begins in source
     * @return boolean representing if the query is a valid substring of source
     */
    public static boolean isSubstringFromStart(String source, String query) {
        return source != null & query != null && source.indexOf(query) == 0;
    }
    
    /**
     * Combines the given list of strings into a single string, with newlines separating the strings.
     * The list given cannot be null.
     * If list of strings is empty, returns an empty string.
     * If a string in the list is null, it will be ignored.
     * 
     * @param strings the list of strings to combine
     * @return the single combined string
     */
    public static String combineStrings(List<String> strings) {
        assert strings != null;
        
        StringBuilder sb = new StringBuilder();
                
        for (String string : strings) {
            if (string != null) {
                sb.append(string);
                sb.append("\n");
            }
        }
        
        // remove the final newline char if present
        if (sb.length() > 0) {
            sb.deleteCharAt(sb.length()-1);
        }
        
        return sb.toString();
    }
    
```
###### \java\seedu\address\history\InputHistory.java
``` java
public interface InputHistory {
    
    /** Updates the user input history and resets the current state to be the latest input with the given userInput String **/
    public void updateInputHistory(String userInput);
    
    /** Returns whether we are already at the earliest input state (no more previous input in memory to backtrack to) **/
    public boolean isEarliestInput();
    
    /** Returns whether we are already at the latest input state (no more later input in memory to move forward to) **/
    public boolean isLatestInput();

    /** Executes the action to get the next input from the input history **/
    String nextStep();

    /** Executes the action to get the prev input from the input history **/
    String prevStep(String currentInput);
}
```
###### \java\seedu\address\history\InputHistoryManager.java
``` java
/**
 * Stores the history of user inputs for navigating previous and next user inputs using up and down arrow keys.
 */
public class InputHistoryManager implements InputHistory{
    
    private static InputHistoryManager theInputHistoryManager;
    
    // command inputs
    private Stack<String> prevCommands;
    private Stack<String> nextCommands;
    private String currentStoredCommandShown;
    
    // Private constructor for Singleton Pattern
    private InputHistoryManager(){
        prevCommands = new Stack<String>();
        nextCommands = new Stack<String>();
        currentStoredCommandShown = "";
    }
    
    // Use Singleton Pattern here
    public static InputHistoryManager getInstance() {
        if (theInputHistoryManager == null){
            theInputHistoryManager = new InputHistoryManager();
        }
        return theInputHistoryManager;
    }
    
    @Override
    public void updateInputHistory(String userInput) {
        assert prevCommands != null && nextCommands != null && currentStoredCommandShown != null;
        
        if (!isLatestInput()) {
            pushPrevInput(currentStoredCommandShown);
        }
        
        while (!isLatestInput()) {
            // last 'next' is the one that i typed halfway, don't push it in my history 
            if (nextCommands.size() == 1){
                nextCommands.pop();
                break;
            }
                
            prevCommands.push(nextCommands.pop());
        }
        pushPrevInput(userInput);
        currentStoredCommandShown = "";
    }
    
    @Override
    public boolean isEarliestInput() {
        assert prevCommands != null;
        return prevCommands.isEmpty();
    }
    
    @Override
    public boolean isLatestInput() {
        assert nextCommands != null;
        return nextCommands.isEmpty();
    }
    
    @Override
    public String prevStep(String currentInput) {
        String inputToStore;
        
        if (isLatestInput()) {
            inputToStore = currentInput;
        }
            
        else {
            inputToStore = currentStoredCommandShown;
        }
        pushNextInput(inputToStore);
        return popPrevInput();
    }
    
    @Override
    public String nextStep() {
        pushPrevInput(currentStoredCommandShown);
        return popNextInput();
    }
    
    // private helper methods below
    
    private String popPrevInput() {
        assert prevCommands != null;
        currentStoredCommandShown = prevCommands.pop();
        return currentStoredCommandShown;
    }  
    
    private String pushPrevInput(String input) {
        assert prevCommands != null;
        return prevCommands.push(input);
    }
    
    private String popNextInput() {
        assert nextCommands != null;
        currentStoredCommandShown = nextCommands.pop();
        return currentStoredCommandShown;
    }
    
    private String pushNextInput(String input) {
        assert nextCommands != null;
        return nextCommands.push(input);
    }
    
}
```
###### \java\seedu\address\history\UndoableCommandHistory.java
``` java
public interface UndoableCommandHistory {

    /** Updates the command history with the given UndoableCommand **/
    public void updateCommandHistory(UndoableCommand undoableCommand);
    
    /** Returns whether we are already at the earliest command state (there is nothing to undo anymore) **/
    public boolean isEarliestCommand();
    
    /** Returns whether we are already at the latest command state (there is nothing to redo anymore) **/
    public boolean isLatestCommand();
    
    /** Executes an undo step on the command history, returning the UndoableCommand that was undone **/
    public UndoableCommand undoStep();
    
    /** Executes a redo step on the command history, returning the UndoableCommand that was redone **/
    public UndoableCommand redoStep();
    
}
```
###### \java\seedu\address\history\UndoableCommandHistoryManager.java
``` java
/**
 * Stores the history of undoable and redoable commands for UndoCommand to use.
 */
public class UndoableCommandHistoryManager implements UndoableCommandHistory{
    
    private static UndoableCommandHistoryManager theUndoableCommandHistory;

    // command effects
    private Stack<UndoableCommand> undoableCommands;
    private Stack<UndoableCommand> redoableCommands;
    
    // Private constructor for Singleton Pattern
    private UndoableCommandHistoryManager(){
        undoableCommands = new Stack<UndoableCommand>();
        redoableCommands = new Stack<UndoableCommand>();
    }
    
    // Use Singleton Pattern here
    public static UndoableCommandHistoryManager getInstance(){
        if (theUndoableCommandHistory == null){
            theUndoableCommandHistory = new UndoableCommandHistoryManager();
        }
        return theUndoableCommandHistory;
    }
    
    @Override
    public void updateCommandHistory(UndoableCommand undoableCommand){
        assert undoableCommands != null;
        undoableCommands.push(undoableCommand);
        resetRedo();
    }
    
    @Override
    public boolean isEarliestCommand(){
        assert undoableCommands != null;
        return undoableCommands.isEmpty();
    }
    
    @Override
    public boolean isLatestCommand(){
        assert redoableCommands != null;
        return redoableCommands.isEmpty();
    }
    
    @Override
    public UndoableCommand undoStep(){
        assert redoableCommands != null && undoableCommands != null;
        return redoableCommands.push(undoableCommands.pop());
    }
    
    @Override
    public UndoableCommand redoStep(){
        assert redoableCommands != null && undoableCommands != null;
        return undoableCommands.push(redoableCommands.pop());
    }
    
    private void resetRedo(){
        // not sure if using clear() gives worse performance
        redoableCommands = new Stack<UndoableCommand>();
    }
    
}
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null && toAdd != null;
        
        // attempt to undo the add by deleting the same task that was added
        try {
            model.deleteTask(toAdd);
        } catch (TaskNotFoundException e) {
            // cannot find the task that was added
            return new CommandResult("Failed to undo last add command: add " + toAdd);
        }
        
        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, toAdd));
    }
    
```
###### \java\seedu\address\logic\commands\ClearCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null && clearedTasks != null;
           
        // attempt to undo the clear by adding back the list of tasks that was cleared
        // add back to the list the user was viewing when clear was executed
        if (viewingDoneList) {
            model.addDoneTasks(clearedTasks);
        }
        else {
            model.addTasks(clearedTasks);
        }
        
        return new CommandResult(MESSAGE_UNDO_SUCCESS);
    }
    
```
###### \java\seedu\address\logic\commands\DeleteCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null && deletedTasks != null;    
        
        // attempt to undo the delete by adding back the list of tasks that was deleted
        // add back to the list the user was viewing when clear was executed
        if (viewingDoneList) {
            model.addDoneTasks(deletedTasks);
        }
        else {
            model.addTasks(deletedTasks);
        }
        
        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, displayDeletedTasks));
    }
```
###### \java\seedu\address\logic\commands\DoneCommand.java
``` java
    @Override
    public CommandResult undo() {
        doneTasksUndoFail = new ArrayList<Task>();
        
        for (Task doneTask : doneTasks){
            try {
                model.deleteDoneTask(doneTask);
            } catch (TaskNotFoundException e) {
                doneTasksUndoFail.add(doneTask);
            }
        }
        
        for (Task readdedRecurTask : readdedRecurringTasks) { 
            try {
                model.deleteTask(readdedRecurTask);
            } catch (TaskNotFoundException e) {
                doneTasksUndoFail.add(readdedRecurTask);
            }
        }
        
        model.addTasks(doneTasks);
        return new CommandResult(MESSAGE_DONE_UNDO_SUCCESS);
    }

```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
    @Override
    public CommandResult undo() {
        // edit all the fields back to the state before the edit took place
        
        // save this for printing purposes
        Task toUndoForPrint = new Task(toEdit);
        
        Task toUndo = toEdit;
        
        System.out.println(toUndo);
        
        Name previousTaskName = beforeEdit.getName();
        Optional<Date> previousStartDate = beforeEdit.getStartDate();
        Optional<Date> previousEndDate = beforeEdit.getEndDate();
        Priority previousPriority = beforeEdit.getPriorityValue();
        Optional<RecurrenceRate> previousReccurence = beforeEdit.getRecurrenceRate();
        
        Date undoStartDate = null;
        Date undoEndDate = null;
        RecurrenceRate undoRecurrenceRate = null;
       
        // edit back the start date
        if (previousStartDate.isPresent()) {
            undoStartDate = previousStartDate.get();
        }
       
        // edit back the end date
        if (previousEndDate.isPresent()) {
            undoEndDate = previousEndDate.get();
        }
        
        // edit back the recurrence rate
        if (previousReccurence.isPresent()) {
            undoRecurrenceRate = previousReccurence.get();
        }
                   
        model.editTask(toUndo, previousTaskName, undoStartDate, undoEndDate, previousPriority, undoRecurrenceRate);      
        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, toUndoForPrint, toUndo));
    }
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
/**
 * Selects a person identified using it's last displayed index from the address book.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Reverses the last undo command, reversing the effect on the task manager.\n"
            + "Example: " + COMMAND_WORD;
    
    public static final String TOOL_TIP = "redo";
    

    public RedoCommand() {
    }

    @Override
    public CommandResult execute() {
        assert history != null;
        
        // if we are at the latest state where there is no later 'undo commands' to redo, return nothing to redo
        if (history.isLatestCommand()){
            return new CommandResult("Nothing to redo.");
        }
        
        // redo is now OCP friendly :-)
        UndoableCommand cmdToRedo = history.redoStep();
        return cmdToRedo.execute();
        
    }
    
   
}
```
###### \java\seedu\address\logic\commands\UndoableCommand.java
``` java
public abstract class UndoableCommand extends Command {
    
    private boolean isRedoAction;
    
    /**
     * Undoes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult undo();   
    
    /**
     * Updates the history of undoable commands with this command, if this command is not a 
     * command that was executed as part of a redo command.
     *
     */
    public void updateHistory(){
        
        if (isRedoAction) {
            return;
        }
        
        history.updateCommandHistory(this);        
        isRedoAction = true;
    }
    
    /**
     * Getter method to check if the current command is a new command or is a command executed
     * as part of a redo command.
     * @return boolean representing if the current command is executed as part of a redo command
     */
    public boolean checkIfRedoAction() {
        return isRedoAction;
    }

}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
/**
 * Selects a person identified using it's last displayed index from the address book.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undoes the last reversible command, reversing the effect on the task manager.\n"
            + "Example: " + COMMAND_WORD;
    
    public static final String TOOL_TIP = "undo";
    

    public UndoCommand() {
    }

    @Override
    public CommandResult execute() {
        assert history != null;
        
        // if we are at the earliest state where there is no earlier reversible command to undo, return nothing to undo
        if (history.isEarliestCommand()){
            return new CommandResult("Nothing to undo.");
        }
        
        // Undo is now OCP friendly :-)
        UndoableCommand cmdToUndo = history.undoStep();
        return cmdToUndo.undo();

    }

}
```
###### \java\seedu\address\storage\XmlAdaptedRecurrenceRate.java
``` java
public class XmlAdaptedRecurrenceRate {

    @XmlElement(required = true)
    private String rate;
    @XmlElement(required = true)
    private String timePeriod;
    
    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedRecurrenceRate() {}

    
    /**
     * Converts a given Person into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedPerson
     */
    public XmlAdaptedRecurrenceRate(RecurrenceRate source) {
        assert source.rate != null && source.timePeriod != null;
        this.rate = source.rate.toString().toLowerCase();
        this.timePeriod = source.timePeriod.toString().toLowerCase();
    }

    /**
     * Converts this jaxb-friendly adapted person object into the model's Person object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     * @throws ParseException 
     */
    public RecurrenceRate toModelType() throws IllegalValueException, ParseException {
        return new RecurrenceRate(this.rate, this.timePeriod);
    }
}
```
###### \java\seedu\address\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Person.
 */
public class XmlAdaptedTask {
    
    private static SimpleDateFormat dateParser = new SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy");


    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String priorityValue;
    @XmlElement
    private String startDate;
    @XmlElement
    private String endDate;
    @XmlElement
    private XmlAdaptedRecurrenceRate recurrenceRate;


    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedPerson
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        saveName(source);
        savePriority(source); 
        saveStartDateIfPresent(source);    
        saveEndDateIfPresent(source);
        saveRecurrenceRateIfPresent(source); 
    }


    /**
     * @param source
     */
    private void savePriority(ReadOnlyTask source) {
        String priorityString = source.getPriorityValue().toString();
        priorityValue = priorityString.toLowerCase();
    }


    /**
     * @param source
     */
    private void saveName(ReadOnlyTask source) {
        name = source.getName().name;
    }


    /**
     * @param source
     */
    private void saveRecurrenceRateIfPresent(ReadOnlyTask source) {
        boolean hasRecurrenceRate = hasRecurrenceRate(source);
        if (hasRecurrenceRate) {
            recurrenceRate = new XmlAdaptedRecurrenceRate(source.getRecurrenceRate().get());
        }
    }


    /**
     * @param source
     */
    private void saveEndDateIfPresent(ReadOnlyTask source) {
        boolean hasEndDate = taskHasEndDate(source);

        if (hasEndDate) {
            endDate = source.getEndDate().get().toString();
        }
    }


    /**
     * @param source
     */
    private void saveStartDateIfPresent(ReadOnlyTask source) {
        boolean hasStartDate = taskHasStartDate(source);
        if (hasStartDate) {
            startDate = source.getStartDate().get().toString();
        }
    }


    /**
     * @param source
     * @return
     */
    private boolean hasRecurrenceRate(ReadOnlyTask source) {
        return source.getRecurrenceRate().isPresent();
    }


    /**
     * @param source
     * @return
     */
    private boolean taskHasEndDate(ReadOnlyTask source) {
        return source.getEndDate().isPresent();
    }


    /**
     * @param source
     * @return
     */
    private boolean taskHasStartDate(ReadOnlyTask source) {
        return source.getStartDate().isPresent();
    }

    /**
     * Converts this jaxb-friendly adapted person object into the model's Person object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     * @throws ParseException 
     */
    public Task toModelType() throws IllegalValueException, ParseException {
        final String nameForModel = retrieveNameFromStoredTask();
        Priority priorityForModel = retrievePriorityFromStoredTask();
        
        Date startDateForModel = retrieveStartDateFromStoredTask();
        Date endDateForModel = retrieveEndDateFromStoredTask();
        RecurrenceRate recurrenceRateForModel = retrieveRecurrenceRateFromStoredTask();
    
        return new Task(new Name(nameForModel), startDateForModel, endDateForModel, recurrenceRateForModel, priorityForModel);
    }


    /**
     * @param recurrenceRateForModel
     * @return
     * @throws IllegalValueException
     * @throws ParseException
     */
    private RecurrenceRate retrieveRecurrenceRateFromStoredTask()
            throws IllegalValueException, ParseException {
        if (this.recurrenceRate == null) {
            return null;
        }
        return recurrenceRate.toModelType();
    }


    /**
     * @param endDateForModel
     * @return
     * @throws ParseException
     */
    private Date retrieveEndDateFromStoredTask() throws ParseException {
        if (this.endDate == null) {
            return null;
        }
        
        return dateParser.parse(this.endDate);
    }


    /**
     * @param startDateForModel
     * @return
     * @throws ParseException
     */
    private Date retrieveStartDateFromStoredTask() throws ParseException {
        if (this.startDate == null) {
            return null;
        }
        return dateParser.parse(this.startDate);
    }


    /**
     * @return
     * @throws IllegalValueException 
     */
    private Priority retrievePriorityFromStoredTask() throws IllegalValueException {    
        String storedPriority = this.priorityValue;
        
        switch (storedPriority) {
            case "high":
            case "h":
                return Priority.HIGH;
            case "medium":
            case "med":
            case "m":
                return Priority.MEDIUM;
            case "low":
            case "l":
                return Priority.LOW;
            default:
                // invalid value
                throw new IllegalValueException("The priority value stored is invalid");
        }
    }


    /**
     * @return
     */
    private String retrieveNameFromStoredTask() {
        assert this.name != null;
        
        return new String(this.name);
    }
}
```
###### \java\seedu\address\ui\CommandBox.java
``` java
public class CommandBox extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;
    String previousCommandTest;

    private Logic logic;
    private InputHistory inputHistory;
    
    private static final String BACKSPACE_UNICODE = "\u0008";
    private static final String SPACE_UNICODE = "\u0020";
    private static final String CARRIAGE_RETURN = "\r";
    private static final String NEW_LINE = "\n";


    @FXML
    private TextField commandTextField;
    private CommandResult mostRecentResult;

    public static CommandBox load(Stage primaryStage, AnchorPane commandBoxPlaceholder,
            ResultDisplay resultDisplay, Logic logic, InputHistory history) {
        CommandBox commandBox = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new CommandBox());
        commandBox.configure(resultDisplay, logic, history);
        commandBox.addToPlaceholder();
        return commandBox;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic, InputHistory history) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        this.inputHistory = history;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }
    
    /**
     * Handles the event where the user presses a key in the command box.
     */
    @FXML
    private void handleKeyInput(KeyEvent event) {       
        String keyInputAsString = event.getCharacter();
        
        boolean keyIsEnter = checkIfEnterPressed(keyInputAsString);
        
        if (keyIsEnter) {
            return;
        }
        
        // reset incorrect command style on command box
        setStyleToIndicateCorrectCommand();
        
        String userInput = getUserInputAfterKeyPressed(keyInputAsString);
        updateTooltipForUser(userInput);        

    }

    private boolean checkIfEnterPressed(String keyInputAsString) {
        // Enter is \r\n on windows, \n on unix
        return keyInputAsString.equals(CARRIAGE_RETURN) || keyInputAsString.equals(NEW_LINE);
    }
    
    @FXML
    private void handleKeyPressed(KeyEvent event) {
        KeyCode key = getKeyCodeFromEvent(event);
        
        boolean isNavigatingInputHistory = checkIfNavigatingInputHistory(key);
        boolean notNavigatingInputHistory = !isNavigatingInputHistory;
        
        if (notNavigatingInputHistory) {
            return;
        }
        
        setStyleToIndicateCorrectCommand();
        handleInputHistoryNavigation(key);
        /*
        String userInput = getUserInputAfterKeyPressed(key);
        */
        String userInput = commandTextField.getText();
        updateTooltipForUser(userInput);    
    }

    /**
     * Get the complete user input taking into account the current key pressed as key pressed
     * event is triggered before the command box text is updated.
     * key is either a backspace, space, letter or digit key.
     * 
     * @param keyAsString the key that was pressed as string
     * @return the full user input taking into account the key pressed
     */
    private String getUserInputAfterKeyPressed(String keyAsString) {
        String userInput = commandTextField.getText();
                
        switch (keyAsString) {
            case BACKSPACE_UNICODE:
                // backspace action occurs before event triggers, just return the user input
                return userInput;
            case SPACE_UNICODE:
                return applySpaceOnInputEnd(userInput);
            default:
                // is a normal letter/digit
                return applyKeyOnInputEnd(userInput, keyAsString);
        }
        
    }

    /**
     * Returns a string that is the result of the key appended to the back of the user input
     * @param userInput the user input
     * @param keyString the key as a string
     * @return string with key appended to the user input string
     */
    private String applyKeyOnInputEnd(String userInput, String keyString) {
        return userInput + keyString;
    }

    /**
     * Returns the key code associated with the Key Event
     * @param event the KeyEvent
     * @return the key code associated
     */
    private KeyCode getKeyCodeFromEvent(KeyEvent event) {
        return event.getCode();
    }

    /**
     * Returns if the key press corresponds to an up or down arrow key used to navigate input history.
     * @param key the key to check
     * @return boolean representing if the key is an up or down arrow key
     */
    private boolean checkIfNavigatingInputHistory(KeyCode key) {
        return key == KeyCode.UP || key == KeyCode.DOWN;
    }

    /**
     * Updates the tooltip on the GUI for the user to see.
     */
    private void updateTooltipForUser(String userInput) {
        String toDisplay = logic.generateToolTip(userInput);
        resultDisplay.postMessage(toDisplay);
    }
    
    /**
     * Returns a string with a single whitespace character appended to the back of
     * the given user input string
     * @param userInput
     * @return
     */
    private String applySpaceOnInputEnd(String userInput) {
        return userInput + " ";
    }

    /**
     * Handles the event where the user is trying to navigate the input history.
     * keyCode must either be up or down arrow key.
     * 
     * @param keyCode the keycode associated with this event
     */
    private void handleInputHistoryNavigation(KeyCode keyCode) {
        assert keyCode == KeyCode.UP || keyCode == KeyCode.DOWN;
        
        boolean wantPrev = checkIfWantPrevInput(keyCode);
        
        // if attempt to get next command while at latest command input or prev while at earliest, return
        if (desiredInputHistoryUnavailable(wantPrev)) {
            return;
        }
                
        if (wantPrev){
            handleGetPreviousInput();
        }        
        else {
            // else the user wants next
            handleGetNextInput();
        }
        
        updateCaretPosition();
    }

    /**
     * Returns whether the user is trying to access a previous or next input in 
     * the input history but is already at the limit (either earliest history or latest
     * history respectively).
     * 
     * @param wantPrev boolean representing if the user wants the previous input
     * @return
     */
    private boolean desiredInputHistoryUnavailable(boolean wantPrev) {
        boolean wantNext = !wantPrev;
        boolean atEarliestHistoryButWantPrevInput = inputHistory.isEarliestInput() && wantPrev;
        boolean atLatestHistoryButWantNextInput = inputHistory.isLatestInput() && wantNext;
        
        return atEarliestHistoryButWantPrevInput || atLatestHistoryButWantNextInput;
    }

    /**
     * Updates the caret position to the end of the current text input in the command box.
     */
    private void updateCaretPosition() {
        String currentInputShown = commandTextField.getText();
        int positionAtEndOfString = currentInputShown.length();
        
        commandTextField.positionCaret(positionAtEndOfString);
    }

    /**
     * Handles the event where the user wants to get the next input from input history.
     */
    private void handleGetNextInput() {
        // store the current input into the prev first
        String nextInput = inputHistory.nextStep(); 
        
        // get a next command input and replace current input
        commandTextField.setText(nextInput);
    }

    /**
     * Handles the event where the user wants to get the previous input from input history.
     */
    private void handleGetPreviousInput() {
        // store the current input and get prev input
        String currentInput = commandTextField.getText();      
        String prevInput = inputHistory.prevStep(currentInput);
        
        // show user the prev input
        commandTextField.setText(prevInput);
    }

    /**
     * Returns whether the user wants to get the previous input from input history.
     * @param keyCode the key the user pressed to trigger the event
     * @return boolean representing the above
     */
    private boolean checkIfWantPrevInput(KeyCode keyCode) {
        return keyCode == KeyCode.UP;
    }

    @FXML
    private void handleCommandInputEntered() {
        //Take a copy of the command text
        previousCommandTest = commandTextField.getText();
        
        // first push back all 'next' commands into 'prev' command       
        // immediately add it to the history of command inputs
        inputHistory.updateInputHistory(previousCommandTest); 

        /* We assume the command is correct. If it is incorrect, the command box will be changed accordingly
         * in the event handling code {@link #handleIncorrectCommandAttempted}
         */
        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        commandTextField.setText("");
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event,"Invalid command: " + previousCommandTest));
        setStyleToIndicateIncorrectCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandTest);
    }

    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
    }
    
    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }
    


}
```
###### \java\seedu\address\ui\TaskCard.java
``` java
public class TaskCard extends UiPart{

    private static final String FXML = "TaskListCard.fxml";
    private static SimpleDateFormat dateFormatter = new SimpleDateFormat("EEE, d MMM yyyy, h:mm a");


    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Rectangle priority;
    @FXML
    private Label startDate;
    @FXML
    private Label endDate;
    @FXML
    private Label recurrenceRate;
    @FXML
    private Label tags;
    
    private ReadOnlyTask task;
    private int displayedIndex;

    public TaskCard() {
        
    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex) {
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        assert task != null && task.getName() != null && task.getPriorityValue() != null;
        
        setTaskCardId();
        setTaskCardName();
        setTaskCardPriority();                
        setTaskCardStartDate();
        setTaskCardEndDate();       
        setTaskCardRecurrence();       
    }
    
    private void setTaskCardId() {
        assert displayedIndex > 0;
        
        String taskCardId = displayedIndex + ".";
        id.setText(taskCardId);
    }
    
    private void setTaskCardName() {
        assert task != null && task.getName() != null && task.getName().name != null;
        
        String taskName = task.getName().name;
        name.setText(taskName);
    }
    
    private void setTaskCardPriority() {
        assert task != null && task.getPriorityValue() != null;
        
        Priority taskPriority = task.getPriorityValue();
        
        Paint taskPriorityColour = Paint.valueOf("yellow");
        
        switch (taskPriority) {
            case LOW:
                taskPriorityColour = Paint.valueOf("green");
                break;
            case MEDIUM:
                taskPriorityColour = Paint.valueOf("yellow");
                break;
            case HIGH:
                taskPriorityColour = Paint.valueOf("red");
                break;
            default:
                assert false: "priority should only be LOW, MEDIUM, or HIGH";
        }
        
        priority.setFill(taskPriorityColour);
    }
    
    private void setTaskCardStartDate() {
        String startDateText = "";
        boolean taskHasStartDate = checkIfStartDatePresent();
        
        if (taskHasStartDate) {
            startDateText = prepareStartDateToDisplay();
        }
        
        startDate.setText(startDateText);
    }
    
    private void setTaskCardEndDate() {
        String endDateText = "";
        boolean taskHasEndDate = checkIfEndDatePresent();
        if (taskHasEndDate) {
            endDateText = prepareEndDateToDisplay();
        }
        endDate.setText(endDateText);
    }
    
    private void setTaskCardRecurrence() {
        String recurrenceRateText = "";
        boolean taskIsRecurring = task.getRecurrenceRate().isPresent();

        if (taskIsRecurring) {
            recurrenceRateText = prepareRecurrenceRateToDisplay();
        }
        
        recurrenceRate.setText(recurrenceRateText);
    }

    private String prepareStartDateToDisplay() {
        assert task.getStartDate().isPresent();
        
        Date startDate = task.getStartDate().get();
        return "Start: " + formatDateForDisplay(startDate);
    }
    
    private String formatDateForDisplay(Date date) {
        assert date != null;
        
        return dateFormatter.format(date);
    }

    private boolean checkIfStartDatePresent() {
        assert task != null;

        return task.getStartDate().isPresent();
    }
    
    private String prepareEndDateToDisplay() {
        assert task.getEndDate().isPresent();

        Date endDate = task.getEndDate().get();
        return "End: " + formatDateForDisplay(endDate);
    }

    private boolean checkIfEndDatePresent() {
        assert task != null;
        
        return task.getEndDate().isPresent();
    }

    private String prepareRecurrenceRateToDisplay() {
        String recurrenceRateText = "";
        Integer recurrenceRateInteger = task.getRecurrenceRate().get().rate;
        TimePeriod timePeriod = task.getRecurrenceRate().get().timePeriod;
        boolean hasRecurrenceRateInt = checkIfHasRecurrenceRateInt(recurrenceRateInteger);
        
        if (hasRecurrenceRateInt) {
            recurrenceRateText = prepareRecurrenceRateWithInt(recurrenceRateInteger, timePeriod);
        } else {
            recurrenceRateText = prepareRecurrenceRateWithoutInt(timePeriod);
        }
        
        return recurrenceRateText;
    }

    private String prepareRecurrenceRateWithoutInt(TimePeriod timePeriod) {
        return "every " + timePeriod.toString().toLowerCase();
    }

    private String prepareRecurrenceRateWithInt(Integer recurrenceRateInteger, TimePeriod timePeriod) {
        return "every " 
                + (recurrenceRateInteger == 1 ? "" : recurrenceRateInteger.toString() + " ")
                + timePeriod.toString().toLowerCase() 
                + (recurrenceRateInteger.intValue() > 1 ? "s" : "");
    }

    private boolean checkIfHasRecurrenceRateInt(Integer recurrenceRateInteger) {
        return recurrenceRateInteger != null;
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \resources\view\MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Menu?>
<?import javafx.scene.control.MenuBar?>
<?import javafx.scene.control.MenuItem?>
<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.MainWindow">
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <MenuBar maxHeight="0.0" minHeight="0.0" prefHeight="0.0" VBox.vgrow="NEVER">
         <menus>
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
       <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
           <padding>
               <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           </padding>
       </AnchorPane>
      <AnchorPane fx:id="switchViewButtonsPlaceholder" styleClass="anchor-pane-with-border">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
      <SplitPane id="splitPane" fx:id="splitPane" VBox.vgrow="ALWAYS">
         <items>
            <VBox fx:id="personList" minWidth="340" prefWidth="340">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                </padding>
               <children>
                  <AnchorPane fx:id="personListPanelPlaceholder" VBox.vgrow="ALWAYS" />
               </children>
            </VBox>
         </items>
      </SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
###### \resources\view\PersonListPanel.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.PersonListPanel">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
        <ListView fx:id="taskListView" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### \resources\view\ResultDisplay.fxml
``` fxml

<?import javafx.scene.layout.AnchorPane?>
<?import java.net.URL?>
<AnchorPane styleClass="anchor-pane-with-border" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1"
            fx:controller="seedu.address.ui.ResultDisplay">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
</AnchorPane>
```
###### \resources\view\SwitchViewButtons.fxml
``` fxml

<?import javafx.scene.control.ToggleButton?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>

<AnchorPane styleClass="anchor-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.SwitchViewButtons">
   <children>
      <HBox fx:id="hb" prefHeight="25.0" prefWidth="200.0">
         <children>
            <ToggleButton fx:id="showListUndone" mnemonicParsing="false" onMouseClicked="#switchToListUndoneView" text="Show Undone Tasks" />
            <ToggleButton fx:id="showListDone" mnemonicParsing="false" onMouseClicked="#switchToListDoneView" text="Show Done Tasks" />
         </children>
      </HBox>
   </children>
</AnchorPane>
```
###### \resources\view\TaskListCard.fxml
``` fxml
<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.shape.Rectangle?>

<HBox id="cardPane" fx:id="cardPane" maxHeight="-Infinity" minHeight="-Infinity" prefHeight="131.0" prefWidth="342.0" style="-fx-border-radius: 5; -fx-background-radius: 5;" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1">
    <children>
      <Rectangle fx:id="priority" arcHeight="5.0" arcWidth="5.0" fill="DODGERBLUE" height="128.0" stroke="BLACK" strokeType="INSIDE" width="8.0">
         <HBox.margin>
            <Insets top="1.0" />
         </HBox.margin>
      </Rectangle>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>
      
                          <children>
                  <HBox>
                     <children>
                                 <Label fx:id="id" styleClass="cell_big_label" text="\$index" />
                        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
                     </children>
                  </HBox>
                  <HBox>
                     <children>
                        <Label fx:id="startDate" styleClass="cell_small_label" text="\$startDate" />
                     </children>
                  </HBox>
                  <HBox prefHeight="100.0" prefWidth="200.0">
                     <children>
                        <Label fx:id="endDate" styleClass="cell_small_label" text="\$endDate" />
                     </children>
                  </HBox>
                  <Label fx:id="recurrenceRate" styleClass="cell_small_label" text="\$recurrenceRate" />
                  <Label style="-fx-padding: 4; -fx-text-fill: #FFFFFF; -fx-background-color: #777777; -fx-font-size: 14; -fx-background-radius: 3; -fx-border-radius: 3;" text="Test Label">
                     <VBox.margin>
                        <Insets top="1.0" />
                     </VBox.margin></Label>
                    </children>
                </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
