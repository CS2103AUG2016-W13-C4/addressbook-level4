# A0093960X
###### \java\seedu\address\commons\util\StringUtil.java
``` java
    /**
     * Returns a string that is the result of adding the specified stringToAdd
     * String at the specified position in the originalString String. <br>
     * If the position is less than 0, the stringToAdd will be added to the
     * front of originalString. <br>
     * If the position is greater than the length of the originalString, the stringToAdd
     * will be added to the back of the originalString. <br>
     * Asserts that the originalString and stringToAdd are not null.
     * 
     * @param originalString The String to add to
     * @param stringToAdd The String to add to the originalString
     * @param position The position in originalString to add the stringToAdd
     * @return The String with the stringToAdd added to in the given position of
     *         the originalString
     */
    public static String applyStringAtPosition(String originalString, String stringToAdd, int position) {
        assert originalString != null && stringToAdd != null;

        int originalStringLen = originalString.length();
        boolean isPositionBelowMinimum = (position < 0);
        boolean isPositionAboveMaximum = (position > originalStringLen);

        
        if (isPositionBelowMinimum) {
            position = 0;
        }
        else if (isPositionAboveMaximum) {
            position = originalString.length();
        }

        String stringBeforeCaret = originalString.substring(0, position);
        String stringAfterCaret = originalString.substring(position);
        return String.join(stringToAdd, stringBeforeCaret, stringAfterCaret);
    }

```
###### \java\seedu\address\history\InputHistory.java
``` java
/**
 * Interface API for the InputHistory.
 */
public interface InputHistory {
    // Applying facade for the InputHistoryManager class.

    /**
     * Updates the input history with the given input and resets the input
     * history to the latest input state
     * 
     * @param input The input to update the input history with
     */
    public void updateInputHistory(String input);

    /**
     * Returns whether we are already at the earliest input state (no more
     * previous input in memory to backtrack to)
     * 
     * @return A boolean representing whether we are already at the
     *         earliest input of the input history
     */
    public boolean isEarliestInput();

    /**
     * Returns whether we are already at the latest input state (no more later
     * input in memory to move forward to)
     * 
     * @return A boolean representing whether we are already at the
     *         latest input of the input history
     */
    public boolean isLatestInput();

    /**
     * Executes the action to get the next input from the input history,
     * returning that next input
     * 
     * @return The next input String from the input history
     */
    public String nextStep();

    /**
     * Executes the action to get the previous input from the input history,
     * storing the current input if currently at the latest input state
     * 
     * @param input The input to store if currently at the latest input state
     * @return The previous input String from the input history
     */
    public String prevStep(String input);
}
```
###### \java\seedu\address\history\InputHistoryManager.java
``` java
/**
 * Stores the history of user inputs for navigating previous and next user
 * inputs.
 */
public class InputHistoryManager implements InputHistory {

    private static final Logger logger = LogsCenter.getLogger(InputHistory.class);
    
    private static InputHistoryManager theInputHistoryManager;

    // command inputs
    private Stack<String> prevInputs;
    private Stack<String> nextInputs;
    private String currentStoredInputShown;

    // Private constructor for Singleton Pattern
    private InputHistoryManager() {
        prevInputs = new Stack<String>();
        nextInputs = new Stack<String>();
        resetCurrentStoredInputShown();
    }

    // Use Singleton Pattern here
    public static InputHistoryManager getInstance() {
        if (theInputHistoryManager == null) {
            theInputHistoryManager = new InputHistoryManager();
        }
        return theInputHistoryManager;
    }

    @Override
    public void updateInputHistory(String userInput) {
        assert prevInputs != null && nextInputs != null && currentStoredInputShown != null;
        
        logger.info("Updating the input history with the given user input.");
        if (!isLatestInput()) {
            pushToPrevInput(currentStoredInputShown);
        }

        resetInputHistoryToLatestState();
        pushToPrevInput(userInput);
        resetCurrentStoredInputShown();
    }

    @Override
    public boolean isEarliestInput() {
        assert prevInputs != null;
        return prevInputs.isEmpty();
    }

    @Override
    public boolean isLatestInput() {
        assert nextInputs != null;
        return nextInputs.isEmpty();
    }

    @Override
    public String prevStep(String currentInput) {
        logger.info("Executing the prevStep method to get the previous input from input history.");

        String inputToStore = decideInputToStore(currentInput);
        pushToNextInput(inputToStore);
        return popFromPrevInput();
    }

    @Override
    public String nextStep() {
        logger.info("Executing the nextStep method to get the previous input from input history.");
        
        pushToPrevInput(currentStoredInputShown);
        return popFromNextInput();
    }

    // private helper methods below

    /**
     * Returns the correct input to store depending on whether the current state
     * is at the latest input state.
     * 
     * @param currentInput The current user input String
     * @return The correct input to store into the input history
     */
    private String decideInputToStore(String currentInput) {
        if (isLatestInput()) {
            logger.info("Storing the given currentInput String to input history.");
            return currentInput;
        } else {
            logger.info("Storing the currentStoredInputShown String to input history.");
            return currentStoredInputShown;
        }
    }

    /**
     * Resets the current stored input shown to an empty string.
     */
    private void resetCurrentStoredInputShown() {
        logger.info("Resetting the current stored input shown.");
        currentStoredInputShown = StringUtils.EMPTY;
    }

    /**
     * Resets the previous and next input history to the latest state,
     * transferring all the valid next input into the previous input history.
     */
    private void resetInputHistoryToLatestState() {
        logger.info("Resetting the input history to the latest state.");        

        boolean isEarliestNextInputValid = isLatestInput();
        String nextInputToTransfer;

        while (!isLatestInput()) {
            nextInputToTransfer = popFromNextInput();
            pushToPrevInput(nextInputToTransfer);
        }

        if (!isEarliestNextInputValid) {
            popFromPrevInput();
        }
    }

    /**
     * Pops and returns the last stored previous input from the previous input
     * history, updating the current stored input shown to that input. <br>
     * Asserts that the previous input history is non-empty.
     * 
     * @return The last stored previous input String
     */
    private String popFromPrevInput() {
        assert prevInputs != null && prevInputs.size() > 0;
        currentStoredInputShown = prevInputs.pop();
        return currentStoredInputShown;
    }

    /**
     * Pops and returns the last stored next input from the next input history,
     * updating the current stored input shown to that input. <br>
     * Asserts that the next input history is non-empty.
     * 
     * @return The last stored next input String
     */
    private String popFromNextInput() {
        assert nextInputs != null && nextInputs.size() > 0;
        currentStoredInputShown = nextInputs.pop();
        return currentStoredInputShown;
    }

    /**
     * Pushes the given input into the previous input history.
     */
    private void pushToPrevInput(String input) {
        assert prevInputs != null;
        prevInputs.push(input);
    }

    /**
     * Pushes the given input into the next input history.
     */
    private void pushToNextInput(String input) {
        assert nextInputs != null;
        nextInputs.push(input);
    }

}
```
###### \java\seedu\address\history\UndoableCommandHistory.java
``` java
/**
 * Interface API for the UndoableCommandHistory.
 */
public interface UndoableCommandHistory {
    // Applying facade for the InputHistoryManager class.

    /**
     * Updates the UndoableCommand history with the given UndoableCommand
     * 
     * @param undoableCommand The UndoableCommand to update the history with
     */
    public void updateCommandHistory(UndoableCommand undoableCommand);

    /**
     * Returns whether we are already at the earliest command state (there is
     * nothing to undo anymore)
     * 
     * @return A boolean representing whether we are already at the earliest
     *         command of the undoable command history
     */
    public boolean isEarliestCommand();

    /**
     * Returns whether we are already at the latest command state (there is
     * nothing to redo anymore)
     * 
     * @return A boolean representing whether we are already at the latest
     *         command of the redoable command history
     */
    public boolean isLatestCommand();

    /**
     * Executes an undo step on the command history, returning the
     * UndoableCommand that was undone
     * 
     * @return The UndoableCommand that was undone
     */
    public UndoableCommand undoStep();

    /**
     * Executes a redo step on the command history, returning the
     * UndoableCommand that was redone
     * 
     * @return The UndoableCommand that was redone
     */
    public UndoableCommand redoStep();

}
```
###### \java\seedu\address\history\UndoableCommandHistoryManager.java
``` java
/**
 * Stores the history of undoable and redoable commands.
 */
public class UndoableCommandHistoryManager implements UndoableCommandHistory {
    
    private static final Logger logger = LogsCenter.getLogger(UndoableCommandHistoryManager.class);

    private static UndoableCommandHistoryManager theUndoableCommandHistory;

    // command effects
    private Stack<UndoableCommand> undoableCommands;
    private Stack<UndoableCommand> redoableCommands;

    // Private constructor for Singleton Pattern
    private UndoableCommandHistoryManager() {
        undoableCommands = new Stack<UndoableCommand>();
        redoableCommands = new Stack<UndoableCommand>();
    }

    // Use Singleton Pattern here
    public static UndoableCommandHistoryManager getInstance() {
        if (theUndoableCommandHistory == null) {
            theUndoableCommandHistory = new UndoableCommandHistoryManager();
        }
        return theUndoableCommandHistory;
    }

    @Override
    public void updateCommandHistory(UndoableCommand undoableCommand) {
        assert undoableCommands != null;
        undoableCommands.push(undoableCommand);
        resetRedo();
    }

    @Override
    public boolean isEarliestCommand() {
        assert undoableCommands != null;
        return undoableCommands.isEmpty();
    }

    @Override
    public boolean isLatestCommand() {
        assert redoableCommands != null;
        return redoableCommands.isEmpty();
    }

    @Override
    public UndoableCommand undoStep() {
        assert redoableCommands != null && undoableCommands != null;
        logger.info("Executing the undoStep method to undo the previous undoable command.");
        
        UndoableCommand undoneCmd = undoableCommands.pop();
        return redoableCommands.push(undoneCmd);
    }

    @Override
    public UndoableCommand redoStep() {
        assert redoableCommands != null && undoableCommands != null;
        logger.info("Executing the redoStep method to redo the last undo.");

        UndoableCommand redoneCmd = redoableCommands.pop();
        return undoableCommands.push(redoneCmd);
    }

    /**
     * Resets the redoable command history, erasing all redoable command history.
     */
    private void resetRedo() {
        redoableCommands = new Stack<UndoableCommand>();
    }

}
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    @Override
    public CommandResult execute() {
        assert model != null && toAdd != null;

        if (attemptToExecuteAddOnDoneList()) {
            logger.info("Attempting to execute the add command on the done list. Aborting this action.");
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_DONE_LIST_RESTRICTION);
        }

        logger.info("Adding task in execute() of AddCommand");
        model.addTask(toAdd);
        updateHistory();

        String formattedResult = String.format(MESSAGE_SUCCESS, toAdd);
        return new CommandResult(formattedResult);
    }

    /**
     * Returns true if the add command is being executed on the done list.
     * 
     * @return A boolean representing if the add is executed on the done list.
     */
    private boolean attemptToExecuteAddOnDoneList() {
        return model.isCurrentListDoneList() && (!isRedoAction);
    }

    @Override
    public CommandResult undo() {
        assert model != null && toAdd != null;

        String formattedResult;
        try {
            logger.info("Attempting to undo the add by deleting the added task from the undone list.");
            model.deleteUndoneTask(toAdd);
            formattedResult = String.format(MESSAGE_UNDO_SUCCESS, toAdd);
            return new CommandResult(formattedResult);

        } catch (TaskNotFoundException e) {
            logger.info("Unable to undo the add as the task was not found in the undone list.");
            formattedResult = String.format(MESSAGE_UNDO_FAILURE, toAdd);
            return new CommandResult(formattedResult);
        }

    }

```
###### \java\seedu\address\logic\commands\ClearCommand.java
``` java
/**
 * Clears the address book.
 */
public class ClearCommand extends UndoableCommand {

    private final Logger logger = LogsCenter.getLogger(ClearCommand.class);
    
    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ":\n" 
            + "Clears the current view of the task manager.\n\t"
            + "Example: " + COMMAND_WORD;

    public static final String TOOL_TIP = "clear";
    public static final String MESSAGE_SUCCESS_UNDONE_LIST = "Task Manager undone list has been cleared!";
    public static final String MESSAGE_SUCCESS_DONE_LIST = "Task Manager done list has been cleared!";
    public static final String MESSAGE_UNDO_SUCCESS_UNDONE_LIST = "Undid the clear command!"
            + " Cleared tasks from the undone list have been restored!";
    public static final String MESSAGE_UNDO_SUCCESS_DONE_LIST = "Undid the clear command!"
            + " Cleared tasks from the undone list have been restored!";

    private ObservableList<Task> clearedTasks;
    private boolean isTargetDoneList;

    public ClearCommand() {
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        if (!isRedoAction) {
            updateTargetList();
        }

        updateHistory();
        if (isTargetDoneList) {
            saveAndClearDoneList();
            return new CommandResult(MESSAGE_SUCCESS_DONE_LIST);
        } else {
            saveAndClearUndoneList();
            return new CommandResult(MESSAGE_SUCCESS_UNDONE_LIST);
        }

    }
    
    @Override
    public CommandResult undo() {
        assert model != null && clearedTasks != null;

        if (isTargetDoneList) {
            revertDoneListBeforeClear();
            return new CommandResult(MESSAGE_UNDO_SUCCESS_DONE_LIST);
        } else {
            revertUndoneListBeforeClear();
            return new CommandResult(MESSAGE_UNDO_SUCCESS_UNDONE_LIST);
        }

    }

    private void revertUndoneListBeforeClear() {
        logger.info("Undoing the clear command by reverting the undone list "
                + "back to the old list before it was cleared");
        model.setTaskManagerUndoneList(clearedTasks);
    }

    private void revertDoneListBeforeClear() {
        logger.info("Undoing the clear command by reverting the done list "
                + "back to the old list before it was cleared");
        model.setTaskManagerDoneList(clearedTasks);
    }

    /**
     * Updates the target list of this clear command to the appropriate list.
     */
    private void updateTargetList() {
        logger.info("Clear command is executed as a new action and not part of a redo action."
                + " Saving the current list view as target list.");
        isTargetDoneList = model.isCurrentListDoneList();
    }

    /**
     * Saves the current undone list, and then clears the undone list to an empty list.
     */
    private void saveAndClearUndoneList() {
        logger.info("Attempting to save and clear the undone list.");
        clearedTasks = model.getTaskManagerUndoneList();
        model.clearTaskManagerUndoneList();
    }
    
    /**
     * Saves the current done list, and then clears the done list to an empty list.
     */
    private void saveAndClearDoneList() {
        logger.info("Attempting to save and clear the done list.");
        clearedTasks = model.getTaskManagerDoneList();
        model.clearTaskManagerDoneList();
    }

}
```
###### \java\seedu\address\logic\commands\DeleteCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null && targetTasks != null;    
        
        if (isViewingDoneList) {
            undoDeletedDoneTasks();
        }
        else {
            undoDeletedUndoneTasks();

        }
        
        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, targetTasks));
    }

    /**
     * Undo the deletion of undone tasks by adding them back into the undone list.
     */
    private void undoDeletedUndoneTasks() {
        logger.info("Undoing the deletion of the undone tasks by adding them back into the undone list");
        model.addTasks(targetTasks);
    }


    /**
     * Undo the deletion of done tasks by adding them back into the done list.
     */
    private void undoDeletedDoneTasks() {
        logger.info("Undoing the deletion of the done tasks by adding them back into the undone list");
        model.addDoneTasks(targetTasks);
    }

```
###### \java\seedu\address\logic\commands\DoneCommand.java
``` java
    @Override
    public CommandResult undo() {
        doneTasksUndoFail = new ArrayList<Task>();
        
        attemptToDeleteDoneTasksFromDoneList();
        
        attemptToDeleteReaddedRecurTasksFromUndoneList();
        
        readdAllDoneTasksToUndoneList();
        
        return generateAppropriateCommandResult();
    }

    /**
     * Generates the appropriate command result based on whether the undo was successful in undoing all the done tasks.
     * @return The appropriate CommandResult depending on whether the undo was successful
     */
    private CommandResult generateAppropriateCommandResult() {
        if (isSuccessfulInUndoingAllDoneTasks()) {
            return new CommandResult(MESSAGE_DONE_UNDO_SUCCESS);
        }
        else {
            return new CommandResult(String.format(MESSAGE_DONE_UNDO_SOME_FAILURE, doneTasksUndoFail));
        }
    }

    /**
     * Attempt to delete all readded recurring tasks as a result of this done command from the current undone list.
     */
    private void attemptToDeleteReaddedRecurTasksFromUndoneList() {
        for (Task readdedRecurTask : readdedRecurringTasks) { 
            attemptToDeleteReaddedRecurTaskFromUndoneList(readdedRecurTask);
        }
    }

    /**
     * Attempt to delete all done tasks as a result of this done command from the current done list.
     */
    private void attemptToDeleteDoneTasksFromDoneList() {
        for (Task doneTask : targetTasks){
            attemptToDeleteDoneTaskFromDoneList(doneTask);
        }
    }

    /**
     * Readds all the done tasks as a result of this done command back to the current undone list.
     */
    private void readdAllDoneTasksToUndoneList() {
        model.addTasks(targetTasks);

    }

    /**
     * Attempts to delete a readded recurring task from the current undone list.
     * 
     * @param readdedRecurTask The recurring task that was readded to the current undone list as part of this done command
     */
    private void attemptToDeleteReaddedRecurTaskFromUndoneList(Task readdedRecurTask) {
        try {
            model.deleteUndoneTask(readdedRecurTask);
        } catch (TaskNotFoundException e) {
            logger.info("Cannot find task: " + readdedRecurTask + "; adding to list of done task failures to inform user.");
            doneTasksUndoFail.add(readdedRecurTask);
        }
    }

    /**
     * Attempts to delete a done task from the current done list.
     * 
     * @param doneTask The done task that was added to the current done list as part of this done command
     */
    private void attemptToDeleteDoneTaskFromDoneList(Task doneTask) {
        try {
            model.deleteDoneTask(doneTask);
        } catch (TaskNotFoundException e) {
            logger.info("Cannot find task: " + doneTask + "; adding to list of done task failures to inform user.");
            doneTasksUndoFail.add(doneTask);
        }
    }
    
    /**
     * Return whether the undo command was successful in undoing all done tasks.
     * 
     * @return A boolean representing if all done tasks were undone.
     */
    private boolean isSuccessfulInUndoingAllDoneTasks() {
        return doneTasksUndoFail.isEmpty();
    }

}
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
    /**
     * Returns true if the edit command is being executed on the done list.
     */
    private boolean attemptToExecuteEditDoneList() {
        return model.isCurrentListDoneList() && (!isRedoAction);
    }
    
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
    @Override
    public CommandResult undo() {

        String taskStringBeforeUndo = toEdit.toString();

        Name previousTaskName = beforeEdit.getName();
        Priority previousPriority = beforeEdit.getPriorityValue();
        Date previousStartDate = getPreviousStartDateIfPresent();
        Date previousEndDate = getPreviousEndDateIfPresent();
        RecurrenceRate previousRecurrenceRate = getPreviousRecurrenceIfPresent();

        model.editTask(toEdit, previousTaskName, previousStartDate, previousEndDate, previousPriority, previousRecurrenceRate);
        
        String formattedResult = String.format(MESSAGE_UNDO_SUCCESS, taskStringBeforeUndo, toEdit);
        return new CommandResult(formattedResult);
    }


    /**
     * Get the previous start date before edit, if present.
     * @return The previous start date if present, otherwise returns null
     */
    private Date getPreviousStartDateIfPresent() {
        Optional<Date> previousStartDate = beforeEdit.getStartDate();
        if (previousStartDate.isPresent()) {
            return previousStartDate.get();
        }
        return null;
    }
    
    /**
     * Gets the previous end date before edit, if present.
     * @return The previous end date if present, otherwise returns null
     */
    private Date getPreviousEndDateIfPresent() {
        Optional<Date> previousEndDate = beforeEdit.getEndDate();
        if (previousEndDate.isPresent()) {
            return previousEndDate.get();
        }
        return null;
    }

    /**
     * Gets the previous recurrence rate before edit, if present.
     * @return The previous recurrence rate if present, otherwise returns null
     */
    private RecurrenceRate getPreviousRecurrenceIfPresent() {
        Optional<RecurrenceRate> previousReccurence = beforeEdit.getRecurrenceRate();
        
        if (previousReccurence.isPresent()) {
            return previousReccurence.get();
        }
        return null;
    }

}
```
###### \java\seedu\address\logic\commands\HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows program usage instructions.\n" + "Example: "
            + COMMAND_WORD;

    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";

    public static final String TOOL_TIP = "help";

    @Override
    public CommandResult execute() {
        postNewHelpEvent();
        return new CommandResult(SHOWING_HELP_MESSAGE);
    }
    
    /**
     * Posts a new help request event
     */
    private void postNewHelpEvent() {
        EventsCenter theEventsCenter = EventsCenter.getInstance();
        ShowHelpRequestEvent newHelpRequest = new ShowHelpRequestEvent();
        theEventsCenter.post(newHelpRequest);
    }
}
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
/**
 * Redoes the latest UndoableCommand that was undone.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Reverses the last undo command, reversing the effect on the task manager.\n" + "Example: "
            + COMMAND_WORD;

    public static final String TOOL_TIP = "redo";

    public static final String MESSAGE_FAILURE = "There is nothing to redo.";

    public RedoCommand() {
    }

    @Override
    public CommandResult execute() {
        assert history != null;

        if (history.isLatestCommand()) {
            return new CommandResult(MESSAGE_FAILURE);
        }

        UndoableCommand cmdToRedo = history.redoStep();
        return cmdToRedo.execute();
    }

}
```
###### \java\seedu\address\logic\commands\UndoableCommand.java
``` java
public abstract class UndoableCommand extends Command {

    protected boolean isRedoAction;

    /**
     * Undoes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult undo();

    /**
     * Updates the history of undoable commands with this undoable command, if
     * this command is not a command that was executed as part of a redo
     * command. <br>
     * If this command was not a redo action, also sets the isRedoAction
     * flag to be true as future executes of this same Command must be a redo action.
     */
    public void updateHistory() {

        if (isRedoAction) {
            return;
        }

        history.updateCommandHistory(this);
        isRedoAction = true;
    }

}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
/**
 * Undoes the latest UndoableCommand that was recorded in the undoable command
 * history.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undoes the last reversible command, reversing the effect on the task manager.\n" + "Example: "
            + COMMAND_WORD;

    public static final String TOOL_TIP = "undo";

    public static final String MESSAGE_FAILURE = "There is nothing to undo.";

    public UndoCommand() {
    }

    @Override
    public CommandResult execute() {
        assert history != null;

        if (history.isEarliestCommand()) {
            return new CommandResult(MESSAGE_FAILURE);
        }

        UndoableCommand cmdToUndo = history.undoStep();
        return cmdToUndo.undo();

    }

}
```
###### \java\seedu\address\storage\XmlAdaptedRecurrenceRate.java
``` java
public class XmlAdaptedRecurrenceRate {

    @XmlElement(required = true)
    private String rate;
    @XmlElement(required = true)
    private String timePeriod;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedRecurrenceRate() {
    }

    /**
     * Converts a given RecurrenceRate into this class for JAXB use.<br>
     * Future changes to this will not affect the created
     * XmlAdaptedRecurrenceRate.
     *
     * @param source The RecurrenceRate to convert
     */
    public XmlAdaptedRecurrenceRate(RecurrenceRate source) {
        assert source.getRate() != null && source.getTimePeriod() != null;
        
        Integer sourceRate = source.getRate();
        TimePeriod sourcePeriod = source.getTimePeriod();

        rate = sourceRate.toString();
        timePeriod = sourcePeriod.toString();

    }

    /**
     * Converts this jaxb-friendly adapted RecurrenceRate object into the
     * model's RecurrenceRate object.
     *
     * @throws IllegalValueException If there were any data constraints violated
     *             in the adapted recurrence rate
     */
    public RecurrenceRate toModelType() throws IllegalValueException {
        return new RecurrenceRate(this.rate, this.timePeriod);
    }
}
```
###### \java\seedu\address\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    private static SimpleDateFormat dateParser = new SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy");

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String priority;
    @XmlElement
    private String startDate;
    @XmlElement
    private String endDate;
    @XmlElement
    private XmlAdaptedRecurrenceRate recurrenceRate;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {
    }

    /**
     * Converts a given Task into this class for JAXB use. <br>
     * Future changes to this will not affect the created XmlAdaptedTask.
     *
     * @param source The task to convert
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        saveName(source);
        savePriority(source);
        saveStartDateIfPresent(source);
        saveEndDateIfPresent(source);
        saveRecurrenceRateIfPresent(source);
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task
     * object.
     *
     * @throws IllegalValueException If there were any data constraints violated
     *             in the adapted task
     * @throws ParseException If there was a parsing problem for the start and end dates of the stored Task
     */
    public Task toModelType() throws IllegalValueException, ParseException {
        Name nameForModel = getNameFromStoredTask();
        Priority priorityForModel = getPriorityFromStoredTask();

        Date startDateForModel = getStartDateFromStoredTask();
        Date endDateForModel = getEndDateFromStoredTask();
        RecurrenceRate recurrenceRateForModel = getRecurrenceRateFromStoredTask();

        return new Task(nameForModel, startDateForModel, endDateForModel, recurrenceRateForModel,
                priorityForModel);
    }

    /**
     * Saves the name of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source The Task to convert into the XmlAdaptedTask
     */
    private void saveName(ReadOnlyTask source) {
        name = source.getName().toString();
    }

    /**
     * Saves the priority of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source The Task to convert into the XmlAdaptedTask
     */
    private void savePriority(ReadOnlyTask source) {
        String priorityString = source.getPriorityValue().toString();
        priority = priorityString.toLowerCase();
    }

    /**
     * Saves the start date of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source The Task to convert into the XmlAdaptedTask
     */
    private void saveStartDateIfPresent(ReadOnlyTask source) {
        boolean hasStartDate = source.getStartDate().isPresent();

        if (hasStartDate) {
            startDate = source.getStartDate().get().toString();
        }
    }

    /**
     * Saves the end date of the source ReadOnlyTask into the XmlAdaptedTask.
     * 
     * @param source The Task to convert into the XmlAdaptedTask
     */
    private void saveEndDateIfPresent(ReadOnlyTask source) {
        boolean hasEndDate = source.getEndDate().isPresent();

        if (hasEndDate) {
            endDate = source.getEndDate().get().toString();
        }
    }

    /**
     * Saves the recurrence rate of the source ReadOnlyTask into the
     * XmlAdaptedTask.
     * 
     * @param source the Task to convert into the XmlAdaptedTask
     */
    private void saveRecurrenceRateIfPresent(ReadOnlyTask source) {
        boolean hasRecurrenceRate = source.getRecurrenceRate().isPresent();

        if (hasRecurrenceRate) {
            recurrenceRate = new XmlAdaptedRecurrenceRate(source.getRecurrenceRate().get());
        }
    }

    /**
     * Retrieves the Name associated with the stored task.
     * 
     * @return The Name associated with the stored task
     */
    private Name getNameFromStoredTask() {
        assert name != null;

        return new Name(name);
    }

    /**
     * Retrieves the Priority associated with the stored task. If the priority
     * string in the stored task does not match any valid priority strings, the
     * task will be given a default medium priority.
     * 
     * @return The Priority associated with the stored task
     */
    private Priority getPriorityFromStoredTask() {
        // assert priority != null;

        return Priority.convertStringToPriority(priority);
    }

    /**
     * Retrieves the start date Date associated with the stored task. Returns
     * null if there is no start date associated with the stored task.
     * 
     * @return The start date Date associated with the task, or null if no start
     *         date is associated with the current stored task.
     * @throws ParseException If the format of the start date does not conform
     *             to the expected format
     */
    private Date getStartDateFromStoredTask() throws ParseException {
        if (startDate == null) {
            return null;
        }
        return dateParser.parse(startDate);
    }

    /**
     * Retrieves the end date Date associated with the stored task. Returns null
     * if there is no end date associated with the stored task.
     * 
     * @return The end date Date associated with the task, or null if no end
     *         date is associated with the current stored task.
     * @throws ParseException If the format of the end date does not conform to
     *             the expected format
     */
    private Date getEndDateFromStoredTask() throws ParseException {
        if (endDate == null) {
            return null;
        }

        return dateParser.parse(endDate);
    }

    /**
     * Retrieves the ReccurenceRate associated with the stored task. Returns
     * null if there is no recurrence rate associated with the stored task.
     * 
     * @return The RecurrenceRate associated with the task, or null if no
     *         recurrence rate is associated with the current stored task.
     * 
     * @throws IllegalValueException If there were any data constraints violated
     *             in the adapted recurrence rate
     */
    private RecurrenceRate getRecurrenceRateFromStoredTask() throws IllegalValueException {
        if (recurrenceRate == null) {
            return null;
        }

        return recurrenceRate.toModelType();
    }

}
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    private void addToPlaceholder() {
        setupCommandBoxPosition();
        setupKeyPressHandler();
    }

    /**
     * Sets up the key press event handler for the command box.
     */
    private void setupKeyPressHandler() {
        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {

            @Override
            public void handle(KeyEvent keyEvent) {
                KeyCode keyCode = keyEvent.getCode();

                switch (keyCode) {
                case UP :
                    // Fallthrough
                case DOWN :
                    keyEvent.consume();
                    handleUpDownArrow(keyCode);
                    break;
                default :
                    break;
                }
            }

        });
    }

    /**
     * Sets up the command box position at the placeholder position.
     */
    private void setupCommandBoxPosition() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
    }

```
###### \java\seedu\address\ui\CommandBox.java
``` java
    /**
     * Handles the event where the user enters an input in the command box.
     */
    @FXML
    private void handleKeyInput(KeyEvent event) {
        String keyInputAsString = event.getCharacter();

        if (isKeyPressedEnter(keyInputAsString)) {
            return;
        }

        setStyleToIndicateCorrectCommand();
        String userInput = getUserInputAfterKeyPressed(keyInputAsString);
        updateTooltipForUser(userInput);

    }

    /**
     * Returns whether the given keyInputAsString is an 'enter' key on Windows
     * and Unix machines. <br>
     * This is represented by CRLF on windows and LF on unix systems.
     * 
     * @param keyInputAsString The String to check
     * @return A boolean representing if the String is a newline character
     */
    private boolean isKeyPressedEnter(String keyInputAsString) {
        return keyInputAsString.equals(CARRIAGE_RETURN) || keyInputAsString.equals(NEW_LINE);
    }

    /**
     * Handles the up or down arrow key event.<br>
     * Asserts that the specified KeyCode is either an UP or DOWN KeyCode.
     * 
     * @param keyCode The KeyCode associated with this event
     */
    private void handleUpDownArrow(KeyCode keyCode) {
        assert keyCode == KeyCode.UP || keyCode == KeyCode.DOWN;

        setStyleToIndicateCorrectCommand();
        handleInputHistoryNavigation(keyCode);
        String userInput = commandTextField.getText();
        updateTooltipForUser(userInput);
    }

    /**
     * Get the complete user input taking into account the current key pressed
     * as key pressed event is triggered before the command box text is updated.
     * key is either a backspace, space, letter or digit key.
     * 
     * @param keyAsString the key that was pressed as string
     * @return the full user input taking into account the key pressed
     */
    private String getUserInputAfterKeyPressed(String keyAsString) {
        handleKeyPressWithTextSelectionIfPresent();

        String userInput = commandTextField.getText();
        int caretPosition = commandTextField.getCaretPosition();

        return getNewUserInputIfNecessary(keyAsString, userInput, caretPosition);

    }

    /**
     * Returns the new user input String by adding the keyAsString at the
     * caretPosition, if necessary.
     * 
     * @param keyAsString The String to add to the userInput
     * @param userInput The user input String to add the keyAsString
     * @param stringPosition The position to add the keyAsString to
     * @return
     */
    private String getNewUserInputIfNecessary(String keyAsString, String userInput, int stringPosition) {
        switch (keyAsString) {
        case BACKSPACE_UNICODE :
            // backspace action occurs before event triggers, just return the
            // user input
            return userInput;
        case SPACE_UNICODE :
            return StringUtil.applyStringAtPosition(userInput, STRING_ONE_SPACE, stringPosition);
        default :
            // is a normal letter/digit
            return StringUtil.applyStringAtPosition(userInput, keyAsString, stringPosition);
        }
    }

    /**
     * Handles the case where the user selects the text in the command field
     * then enters some text, replacing the old selected text.<br>
     * This method will replace that selection by emptying it.
     */
    private void handleKeyPressWithTextSelectionIfPresent() {
        String userSelectedText = commandTextField.getSelectedText();
        if (!userSelectedText.isEmpty()) {
            commandTextField.replaceSelection(STRING_EMPTY);
        }
    }

    /**
     * Updates the tooltip on the GUI for the user to see.
     */
    private void updateTooltipForUser(String userInput) {
        String toDisplay = logic.generateToolTip(userInput);
        resultDisplay.postMessage(toDisplay);
    }

    /**
     * Handles the event where the user is trying to navigate the input
     * history.<br>
     * Asserts that the KeyCode specified is either the UP or DOWN KeyCode.
     * 
     * @param keyCode The KeyCode associated with this event
     */
    private void handleInputHistoryNavigation(KeyCode keyCode) {
        assert (keyCode == KeyCode.UP) || (keyCode == KeyCode.DOWN);

        // if attempt to get next command while at latest command input or prev
        // while at earliest, return
        if (desiredInputHistoryUnavailable(keyCode)) {
            return;
        }

        if (isAttemptingToGetPrevInput(keyCode)) {
            handleGetPreviousInput();
        } else {
            handleGetNextInput();
        }

        updateCaretPosition();
    }

    /**
     * Returns whether the user is trying to access a previous or next input in
     * the input history but is already at the limit (either earliest history or
     * latest history respectively). <br>
     * Asserts that the KeyCode specified is either an UP or DOWN KeyCode.
     * 
     * @param keyCode The KeyCode pressed
     * @return The boolean representing the above
     */
    private boolean desiredInputHistoryUnavailable(KeyCode keyCode) {
        assert keyCode == KeyCode.UP || keyCode == KeyCode.DOWN;

        return isAtEarliestHistoryButWantPrevInput(keyCode) || isAtLatestHistoryButWantNextInput(keyCode);
    }

    /**
     * Returns whether the user is already at the latest input history state but
     * wants to access a next input.
     * 
     * @param keyCode The KeyCode pressed
     * @return The boolean representing the above
     */
    private boolean isAtLatestHistoryButWantNextInput(KeyCode keyCode) {
        return inputHistory.isLatestInput() && isAttemptingToGetNextInput(keyCode);
    }

    /**
     * Returns whether the user is already at the earliest input history state
     * but wants to access a previous input.
     * 
     * @param keyCode the KeyCode pressed
     * @return boolean representing the above
     */
    private boolean isAtEarliestHistoryButWantPrevInput(KeyCode keyCode) {
        return inputHistory.isEarliestInput() && isAttemptingToGetPrevInput(keyCode);
    }

    /**
     * Updates the caret position to the end of the current text input in the
     * command box.
     */
    private void updateCaretPosition() {
        String currentInputShown = commandTextField.getText();
        int positionAtEndOfString = currentInputShown.length();

        commandTextField.positionCaret(positionAtEndOfString);
    }

    /**
     * Handles the event where the user wants to get the next input from input
     * history.
     */
    private void handleGetNextInput() {
        // store the current input into the prev first
        String nextInput = inputHistory.nextStep();

        // get a next command input and replace current input
        commandTextField.setText(nextInput);
    }

    /**
     * Handles the event where the user wants to get the previous input from
     * input history.
     */
    private void handleGetPreviousInput() {
        // store the current input and get prev input
        String currentInput = commandTextField.getText();
        String prevInput = inputHistory.prevStep(currentInput);

        // show user the prev input
        commandTextField.setText(prevInput);
    }

    /**
     * Returns whether the user wants to get the previous input from input
     * history.
     * 
     * @param keyCode the key the user pressed to trigger the event
     * @return boolean representing the above
     */
    private boolean isAttemptingToGetPrevInput(KeyCode keyCode) {
        return keyCode == KeyCode.UP;
    }

    /**
     * Returns whether the user wants to get the next input from input history.
     * 
     * @param keyCode the key the user pressed to trigger the event
     * @return boolean representing the above
     */
    private boolean isAttemptingToGetNextInput(KeyCode keyCode) {
        return keyCode == KeyCode.DOWN;
    }

    @FXML
    private void handleCommandInputEntered() {
        // Take a copy of the command text
        previousCommandTest = commandTextField.getText();

        // first push back all 'next' commands into 'prev' command
        // immediately add it to the history of command inputs
        inputHistory.updateInputHistory(previousCommandTest);

        /*
         * We assume the command is correct. If it is incorrect, the command box
         * will be changed accordingly in the event handling code {@link
         * #handleIncorrectCommandAttempted}
         */
        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        clearCommandBoxAndDisplayResult();
    }

    /**
     * Clears the command box text field and displays the most recent result on
     * the result display area.
     */
    private void clearCommandBoxAndDisplayResult() {
        commandTextField.setText(STRING_EMPTY);
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }

```
###### \java\seedu\address\ui\HelpWindow.java
``` java
    /**
     * Configures the help window stage.
     */
    private void configure() {
        Scene scene = initializeHelpWindowProperties();
        setupKeyPressEventHandler(scene);
    }
    
    /**
     * Sets up the key press event handler for the help window scene.
     * @param scene
     */
    private void setupKeyPressEventHandler(Scene scene) {
        scene.setOnKeyPressed(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                dialogStage.close();
            }
        });
    }

    private Scene initializeHelpWindowProperties() {
        Scene scene = new Scene(mainPane);
        // Null passed as the parent stage to make it non-modal.
        dialogStage = createDialogStage(TITLE, null, scene);
        setIcon(dialogStage, ICON);
        return scene;
    }

    /**
     * Shows the help window.
     */
    public void show() {
        dialogStage.show();
    }

}
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage);
        helpWindow.show();
    }

    public void show() {
        primaryStage.show();
    }

```
###### \java\seedu\address\ui\ResultDisplay.java
``` java
        resultDisplayArea.textProperty().addListener(e -> {
            int newHeight = computeNewHeight();
            setNewHeight(newHeight);
        });

```
###### \java\seedu\address\ui\ResultDisplay.java
``` java
    /**
     * Sets the height of the result display to the specified newHeight
     * @param newHeight The new height to set the result display area to
     */
    private void setNewHeight(int newHeight) {
        resultDisplayArea.setMinHeight(newHeight);
        resultDisplayArea.setPrefHeight(newHeight);
        resultDisplayArea.setMaxHeight(newHeight);
    }

    /**
     * Computes the new height of the result display area by considering the
     * number of newline characters present in the text of the result display
     * area.
     * 
     * @return The size of the new height
     */
    private int computeNewHeight() {
        return PREF_HEIGHT + getNumberOfNewLines() * HEIGHT_PER_EXTRA_NEWLINE;
    }

    /**
     * Returns the number of newlines characters in the result display text.
     * @return The number of newline characters
     */
    private int getNumberOfNewLines() {
        String displayedText = resultDisplayArea.getText();
        return StringUtils.countMatches(displayedText, NEWLINE_STRING);
    }

```
###### \java\seedu\address\ui\TaskCard.java
``` java
public class TaskCard extends UiPart {

    private static final Paint PAINT_RED = Paint.valueOf("red");
    private static final Paint PAINT_GREEN = Paint.valueOf("green");
    private static final Paint PAINT_YELLOW = Paint.valueOf("yellow");

    private static final String END_DATE_DISPLAY_PREFIX = "End: ";
    private static final String START_DATE_DISPLAY_PREFIX = "Start: ";
    private static final String STRING_EMPTY = "";

    private static final String FXML = "TaskListCard.fxml";
    private static final SimpleDateFormat dateFormatter = new SimpleDateFormat("EEE, d MMM yyyy, h:mm a");

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Rectangle priority;
    @FXML
    private Label startDate;
    @FXML
    private Label endDate;
    @FXML
    private Label recurrenceRate;

    private ReadOnlyTask task;
    private int displayedIndex;

    public TaskCard() {

    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex) {
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        assert task != null && task.getName() != null && task.getPriorityValue() != null;

        setTaskCardIndex();
        setTaskCardName();
        setTaskCardPriority();
        setTaskCardStartDate();
        setTaskCardEndDate();
        setTaskCardRecurrence();
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    // private helper methods below

    /**
     * Sets the task card displayed index to its position in the list.
     */
    private void setTaskCardIndex() {
        assert displayedIndex > 0;

        String taskCardId = displayedIndex + ".";
        id.setText(taskCardId);
    }

    /**
     * Sets the task card name to the name of the task of the task it is
     * displaying.
     */
    private void setTaskCardName() {
        assert task != null && task.getName() != null;

        String taskName = task.getName().toString();
        name.setText(taskName);
    }

    /**
     * Sets the task card priority rectangle to the appropriate color depending
     * on the task priority.
     */
    private void setTaskCardPriority() {
        assert task != null && task.getPriorityValue() != null;

        Priority taskPriority = task.getPriorityValue();

        Paint taskPriorityColour = getPaintForPriority(taskPriority);

        priority.setFill(taskPriorityColour);
    }

    /**
     * Gets the appropriate Paint given the Priority.
     * 
     * @param priority The priority to retrieve the Paint for
     * @return The Paint for the specified priority
     */
    private Paint getPaintForPriority(Priority priority) {
        switch (priority) {
        case LOW :
            return PAINT_GREEN;
        case MEDIUM :
            return PAINT_YELLOW;
        case HIGH :
            return PAINT_RED;
        default :
            assert false : "priority should only be LOW, MEDIUM, or HIGH";
            return PAINT_YELLOW;
        }
    }

    /**
     * Sets the task card start date to the start date of the task it is
     * displaying.
     */
    private void setTaskCardStartDate() {
        assert task != null;

        String startDateText = getStartDateTextIfPresent();

        startDate.setText(startDateText);
    }

    /**
     * Get the appropriate start date text if the start date of the task is present.
     * @return The appropriate start date text
     */
    private String getStartDateTextIfPresent() {
        boolean hasStartDate = task.getStartDate().isPresent();
        if (hasStartDate) {
            return prepareStartDateToDisplay();
        }
        return STRING_EMPTY;
    }

    /**
     * Sets the task card end date to the end date of the task it is displaying.
     */
    private void setTaskCardEndDate() {
        assert task != null;

        String endDateText = getEndDateTextIfPresent();
        endDate.setText(endDateText);
    }

    /**
     * Get the appropriate end date text if the end date of the task is present.
     * @return The appropriate end date text
     */
    private String getEndDateTextIfPresent() {
        boolean hasEndDate = task.getEndDate().isPresent();

        if (hasEndDate) {
            return prepareEndDateToDisplay();
        }
        return STRING_EMPTY;
    }

    /**
     * Sets the task card recurrence rate to the recurrence rate of the task it
     * is displaying.
     */
    private void setTaskCardRecurrence() {
        assert task != null;

        String recurrenceRateText = getRecurrenceTextIfPresent();

        recurrenceRate.setText(recurrenceRateText);
    }

    /**
     * Get the appropriate recurrence rate text if the recurrence rate of the task is present.
     * @return The appropriate recurrence rate text
     */
    private String getRecurrenceTextIfPresent() {
        String recurrenceRateText = STRING_EMPTY;
        boolean taskIsRecurring = task.getRecurrenceRate().isPresent();

        if (taskIsRecurring) {
            recurrenceRateText = prepareRecurrenceRateToDisplay();
        }
        return recurrenceRateText;
    }

    /**
     * Prepares the start date for display by converting it into a pretty format
     * as a String.
     * 
     * @return The String representation of the start date for display on the
     *         task card
     */
    private String prepareStartDateToDisplay() {
        assert task != null && task.getStartDate().isPresent();

        Date startDate = task.getStartDate().get();
        return START_DATE_DISPLAY_PREFIX + dateFormatter.format(startDate);
    }

    /**
     * Prepares the end date for display by converting it into a pretty format
     * as a String.
     * 
     * @return The String representation of the end date for display on the task
     *         card
     */
    private String prepareEndDateToDisplay() {
        assert task != null && task.getEndDate().isPresent();

        Date endDate = task.getEndDate().get();
        return END_DATE_DISPLAY_PREFIX + dateFormatter.format(endDate);
    }

    /**
     * Prepares the recurrence rate for display by converting it into a pretty
     * format as a String.
     * 
     * @return The String representation of the recurrence rate for display on
     *         the task card
     */
    private String prepareRecurrenceRateToDisplay() {
        assert task != null && task.getRecurrenceRate().isPresent();

        String recurrenceRateText = task.getRecurrenceRate().get().toString();
        return recurrenceRateText;
    }

}
```
###### \resources\view\MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.MainWindow">
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>

       <AnchorPane fx:id="resultDisplayPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="SOMETIMES">

           <padding>
               <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           </padding>
       </AnchorPane>
      <AnchorPane fx:id="switchViewButtonsPlaceholder" styleClass="anchor-pane-with-border">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
      <SplitPane id="splitPane" fx:id="splitPane" VBox.vgrow="ALWAYS">
         <items>
            <VBox fx:id="personList" minWidth="340" prefWidth="340">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                </padding>
               <children>
                  <AnchorPane fx:id="personListPanelPlaceholder" VBox.vgrow="ALWAYS" />
               </children>
            </VBox>
         </items>
      </SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
###### \resources\view\ResultDisplay.fxml
``` fxml

<?import javafx.scene.layout.AnchorPane?>
<?import java.net.URL?>
<AnchorPane styleClass="anchor-pane-with-border" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1"
            fx:controller="seedu.address.ui.ResultDisplay">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
</AnchorPane>
```
###### \resources\view\SwitchViewButtons.fxml
``` fxml

<?import javafx.scene.control.ToggleButton?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>

<AnchorPane styleClass="anchor-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.SwitchViewButtons">
   <children>
      <HBox fx:id="hbox" prefHeight="25.0" prefWidth="200.0">
         <children>
            <ToggleButton fx:id="showListUndone" mnemonicParsing="false" onMouseClicked="#switchToListUndoneView" text="Show Undone Tasks" />
            <ToggleButton fx:id="showListDone" mnemonicParsing="false" onMouseClicked="#switchToListDoneView" text="Show Done Tasks" />
         </children>
      </HBox>
   </children>
</AnchorPane>
```
###### \resources\view\TaskListPanel.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.address.ui.TaskListPanel">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
        <ListView fx:id="taskListView" style="-fx-background-color: D3D6DB;" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
