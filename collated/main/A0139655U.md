# A0139655U
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    public AddCommand(HashMap<String, Optional<String>> mapOfStrings) 
                    throws IllegalValueException {
        //TODO: assert taskNameString != null;
        HashMap<String, Object> mapOfObjects = AddCommandHelper.convertStringToObjects(mapOfStrings);
        
        Name taskName = (Name) mapOfObjects.get("taskName");
        Date startDate = (Date) mapOfObjects.get("startDate");
        Date endDate = (Date) mapOfObjects.get("endDate");
        RecurrenceRate recurrenceRate = (RecurrenceRate) mapOfObjects.get("recurrenceRate");
        Priority priority = (Priority) mapOfObjects.get("priority");
        
        this.toAdd = new Task(taskName, startDate, endDate, recurrenceRate, priority);
    }

    @Override
    public CommandResult execute() {
        assert model != null && toAdd != null;
        
        // check if viewing done list
        // cannot add to done list, return an incorrect command msg
        if (model.isCurrentListDoneList()) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(String.format(Messages.MESSAGE_DONE_LIST_RESTRICTION));
        }
        
        // add this task to the model
        model.addTask(toAdd);     
        
        // update the history with this command
        updateHistory();
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
    }

```
###### \java\seedu\address\logic\commands\AddCommandHelper.java
``` java
public class AddCommandHelper {
    
    private static final String STRING_CONSTANT_ONE = "1";
    public static final String MESSAGE_RECUR_DATE_TIME_CONSTRAINTS = "For recurring tasks to be valid, "
            + "at least one DATE_TIME must be provided";
    
    public static HashMap<String, Object> convertStringToObjects(HashMap<String, Optional<String>> map) throws IllegalValueException {
        
        Name taskName = new Name(map.get("taskName").get());
        Date startDate = generateStartDateIfPresent(map.get("startDate"));
        Date endDate = generateEndDateIfPresent(map.get("endDate"), startDate);
        RecurrenceRate recurrenceRate = generateRecurrenceRateIfPresent(map.get("rate"), map.get("timePeriod")); 
        Priority priority = Priority.convertStringToPriority(map.get("priority").get());
        
        if (recurWeekdaysButDatesNotGiven(startDate, endDate, recurrenceRate)) {
            startDate = DateTime.assignStartDateToSpecifiedWeekday(recurrenceRate.timePeriod.toString());
        } else if (otherRecurrenceButDatesNotGiven(startDate, endDate, recurrenceRate)) {
            throw new IllegalValueException(MESSAGE_RECUR_DATE_TIME_CONSTRAINTS);
        }
        
        return mapContainingVariables(taskName, startDate, endDate, recurrenceRate, priority);
        
    }

    private static HashMap<String, Object> mapContainingVariables(Name taskName, Date startDate, Date endDate,
            RecurrenceRate recurrenceRate, Priority priority) {
        assert taskName != null && priority != null;
        HashMap<String, Object> map = new HashMap<String, Object>();

        map.put("taskName", taskName);
        map.put("startDate", startDate);
        map.put("endDate", endDate);
        map.put("recurrenceRate", recurrenceRate);
        map.put("priority", priority);
        
        return map;
    }
    
    private static Date generateStartDateIfPresent(Optional<String> startDateString) {
        assert startDateString != null;
        Date startDate = null;
        
        if (startDateString.isPresent()) {
            startDate = DateTime.convertStringToDate(startDateString.get());
            if (!DateTime.hasTimeValue(startDateString.get())) {
                startDate = DateTime.setTimeToStartOfDay(startDate);
            }
        }
        return startDate;
    }
    
    private static Date generateEndDateIfPresent(Optional<String> endDateString, Date startDate) {
        assert endDateString != null;
        Date endDate = null;
        
        if (endDateString.isPresent()) {
            endDate = DateTime.convertStringToDate(endDateString.get());
            if (startDate != null && !DateTime.hasDateValue(endDateString.get())) {
                endDate = DateTime.setEndDateToStartDate(startDate, endDate);
            }
            if (!DateTime.hasTimeValue(endDateString.get())) {
                endDate = DateTime.setTimeToEndOfDay(endDate);
            }
        }
        return endDate;
    }
    
    private static RecurrenceRate generateRecurrenceRateIfPresent(Optional<String> rateString,
            Optional<String> timePeriodString) throws IllegalValueException {
        assert rateString != null && timePeriodString != null;
        RecurrenceRate recurrenceRate = null;
        
        if (rateString.isPresent() && timePeriodString.isPresent()) {
            recurrenceRate = new RecurrenceRate(rateString.get(), timePeriodString.get());
        } else if (!rateString.isPresent() && timePeriodString.isPresent()) {
            recurrenceRate = new RecurrenceRate(STRING_CONSTANT_ONE, timePeriodString.get());
        } else if (rateString.isPresent() && !timePeriodString.isPresent()) {
            throw new IllegalValueException(RecurrenceRate.MESSAGE_VALUE_CONSTRAINTS);
        }
        return recurrenceRate;
    }
    
    private static boolean recurWeekdaysButDatesNotGiven(Date startDate, Date endDate, RecurrenceRate recurrenceRate) {
        return recurrenceRate != null && recurrenceRate.timePeriod != TimePeriod.DAY && 
                recurrenceRate.timePeriod.toString().toLowerCase().contains("day") &&
                startDate == null && endDate == null;
    }

    private static boolean otherRecurrenceButDatesNotGiven(Date startDate, Date endDate, RecurrenceRate recurrenceRate) {
        return recurrenceRate != null && startDate == null && endDate == null;
    }
}
```
###### \java\seedu\address\logic\parser\CommandParser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args){
        assert args != null;
        
        logger.finer("Entering CommandParser, prepareAdd()");
        String argsTrimmed = args.trim();
        
        if(argsTrimmed.isEmpty()) {
            logger.finer("Trimmed argument is empty");
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        
        try {  
            HashMap<String, Optional<String>> extractedValues = new CommandParserHelper().prepareAdd(argsTrimmed);
            logger.finer("Exiting CommandParser, prepareAdd()");
            return new AddCommand(extractedValues);
            
        } catch (IllegalValueException ive) {
            logger.finer("IllegalValueException caught in CommandParser, prepareAdd()");
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    AddCommand.MESSAGE_USAGE + "\n" + ive.getMessage()));
        }
    }

    /**
     * Extracts the new person's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst(" t/", "").split(" t/"));
        return new HashSet<>(tagStrings);
    }
    
```
###### \java\seedu\address\logic\parser\CommandParserHelper.java
``` java
public class CommandParserHelper {
    
    private final Logger logger = LogsCenter.getLogger(CommandParserHelper.class);
    
    private static final String MESSAGE_REPEATED_START_TIME = "Repeated start times are not allowed.";
    private static final String MESSAGE_REPEATED_END_TIME = "Repeated end times are not allowed.";
    private static final String MESSAGE_INVALID_MATCHER = "Matcher is unable to find a match.";
    
    private static final int ZERO = 0;
    private static final int ONE = 1;
    private static final int TWO = 2;

    private static final String REGEX_OPEN_BRACE = "(";
    private static final String REGEX_CASE_IGNORE = "?i:";
    private static final String REGEX_CLOSE_BRACE = ")";
    private static final String REGEX_GREEDY_SELECT = ".*?";
    private static final String REGEX_ESCAPE = "\"";
    
    // greedily captures the taskName until it reaches the following keyword
    private static final String REGEX_NAME = "?<taskName>.*?";
    
    // used for concatenating keyword to REGEX_NAME
    private static final String REGEX_ADDITIONAL_KEYWORD = "(?:" + "(?: from )" + "|(?: at )" + "|(?: start )"
            + "|(?: by )" + "|(?: to )" + "|(?: end )" + ")";
    
    // greedily captures everything after the first keyword, until it reaches the following keyword
    private static final String REGEX_FIRST_DATE = "(?:" + "(?: from (?<startDateFormatOne>.*?))"
            + "|(?: at (?<startDateFormatTwo>.*?))" + "|(?: start (?<startDateFormatThree>.*?))"
            + "|(?: by (?<endDateFormatOne>.*?))" + "|(?: to (?<endDateFormatTwo>.*?))"
            + "|(?: end (?<endDateFormatThree>.*?))" + ")";
    
    // greedily captures everything after the first keyword, until it reaches the following keyword
    private static final String REGEX_SECOND_DATE = "(?:" + "(?: from (?:.*?))"
            + "|(?: at (?:.*?))" + "|(?: start (?:.*?))"
            + "|(?: by (?<endDateFormatFour>.*?))" + "|(?: to (?<endDateFormatFive>.*?))"
            + "|(?: end (?<endDateFormatSix>.*?))" + ")";
    
    // greedily captures everything after the first keyword, until it reaches the following keyword
    private static final String REGEX_RECURRENCE_AND_PRIORITY = "(?: repeat every (?<recurrenceRate>.*?))?"
            + "(?: -(?<priority>.*?))?";

    // beginning of regex when input is escaped
    private static final String REGEX_OPEN_BRACE_CASE_IGNORE_NAME_ESCAPE = REGEX_OPEN_BRACE + REGEX_CASE_IGNORE
            + REGEX_ESCAPE + REGEX_OPEN_BRACE + REGEX_NAME + REGEX_CLOSE_BRACE + REGEX_ESCAPE;
    
    // beginning of regex when input is not escaped
    private static final String REGEX_OPEN_BRACE_CASE_IGNORE_NAME = REGEX_OPEN_BRACE + REGEX_CASE_IGNORE
            + REGEX_OPEN_BRACE + REGEX_NAME;
    
    // used for concatenating keyword to REGEX_NAME
    private static final String REGEX_KEYWORD_GREEDY_SELECT = REGEX_ADDITIONAL_KEYWORD + REGEX_GREEDY_SELECT;
    
    // end of regex; only concatenated at the end of the regex
    private static final String REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE = REGEX_RECURRENCE_AND_PRIORITY
            + REGEX_CLOSE_BRACE;
    
    // seperates the recurrence rate captured by the previous regex into rate and timePeriod.
    private static final Pattern RECURRENCE_RATE_ARGS_FORMAT = Pattern.compile("(?<rate>\\d+)?(?<timePeriod>.*?)");


    //TODO: Change CommandParserHelper to static?
    private Pattern pattern;
    private Matcher matcher;

    /**
     * Returns a HashMap containing Optional<String> values of
     * taskName, startDate, endDate, rate, timePeriod and priority.
     *
     * @param args  user input of task to add.
     * @return     Values of taskName, startDate, endDate, rate, timePeriod and priority.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    public HashMap<String, Optional<String>> prepareAdd(String args) throws IllegalValueException {
        // how should i assert sia: assert args != null;
        OptionalStringTask task = new OptionalStringTask();
        
        if (args.contains(REGEX_ESCAPE)) {
            prepareAddForEscapeInput(args, task);
        } else {
            prepareAddForNonEscapeInput(args, task);
        }
        
        assignTaskParameters(task);
        return mapContainingVariables(task);
    }
    
```
###### \java\seedu\address\logic\parser\CommandParserHelper.java
``` java
    /**
     * Generates the right matcher for the escaped input args.
     *
     * @param args  user input of task to add.
     * @param task  object to store values for startDate and endDate.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void prepareAddForEscapeInput(String args, OptionalStringTask task) throws IllegalValueException {
        assert args != null && task != null;
        
        String argsMinusTaskName = generateArgsMinusTaskName(args);
        int numberOfKeywords = generateNumberOfKeywords(argsMinusTaskName);
        logger.log(Level.FINEST, "Number of keywords in \"" + args + "\" = " + numberOfKeywords);
        String regex = REGEX_OPEN_BRACE_CASE_IGNORE_NAME_ESCAPE;
        generateCorrectMatcherEscape(args, task, regex, numberOfKeywords);
    }

    /**
     * Generates the right matcher for the input args.
     *
     * @param args  user input of task to add.
     * @param task  object to store values for startDate and endDate.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void prepareAddForNonEscapeInput(String args, OptionalStringTask task) throws IllegalValueException {
        assert args != null && task != null;
        
        int numberOfKeywords = generateNumberOfKeywords(args);
        logger.log(Level.FINEST, "Number of keywords in \"" + args + "\" = " + numberOfKeywords);
        String regex = generateStartOfRegex(numberOfKeywords);
        generateCorrectMatcher(args, task, regex, numberOfKeywords);
    }

    /**
     * Returns a string containing args minus the escaped string.
     *
     * @param args  user input of task to add.
     * @return      args minus escaped string.
     */
    private String generateArgsMinusTaskName(String args) {
        assert args != null;
        
        int indexOfEndOfTaskName = args.lastIndexOf(REGEX_ESCAPE) + ONE;
        return args.substring(indexOfEndOfTaskName);
    }
    
    /**
     * Returns the number of occurrences of "from", "at", "start", "by", "to", "end" in args.
     * The value returned will be >= 0.
     *
     * @param args  user input of task to add.
     * @return      number of occurrences of "from", "at", "start", "by", "to", "end".
     */
    private int generateNumberOfKeywords(String args) {    
        assert args != null;
        
        int numberOfKeywords = ZERO;
        pattern = Pattern.compile(REGEX_ADDITIONAL_KEYWORD);
        matcher = pattern.matcher(args);
        while (matcher.find()) {
            numberOfKeywords++;
        }
        
        assert numberOfKeywords >= 0;
        return numberOfKeywords;
    }
    
    //TODO: HELP
    /**
     * Generates the beginning of the regex.
     *
     * @param numberOfKeywords  number of occurrences of "from", "at", "start", "by", "to", "end".
     * @return      the beginning of the regex.
     */
    private String generateStartOfRegex(int numberOfKeywords) {
        assert numberOfKeywords >= 0;
        
        String regex = REGEX_OPEN_BRACE_CASE_IGNORE_NAME;

        if (numberOfKeywords > TWO) {
            int numberOfAdditionalKeywords = numberOfKeywords - TWO;
            for (int i = 0; i < numberOfAdditionalKeywords; i++) {
                regex += REGEX_KEYWORD_GREEDY_SELECT;
            }
        }
        return regex;
    }

    /**
     * Generates the matcher for the given escaped args.
     *
     * @param args  user input of task to add.
     * @param task  object to store values for startDate and endDate.
     * @param regex regex generated by generateStartOfRegex().
     * @param numberOfKeywords  number of occurrences of "from", "at", "start", "by", "to", "end".
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateCorrectMatcherEscape(String args, OptionalStringTask task, String regex, int numberOfKeywords)
            throws IllegalValueException {
        assert args != null && task != null && regex != null && numberOfKeywords >= 0;
        if (numberOfKeywords == ZERO) {
            validateMatcherForNoKeywordEscape(args, regex);
        } else if (numberOfKeywords == ONE) {
            validateMatcherForOneKeywordEscape(args, task, regex);
        } else if (numberOfKeywords >= TWO) {
            validateMatcherForTwoKeywordsEscape(args, task, regex);
        }
    }
    
    /**
     * Generates the matcher for the given args.
     *
     * @param args  user input of task to add.
     * @param task  object to store values for startDate and endDate.
     * @param regex regex generated by generateStartOfRegex().
     * @param numberOfKeywords  number of occurrences of "from", "at", "start", "by", "to", "end".
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateCorrectMatcher(String args, OptionalStringTask task, String regex, int numberOfKeywords)
            throws IllegalValueException {
        assert args != null && task != null && regex != null && numberOfKeywords >= 0;
        if (numberOfKeywords == ZERO) {
            validateMatcherForNoKeyword(args, regex);
        } else if (numberOfKeywords == ONE) {
            validateMatcherForOneKeyword(args, task, regex);
        } else if (numberOfKeywords >= TWO) {
            validateMatcherForTwoKeywords(args, task, regex);
        }
    }

    /**
     * Validates the matcher for the given escaped args, where args has no keywords.
     *
     * @param args  user input of task to add.
     * @param regex regex generated by generateStartOfRegex().
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void validateMatcherForNoKeywordEscape(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        regex += REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
        generateAndValidateMatcher(args, regex);
    }

    /**
     * Validates the matcher for the given args, where args has no keywords.
     *
     * @param args  user input of task to add.
     * @param regex regex generated by generateStartOfRegex().
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void validateMatcherForNoKeyword(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        regex += REGEX_CLOSE_BRACE + REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
        generateAndValidateMatcher(args, regex);
    }
    
    /**
     * Generates and validates a matcher from the given args and regex.
     *
     * @param args  user input of task to add.
     * @param regex
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateAndValidateMatcher(String args, String regex) throws IllegalValueException {
        pattern = Pattern.compile(regex);
        matcher = pattern.matcher(args);
        if (!matcher.matches()) {
            throw new IllegalValueException(MESSAGE_INVALID_MATCHER);
        }
    }
    
    /**
     * Validates the matcher for the given escaped args, where args has one keyword.
     *
     * @param args  user input of task to add.
     * @param task  object to store values for startDate and endDate.
     * @param regex regex generated by generateStartOfRegex().
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void validateMatcherForOneKeywordEscape(String args, OptionalStringTask task, String regex)
            throws IllegalValueException {
        assert args != null && task != null && regex != null;
        generateMatcherForOneKeywordEscape(args, regex);
        setStartOrEndDate(task, matcher);
    }

    /**
     * Validates the matcher for the given args, where args has one keyword.
     *
     * @param args  user input of task to add.
     * @param task  object to store values for startDate and endDate.
     * @param regex regex generated by generateStartOfRegex().
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void validateMatcherForOneKeyword(String args, OptionalStringTask task, String regex)
            throws IllegalValueException {
        assert args != null && task != null && regex != null;
        generateMatcherForOneKeyword(args, regex);
        setStartOrEndDate(task, matcher);
        if (startOrEndDateIsInvalid(task.startDate, task.endDate)) {
            reinitialiseStartAndEndDatesToEmpty(task);
            regex += REGEX_KEYWORD_GREEDY_SELECT;
            validateMatcherForNoKeyword(args, regex);
        }
    }
    
    /**
     * Generates the matcher for the given escaped args, where args has one keyword.
     *
     * @param args  user input of task to add.
     * @param regex regex generated by generateStartOfRegex().
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForOneKeywordEscape(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        String regexCopy = generateRegexForOneKeywordEscape(regex);
        generateAndValidateMatcher(args, regexCopy);
    }

    /**
     * Generates the matcher for the given args, where args has one keyword.
     *
     * @param args  user input of task to add.
     * @param regex regex generated by generateStartOfRegex().
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForOneKeyword(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        String regexCopy = generateRegexForOneKeyword(regex);
        generateAndValidateMatcher(args, regexCopy);
    }
    
    /**
     * Generates the regex to match an escaped string with one keyword 
     * by concatenating the given regex generated by generateStartOfRegex() 
     * with the regex for matching one keyword.
     *
     * @param regex regex generated by generateStartOfRegex().
     * @return regex that matches an escaped string with one keyword.
     */
    private String generateRegexForOneKeywordEscape(String regex) {
        assert regex != null;
        return regex + REGEX_FIRST_DATE + REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
    }

    /**
     * Generates the regex to match an string with one keyword 
     * by concatenating the given regex generated by generateStartOfRegex() 
     * with the regex for matching one keyword.
     *
     * @param regex regex generated by generateStartOfRegex().
     * @return regex that matches a string with one keyword.
     */
    private String generateRegexForOneKeyword(String regex) {
        assert regex != null;
        return regex + REGEX_CLOSE_BRACE + REGEX_FIRST_DATE + REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
    }
    
    /**
     * Sets start date or end date depending on which matcher group was matched
     *
     * @param regex regex generated by generateStartOfRegex().
     */
    private void setStartOrEndDate(OptionalStringTask task, Matcher matcher) {
        assert task != null && matcher != null;
        task.startDate = validateStartDateFormatsOneToThree(matcher);
        task.endDate = validateEndDateFormatsOneToThree(matcher);
        assert task.startDate.isPresent() ^ task.endDate.isPresent();
    }
    
    /**
     * Reinitialises both start date and end date to be empty.
     *
     * @param task  object to store values for startDate and endDate.
     */
    private void reinitialiseStartAndEndDatesToEmpty(OptionalStringTask task) {
        assert task != null;
        task.startDate = Optional.empty();
        task.endDate = Optional.empty();
    }
    
    //TODO: HALP
    /**
     * Verifies if either startDate or endDate is present, and verifies whether 
     * the date that is present is valid.
     *
     * @param startDate 
     * @param endDate   
     * @return true if the date that is present is valid.
     */
    private boolean startOrEndDateIsInvalid(Optional<String> startDate, Optional<String> endDate) {
        return startDate.isPresent() && !DateTime.isValidDate(startDate.get())
                || endDate.isPresent() && !DateTime.isValidDate(endDate.get());
    }
    
    //TODO: HALP
    /**
     * Checks whether any of the matcher groups for start date are present. 
     * Either zero matcher groups are present or only one matcher group is present. 
     * Return the value of the matcher group if it is present, else return Optional.empty().
     *
     * @param matcher   
     * @return the value of the matcher group if it is present, else return Optional.empty().
     */
    private Optional<String> validateStartDateFormatsOneToThree(Matcher matcher) {
        assert matcher != null;

        Optional<String> startDate = Optional.empty();

        if (matcher.group("startDateFormatOne") != null) {
            startDate = Optional.of(matcher.group("startDateFormatOne").trim());
        } else if (matcher.group("startDateFormatTwo") != null) {
            startDate = Optional.of(matcher.group("startDateFormatTwo").trim());
        } else if (matcher.group("startDateFormatThree") != null) {
            startDate = Optional.of(matcher.group("startDateFormatThree").trim());
        }

        return startDate;
    }
    
    //TODO: HALP
    /**
     * Checks whether any of the matcher groups for end date are present. 
     * Either zero matcher groups are present or only one matcher group is present. 
     * Return the value of the matcher group if it is present, else return Optional.empty().
     *
     * @param matcher   
     * @return the value of the matcher group if it is present, else return Optional.empty().
     */
    private Optional<String> validateEndDateFormatsOneToThree(Matcher matcher) {
        assert matcher != null;

        Optional<String> endDate = Optional.empty();

        if (matcher.group("endDateFormatOne") != null) {
            endDate = Optional.of(matcher.group("endDateFormatOne").trim());
        } else if (matcher.group("endDateFormatTwo") != null) {
            endDate = Optional.of(matcher.group("endDateFormatTwo").trim());
        } else if (matcher.group("endDateFormatThree") != null) {
            endDate = Optional.of(matcher.group("endDateFormatThree").trim());
        }

        return endDate;
    }

    /**
     * Validates the matcher for the given escaped args, where args has two keywords.
     *
     * @param args  user input of task to add.
     * @param task  object to store values for startDate and endDate.
     * @param regex regex generated by generateStartOfRegex().
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void validateMatcherForTwoKeywordsEscape(String args, OptionalStringTask task, String regex)
            throws IllegalValueException {
        assert args != null && task != null && regex != null;
        generateMatcherForTwoKeywordsEscape(args, regex);
        setStartOrEndDate(task, matcher);
        validateStartAndEndDates(task);
    }
    
    /**
     * Validates the matcher for the given args, where args has two keywords.
     *
     * @param args  user input of task to add.
     * @param task  object to store values for startDate and endDate.
     * @param regex regex generated by generateStartOfRegex().
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void validateMatcherForTwoKeywords(String args, OptionalStringTask task, String regex)
            throws IllegalValueException {
        assert args != null && task != null && regex != null;
        generateMatcherForTwoKeywords(args, regex);
        setStartOrEndDate(task, matcher);
        if (startOrEndDateIsInvalid(task.startDate, task.endDate)) {
            reinitialiseStartAndEndDatesToEmpty(task);
            regex += REGEX_KEYWORD_GREEDY_SELECT;
            validateMatcherForOneKeyword(args, task, regex);
        } else { 
            validateStartAndEndDates(task);
        }
    }
    
    /**
     * Generates the matcher for the given escaped args, where args has two keywords.
     *
     * @param args  user input of task to add.
     * @param regex regex generated by generateStartOfRegex().
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForTwoKeywordsEscape(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        String regexCopy = generateRegexForTwoKeywordsEscape(regex);
        generateAndValidateMatcher(args, regexCopy);
    }


    /**
     * Generates the matcher for the given args, where args has two keywords.
     *
     * @param args  user input of task to add.
     * @param regex regex generated by generateStartOfRegex().
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForTwoKeywords(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        String regexCopy = generateRegexForTwoKeywords(regex);
        generateAndValidateMatcher(args, regexCopy);
    }
    
    /**
     * Generates the regex to match an escaped string with two keywords 
     * by concatenating the given regex generated by generateStartOfRegex() 
     * with the regex for matching two keywords.
     *
     * @param regex regex generated by generateStartOfRegex().
     * @return regex that matches an escaped string with two keywords.
     */
    private String generateRegexForTwoKeywordsEscape(String regex) {
        assert regex != null;
        return regex + REGEX_FIRST_DATE + REGEX_SECOND_DATE
                + REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
    }

    /**
     * Generates the regex to match an string with two keywords 
     * by concatenating the given regex generated by generateStartOfRegex() 
     * with the regex for matching two keywords.
     *
     * @param regex regex generated by generateStartOfRegex().
     * @return regex that matches a string with two keywords.
     */
    private String generateRegexForTwoKeywords(String regex) {
        assert regex != null;
        return regex + REGEX_CLOSE_BRACE + REGEX_FIRST_DATE + REGEX_SECOND_DATE
                + REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
    }

    //TODO: HALP I'M HERE
    /**
     * Generates the regex to match an string with two keywords 
     * by concatenating the given regex generated by generateStartOfRegex() 
     * with the regex for matching two keywords.
     *
     * @param task  object to store values for startDate and endDate.
     */
    private void validateStartAndEndDates(OptionalStringTask task) throws IllegalValueException {
        assert task != null;
        if (task.endDate.isPresent()) { // i.e does not allow "by 1030pm by 1050pm"
            throw new IllegalValueException(MESSAGE_REPEATED_END_TIME);
        } else {
            task.endDate = validateEndDateFormatsFourToSix(matcher);
        }
        
        if (!task.endDate.isPresent()) {
            throw new IllegalValueException(MESSAGE_REPEATED_START_TIME);
        }
    }

    
    private HashMap<String, Optional<String>> mapContainingVariables(OptionalStringTask task) {
        HashMap<String, Optional<String>> map = new HashMap<String, Optional<String>>();
        
        map.put("taskName", task.taskName);
        map.put("startDate", task.startDate);
        map.put("endDate", task.endDate);
        map.put("rate", task.rate);
        map.put("timePeriod", task.timePeriod);
        map.put("priority", task.priority);
        
        return map;
    }
    
    private HashMap<String, Optional<String>> generateRateAndTimePeriod(Matcher matcher) throws IllegalValueException {
        HashMap<String, Optional<String>> map = new HashMap<String, Optional<String>>();

        Optional<String> rate = Optional.empty();
        Optional<String> timePeriod = Optional.empty();

        if (matcher.group("recurrenceRate") != null) {
            final Matcher recurrenceMatcher = validateRecurrenceMatcher(matcher);

            if (recurrenceMatcher.group("rate") != null) {
                rate = Optional.of(recurrenceMatcher.group("rate").trim());
            }

            assert recurrenceMatcher.group("timePeriod") != null;

            timePeriod = Optional.of(recurrenceMatcher.group("timePeriod").trim());
        }

        map.put("rate", rate);
        map.put("timePeriod", timePeriod);

        return map;
    }

    private Optional<String> validateEndDateFormatsFourToSix(Matcher matcher) {
        assert matcher != null;

        Optional<String> endDate = Optional.empty();

        if (matcher.group("endDateFormatFour") != null) {
            endDate = Optional.of(matcher.group("endDateFormatFour").trim());
        } else if (matcher.group("endDateFormatFive") != null) {
            endDate = Optional.of(matcher.group("endDateFormatFive").trim());
        } else if (matcher.group("endDateFormatSix") != null) {
            endDate = Optional.of(matcher.group("endDateFormatSix").trim());
        }

        return endDate;
    }

    private String generatePriority(Matcher matcher) {
        String priority;
        if (matcher.group("priority") != null) {
            priority = matcher.group("priority").trim();
        } else {
            priority = "medium";
        }
        return priority;
    }

```
###### \java\seedu\address\logic\parser\CommandParserHelper.java
``` java
    // TODO: To update this
    private Matcher validateRecurrenceMatcher(Matcher matcher) throws IllegalValueException {
        String recurrenceString = matcher.group("recurrenceRate");
        final Matcher recurrenceMatcher = RECURRENCE_RATE_ARGS_FORMAT.matcher(recurrenceString);

        if (!recurrenceMatcher.matches()) {
            throw new IllegalValueException(MESSAGE_INVALID_MATCHER);
        }

        return recurrenceMatcher;
    }
    
    private void assignTaskParameters(OptionalStringTask task) throws IllegalValueException {
        assert matcher.group("taskName") != null;
        task.taskName = Optional.of(matcher.group("taskName").trim());
        HashMap<String, Optional<String>> recurrenceRateMap = generateRateAndTimePeriod(matcher);
        task.rate = recurrenceRateMap.get("rate");
        task.timePeriod = recurrenceRateMap.get("timePeriod");
        task.priority = Optional.of(generatePriority(matcher));
    }

```
###### \java\seedu\address\logic\parser\CommandParserHelper.java
``` java
    private class OptionalStringTask {
        public Optional<String> taskName;
        public Optional<String> startDate;
        public Optional<String> endDate;
        public Optional<String> rate;
        public Optional<String> timePeriod;
        public Optional<String> priority;
        
        public OptionalStringTask() {
            taskName = startDate = endDate = rate = timePeriod = priority = Optional.empty();
        }
    }
}
```
###### \java\seedu\address\model\item\DateTime.java
``` java
public abstract class DateTime {

    private static final int NEGATIVE_ONE = -1;
    public static final String TIME = "EXPLICIT_TIME";
    private static final String DATE_FORMAT_ONE = "EXPLICIT_DATE";
    private static final String DATE_FORMAT_TWO = "RELATIVE_DATE";

    private static final int BASE_INDEX = 0;
    private static final int INTEGER_CONSTANT_ONE = 1;

    private static final int NUMBER_OF_DAYS_IN_A_WEEK = 7;
    
    public static final String MESSAGE_VALUE_CONSTRAINTS = "DATE_TIME format: "
            + "DATE must be in one of the formats: "
            + "\"13th Sep 2015\", \"02-08-2015\" (mm/dd/yyyy) \n"
            + "TIME must be in one of the formats: "
            + "\"7:30am\", \"19:30\"";

    /**
     * Converts given String into a valid Date object
     * 
     * @return Date object converted from given String
     */
    public static Date convertStringToDate(String dateString) {
        List<DateGroup> dates = new Parser().parse(dateString);
        Date date = dates.get(BASE_INDEX).getDates().get(BASE_INDEX);
        return date;
    }

    public static boolean hasDateValue(String dateString) {
        List<DateGroup> dates = new Parser().parse(dateString);
        
        assert dates.get(BASE_INDEX) != null;
        
        String syntaxTree = dates.get(BASE_INDEX).getSyntaxTree().toStringTree();

        if (syntaxTree.contains(DATE_FORMAT_ONE) || syntaxTree.contains(DATE_FORMAT_TWO)) {
            return true;
        } else {
            return false;
        }
    }
    
    public static boolean hasTimeValue(String dateString) {
        List<DateGroup> dates = new Parser().parse(dateString);
        
        assert dates.get(BASE_INDEX) != null;
        
        String syntaxTree = dates.get(BASE_INDEX).getSyntaxTree().toStringTree();

        if (syntaxTree.contains(TIME)) {
            return true;
        } else {
            return false;
        }
    }
    
    public static Date setEndDateToStartDate(Date startDate, Date endDate) {
        Calendar calendarStartDate = Calendar.getInstance();
        calendarStartDate.setTime(startDate);
        int date = calendarStartDate.get(Calendar.DATE);
        int month = calendarStartDate.get(Calendar.MONTH);
        int year = calendarStartDate.get(Calendar.YEAR);

        Calendar calendarEndDate = Calendar.getInstance();
        calendarEndDate.setTime(endDate);
        calendarEndDate.set(Calendar.DATE, date);
        calendarEndDate.set(Calendar.MONTH, month);
        calendarEndDate.set(Calendar.YEAR, year);
        if (calendarEndDate.getTimeInMillis() <= calendarStartDate.getTimeInMillis()) {
            calendarEndDate.set(Calendar.DATE, date+1);
        } 
        
        Date updatedDate = calendarEndDate.getTime();
        return updatedDate;
    }

    //TODO: ??
    /**
     * Verifies if given String conforms to what was specified in User Guide e.g 
     * "5pm tomorrow", "02/10/2016", "13 Sep"
     */
    public static boolean isValidDate(String dateString) {
        assert dateString != null;
        List<DateGroup> dates = new Parser().parse(dateString.trim());
        try {
            dates.get(BASE_INDEX).getDates().get(BASE_INDEX);
            int positionOfMatchingValue = dates.get(BASE_INDEX).getPosition();
            String matchingValue = dates.get(BASE_INDEX).getText();
            
            if (positionOfMatchingValue > INTEGER_CONSTANT_ONE || !matchingValue.equals(dateString)) {
                return false;
            }
        } catch (IndexOutOfBoundsException ioobe) {
            return false;
        }
        return true;
    }
    
    /**
     * Assigns start date to a specified weekday
     */
    public static Date assignStartDateToSpecifiedWeekday(String dateString) {
        assert dateString != null && (dateString.toLowerCase().equals("monday") || dateString.toLowerCase().equals("tuesday") ||
        dateString.toLowerCase().equals("wednesday") || dateString.toLowerCase().equals("thursday") || 
        dateString.toLowerCase().equals("friday") || dateString.toLowerCase().equals("saturday") || 
        dateString.toLowerCase().equals("sunday"));
        
        List<DateGroup> dates = new Parser().parse(dateString);
        Date date = dates.get(BASE_INDEX).getDates().get(BASE_INDEX);
        date = setTimeToStartOfDay(date);
        date = correctDateIfSameDay(date);
        
        return date;
    }

    private static Date correctDateIfSameDay(Date date) {
        Calendar temp = Calendar.getInstance();
        Calendar actual = Calendar.getInstance();
        actual.setTime(date);
        
        if (actual.get(Calendar.DAY_OF_WEEK) == temp.get(Calendar.DAY_OF_WEEK)) {
            actual.add(Calendar.DATE, NUMBER_OF_DAYS_IN_A_WEEK * NEGATIVE_ONE);
            date = actual.getTime();
        }
        
        return date;
    }
    
    /**
     * Sets time of Date object to start of the day i.e "00:00:00"
     */
    public static Date setTimeToStartOfDay(Date date) {
        assert date != null;
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        
        Date updatedDate = calendar.getTime();
        return updatedDate;
    }

    /**
     * Sets time of Date object to end of the day i.e "23:59:59"
     */
    public static Date setTimeToEndOfDay(Date date) {
        assert date != null;
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.HOUR_OF_DAY, 23);
        calendar.set(Calendar.MINUTE, 59);
        calendar.set(Calendar.SECOND, 59);
        
        Date updatedDate = calendar.getTime();
        return updatedDate;
    }
    
    //TODO: Comments
    public static void updateDateByRecurrenceRate(Calendar calendar, RecurrenceRate recurrenceRate) {
        switch (recurrenceRate.timePeriod) {
        case HOUR:
            calendar.add(Calendar.HOUR_OF_DAY, recurrenceRate.rate);
            break;
        case DAY:
            calendar.add(Calendar.DAY_OF_YEAR, recurrenceRate.rate);
            break;
        case WEEK:
            calendar.add(Calendar.WEEK_OF_YEAR, recurrenceRate.rate);
            break;
        case MONTH:
            calendar.add(Calendar.MONTH, recurrenceRate.rate);
            break;
        case YEAR:
            calendar.add(Calendar.YEAR, recurrenceRate.rate);
            break;
        case MONDAY:
            DateTime.updateDateToNextMonday(calendar, recurrenceRate.rate);
            break;
        case TUESDAY:
            DateTime.updateDateToNextTuesday(calendar, recurrenceRate.rate);
            break;
        case WEDNESDAY:
            DateTime.updateDateToNextWednesday(calendar, recurrenceRate.rate);
            break;
        case THURSDAY:
            DateTime.updateDateToNextThursday(calendar, recurrenceRate.rate);
            break;
        case FRIDAY:
            DateTime.updateDateToNextFriday(calendar, recurrenceRate.rate);
            break;
        case SATURDAY:
            DateTime.updateDateToNextSaturday(calendar, recurrenceRate.rate);
            break;
        case SUNDAY:
            DateTime.updateDateToNextSunday(calendar, recurrenceRate.rate);
            break;
        }
    }
    
    //TODO: Comments
    private static void updateDateToNextMonday(Calendar calendar, int rate) {
        updateDateByRate(calendar, rate);

        calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        while (calendar.get(Calendar.DAY_OF_WEEK) != Calendar.MONDAY) {
            calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        }
    }

    private static void updateDateToNextTuesday(Calendar calendar, int rate) {
        updateDateByRate(calendar, rate);
        
        calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        while (calendar.get(Calendar.DAY_OF_WEEK) != Calendar.TUESDAY) {
            calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        }
    }

    private static void updateDateToNextWednesday(Calendar calendar, int rate) {
        updateDateByRate(calendar, rate);
        
        calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        while (calendar.get(Calendar.DAY_OF_WEEK) != Calendar.WEDNESDAY) {
            calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        }
    }

    private static void updateDateToNextThursday(Calendar calendar, int rate) {
        updateDateByRate(calendar, rate);
        
        calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        while (calendar.get(Calendar.DAY_OF_WEEK) != Calendar.THURSDAY) {
            calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        }
    }

    private static void updateDateToNextFriday(Calendar calendar, int rate) {
        updateDateByRate(calendar, rate);
        
        calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        while (calendar.get(Calendar.DAY_OF_WEEK) != Calendar.FRIDAY) {
            calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        }
    }

    private static void updateDateToNextSaturday(Calendar calendar, int rate) {
        updateDateByRate(calendar, rate);
        
        calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        while (calendar.get(Calendar.DAY_OF_WEEK) != Calendar.SATURDAY) {
            calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        }
    }

    private static void updateDateToNextSunday(Calendar calendar, int rate) {
        updateDateByRate(calendar, rate);
        
        calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        while (calendar.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {
            calendar.add(Calendar.DATE, INTEGER_CONSTANT_ONE);
        }
    }
    
    private static void updateDateByRate(Calendar calendar, int rate) {
        if (rate > INTEGER_CONSTANT_ONE) {
            calendar.add(Calendar.DATE, (rate - INTEGER_CONSTANT_ONE) * NUMBER_OF_DAYS_IN_A_WEEK);
        }
    }
}
```
###### \java\seedu\address\model\item\Name.java
``` java
public class Name {

    public String name;
    
    public Name(String name) {
        assert name != null;
        name = name.trim();
        this.name = name;
    }

    @Override
    public String toString() {
        return this.name;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.name.equals(((Name) other).name)); // state check
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

    public int compareTo(Name other) {
        return name.compareTo(other.name);
    }
}
```
###### \java\seedu\address\model\item\RecurrenceRate.java
``` java
public class RecurrenceRate {
    
    private static final String STRING_CONSTANT_ONE = "1";

    public static final String MESSAGE_VALUE_CONSTRAINTS = "RECURRING_INTERVAL Format : repeat every [RATE] TIME_PERIOD\n"
            + "RATE must be a positive integer and TIME_PERIOD must be in one of the formats: "
            + "\"hour(s)\", \"day(s)\", \"week(s)\", \"month(s)\", \"year(s)\", "
            + "or days of the week such as \"Monday\", \"Wed\"\n"
            + "For example: \"repeat every 3 days\", \"repeat every week\", \"repeat every Wed\"";
    
    
    
    public Integer rate;
    public TimePeriod timePeriod;

    /**
     * Validates given rate and timePeriod.
     *
     * @throws IllegalValueException if either values are invalid.
     */
    public RecurrenceRate(String rate, String timePeriodString) throws IllegalValueException {
        assert rate != null && timePeriodString != null;
        
        Optional<TimePeriod> timePeriod = TimePeriod.validateTimePeriodInput(timePeriodString.trim());
        this.timePeriod = timePeriod.orElseThrow(() -> new IllegalValueException(MESSAGE_VALUE_CONSTRAINTS));
        
        if (Integer.valueOf(rate) <= 0) {   
            throw new IllegalValueException(MESSAGE_VALUE_CONSTRAINTS);
        }
        
        try {
            this.rate = Integer.valueOf(rate);
        } catch (NumberFormatException nfe) {
            throw new IllegalValueException(MESSAGE_VALUE_CONSTRAINTS);
        }
    }
    
    public RecurrenceRate(String timePeriod) throws IllegalValueException {
        this(STRING_CONSTANT_ONE, timePeriod);
    }
    
    @Override
    public String toString() {
        return Integer.toString(rate) + " " + timePeriod.toString().toLowerCase();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof RecurrenceRate // instanceof handles nulls
                && this.rate.equals(((RecurrenceRate) other).rate) // state check
                && this.timePeriod.equals(((RecurrenceRate) other).timePeriod));
    }

    @Override
    public int hashCode() {
        return rate.hashCode();
    }
}
```
###### \java\seedu\address\model\item\Task.java
``` java
    //TODO: Comments - Zhi Yuan
    public void updateRecurringTask() {
        assert recurrenceRate != null && recurrenceRate.timePeriod != null && recurrenceRate.rate != null &&
                (startDate != null || endDate != null);

        if (startDate != null) {
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(startDate);
            DateTime.updateDateByRecurrenceRate(calendar, recurrenceRate);
            startDate = calendar.getTime();
        }
        if (endDate != null) {
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(endDate);
            DateTime.updateDateByRecurrenceRate(calendar, recurrenceRate);
            endDate = calendar.getTime();
        }
    }

```
###### \java\seedu\address\model\item\TimePeriod.java
``` java
public enum TimePeriod {
    HOUR,
    DAY,
    WEEK,
    MONTH,
    YEAR,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY;
    
    public static final HashMap<String, TimePeriod> INPUT_TO_TIME_PERIOD_MAP = new HashMap<String, TimePeriod>() {{
        put("hour", TimePeriod.HOUR);
        put("hours", TimePeriod.HOUR);
        put("day", TimePeriod.DAY);
        put("days", TimePeriod.DAY);
        put("week", TimePeriod.WEEK);
        put("weeks", TimePeriod.WEEK);
        put("month", TimePeriod.MONTH);
        put("months", TimePeriod.MONTH);
        put("year", TimePeriod.YEAR);
        put("years", TimePeriod.YEAR);
        put("mon", TimePeriod.MONDAY);
        put("monday", TimePeriod.MONDAY);
        put("tues", TimePeriod.TUESDAY);
        put("tuesday", TimePeriod.TUESDAY);
        put("wed", TimePeriod.WEDNESDAY);
        put("wednesday", TimePeriod.WEDNESDAY);
        put("thur", TimePeriod.THURSDAY);
        put("thurs", TimePeriod.THURSDAY);
        put("thursday", TimePeriod.THURSDAY);
        put("fri", TimePeriod.FRIDAY);
        put("friday", TimePeriod.FRIDAY);
        put("sat", TimePeriod.SATURDAY);
        put("saturday", TimePeriod.SATURDAY);
        put("sun", TimePeriod.SUNDAY);
        put("sunday", TimePeriod.SUNDAY);
    }};
    
    /**
     * Validates user input and converts it into TimePeriod.
     *
     * @return true if user input is recognised as a valid TimePeriod.
     */
    public static Optional<TimePeriod> validateTimePeriodInput(String timePeriodString) {
        assert timePeriodString != null;
        
        Optional<TimePeriod> timePeriod = Optional.empty();
        
        for (String key : INPUT_TO_TIME_PERIOD_MAP.keySet()) {
            if (key.equals(timePeriodString.toLowerCase())) {
                timePeriod = Optional.of(INPUT_TO_TIME_PERIOD_MAP.get(key));
            }
        }
        return timePeriod;
    }
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    public synchronized void editTask(ReadOnlyTask floatingTask, Name name, Date startDate,
            Date endDate, Priority priority, RecurrenceRate recurrenceRate) {
        taskManager.editFloatingTask(floatingTask, name, startDate, endDate, priority, recurrenceRate);
        updateFilteredListsToShowAll();
        indicateTaskManagerChanged();
    }

    //=========== Filtered Person List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredUndoneTaskList() {
        return new UnmodifiableObservableList<>(filteredUndoneTasks);
    }
    
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredDoneTaskList() {
        return new UnmodifiableObservableList<>(filteredDoneTasks);
    }

    public void TaskManager() {
        filteredUndoneTasks.setPredicate(null);
        filteredDoneTasks.setPredicate(null);
    }

    @Override
    public void updateFilteredUndoneTaskList(Set<String> keywords){
        updateFilteredUndoneTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

    private void updateFilteredUndoneTaskList(Expression expression) {
        filteredUndoneTasks.setPredicate(expression::satisfies);
    }
    
    @Override
    public void updateFilteredDoneTaskList(Set<String> keywords){
        updateFilteredDoneTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

    private void updateFilteredDoneTaskList(Expression expression) {
        filteredDoneTasks.setPredicate(expression::satisfies);
    }

    //========== Inner classes/interfaces used for filtering ==================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask person);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask person) {
            return qualifier.run(person);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask person);
        String toString();
    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask person) {
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsIgnoreCase(person.getName().name, keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }
    
```
