# A0093960X
###### \java\guitests\ClearCommandTest.java
``` java
public class ClearCommandTest extends DearJimGuiTest {

    @Override
    protected TaskManager getInitialData() {
        TaskManager ab = TestUtil.generateEmptyTaskManager();
        TypicalTestTasks.loadTaskManagerUndoneListWithSampleData(ab);
        TypicalTestTasks.loadTaskManagerDoneListWithSampleDate(ab);
        return ab;
    }

    /**
     * Runs the clear command on the undone task list without any arguments.
     */
    @Test
    public void clearCommand_clearUndoneListNormalCommand_listCleared() {
        // verify a non-empty list can be cleared
        assertTrue(personListPanel.isListMatching(td.getTypicalUndoneTasks()));
        assertListSize(7);
        assertUndoneListClearCommandSuccess();

        // verify other commands can work after a clear command
        commandBox.runCommand(td.hoon.getAddCommand());
        assertTrue(personListPanel.isListMatching(td.hoon));
        commandBox.runCommand("delete 1");
        assertListSize(0);

        // verify clear command works when the list is empty
        assertUndoneListClearCommandSuccess();
    }

    /**
     * Runs the clear command on the done task list without any arguments.
     */
    @Test
    public void clearCommand_clearDoneListNormalCommand_listCleared() {

        // verify a non-empty list can be cleared
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(td.getTypicalDoneTasks()));
        assertListSize(7);
        assertDoneListClearCommandSuccess();

        // verify other commands can work after a clear command
        commandBox.runCommand("list");
        commandBox.runCommand("done 1");
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(td.alice));
        commandBox.runCommand("delete 1");
        assertListSize(0);

        // verify clear command works when the list is empty
        assertDoneListClearCommandSuccess();
    }

    /**
     * Runs the clear command on both undone task list and done task list with
     * arguments and asserts that list is cleared in both cases.
     */
    @Test
    public void clearCommand_clearAnyListWithArgs_listCleared() {

        commandBox.runCommand("clear    1fasfs#!@32312");
        assertListSize(0);
        assertResultMessage(ClearCommand.MESSAGE_SUCCESS_UNDONE_LIST);

        commandBox.runCommand("list done");
        commandBox.runCommand("clear    1asdf123@#213");
        assertListSize(0);
        assertResultMessage(ClearCommand.MESSAGE_SUCCESS_DONE_LIST);

    }

    private void assertUndoneListClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task Manager undone list has been cleared!");
    }

    private void assertDoneListClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task Manager done list has been cleared!");
    }
}
```
###### \java\guitests\DearJimGuiTest.java
``` java
    /**
     * Asserts the message shown in the Result Display area is same as the given string.
     * 
     * @param expected the expected result message in the result display area
     */
    protected void assertResultMessage(String expected) {
        assertEquals(expected, resultDisplay.getText());
    }
    
    /**
     * Asserts the command input displayed in the command box area is same as the given string.
     * 
     * @param expected the expected command input string
     */
    protected void assertCommandInput(String expected) {
        assertEquals(expected, commandBox.getCommandInput());
    }
    
    
    /**
     * Asserts the add detailed tooltip displayed in the result displayed area matches the expected fields.
     * 
     * @param expectedName the expected name in the add detailed tooltip
     * @param expectedPriority the expected priority in the add detailed tooltip
     * @param expectedStartDate the expected start date in the add detailed tooltip
     * @param expectedEndDate the expected end date in the add detailed tooltip
     * @param expectedRecurrence the expected recurrence rate in the add detailed tooltip
     */
    protected void assertAddDetailedToolTip(String expectedName, String expectedPriority, 
            String expectedStartDate, String expectedEndDate, String expectedRecurrence) {
        
    }
    
    /**
     * Asserts the add detailed tooltip displayed in the result displayed area matches the expected fields.
     * 
     * @param expectedIndex the expected index in the edit detailed tooltip
     * @param expectedName the expected name in the edit detailed tooltip
     * @param expectedPriority the expected priority in the edit detailed tooltip
     * @param expectedStartDate the expected start date in the edit detailed tooltip
     * @param expectedEndDate the expected end date in the edit detailed tooltip
     * @param expectedRecurrence the expected recurrence rate in the edit detailed tooltip
     */
    protected void assertEditDetailedToolTip(String expectedIndex, String expectedName, String expectedPriority, 
            String expectedStartDate, String expectedEndDate, String expectedRecurrence) {
        
        
    }
}
```
###### \java\guitests\guihandles\GuiHandle.java
``` java
    private static final String PRIORITY_LOW = "LOW";
    private static final String PRIORITY_MEDIUM = "MEDIUM";
    private static final String PRIORITY_HIGH = "HIGH";
    private static final String HEXADECIMAL_GREEN = "0x008000ff";
    private static final String HEXADECIMAL_YELLOW = "0xffff00ff";
    private static final String HEXADECIMAL_RED = "0xff0000ff";

```
###### \java\guitests\guihandles\GuiHandle.java
``` java
    /**
     * Looks for the priority rectangle and returns a String that 
     * @param fieldId
     * @param parentNode
     * @return
     */
    protected String getTextFromPriorityRectangle(String fieldId, Node parentNode) {
        Paint rectanglePaint = findPriorityRectangleAndGetPaint(fieldId, parentNode);
        String fillColour = rectanglePaint.toString();

        switch (fillColour) {
        case HEXADECIMAL_RED :
            return PRIORITY_HIGH;
        case HEXADECIMAL_YELLOW :
            return PRIORITY_MEDIUM;
        case HEXADECIMAL_GREEN :
            return PRIORITY_LOW;
        default :
            assert false : "Rectangle should only be of the 3 colours above";
            logger.info("Rectangle other than red, yellow or green was detected.");
            return PRIORITY_MEDIUM;
        }
    }

    /**
     * Looks for the priority rectangle and returns the Paint that fills the given priority rectangle.
     * @param fieldId the fieldId of the priority rectangle to find
     * @param parentNode the parent node that contains the priority rectangle
     * @return the Paint that fills the specified priority rectangle
     */
    private Paint findPriorityRectangleAndGetPaint(String fieldId, Node parentNode) {
        return ((Rectangle) guiRobot.from(parentNode).lookup(fieldId).tryQuery().get()).getFill();
    }

```
###### \java\guitests\guihandles\TaskCardHandle.java
``` java
    public String getPriority() {
        return getTextFromPriorityRectangle(PRIORITY_FIELD_ID);
        
    }
    
    public String getIndex() {
        return getTextFromLabel(INDEX_FIELD_ID);
        
    }
    
    public String getStartDate() {
        return getTextFromLabel(START_DATE_FIELD_ID);
        
    }
    
    public String getEndDate() {
        return getTextFromLabel(END_DATE_FIELD_ID);
        
    }
    
    public String getRecurrenceRate() {
        return getTextFromLabel(RECURRENCE_RATE_FIELD_ID);
        
    }
    

```
###### \java\guitests\guihandles\TaskCardHandle.java
``` java
    @Override
    public boolean equals(Object obj) {
        if(obj instanceof TaskCardHandle) {
            TaskCardHandle handle = (TaskCardHandle) obj;
            return getName().equals(handle.getName())
                    && getPriority().equals(handle.getPriority())
                    && getIndex().equals(handle.getIndex())
                    && getStartDate().equals(handle.getStartDate())
                    && getEndDate().equals(handle.getEndDate())
                    && getRecurrenceRate().equals(handle.getRecurrenceRate());
        }
        return super.equals(obj);
    }

```
###### \java\guitests\HelpWindowTest.java
``` java
public class HelpWindowTest extends DearJimGuiTest {
    
    @Rule
    public ExpectedException thrown = ExpectedException.none();
    
    @Test 
    public void helpCommand_helpCommandOnlyInUndoneList_helpWindowOpens() {
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommand());
    }
    
    @Test 
    public void helpCommand_helpCommandOnlyInDoneList_helpWindowOpens() {
        commandBox.runCommand("list done");
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommand());
    }
    
    @Test 
    public void helpCommand_helpCommandWithArgsInUndoneList_helpWindowOpens() {
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommandWithArgs("123123123123"));
    }
    
    @Test 
    public void helpCommand_helpCommandWithArgsInDoneList_helpWindowOpens() {
        commandBox.runCommand("list done");
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommandWithArgs("123123123123"));
    }
    
    @Test
    public void helpCommand_buttonPressWhileFocusOnHelpWindow_helpWindowCloses() {
        HelpWindowHandle helpWindow = commandBox.runHelpCommand();
        assertHelpWindowOpen(helpWindow);
        helpWindow.pressEnter();
        assertHelpWindowClosed(helpWindow);
    }

    private void assertHelpWindowOpenAndCloseIt(HelpWindowHandle helpWindowHandle) {
        assertTrue(helpWindowHandle.isWindowOpen());
        helpWindowHandle.closeWindow();
    }
    
    private void assertHelpWindowOpen(HelpWindowHandle helpWindowHandle) {
        assertTrue(helpWindowHandle.isWindowOpen());
    }
    
    private void assertHelpWindowClosed(HelpWindowHandle helpWindowHandle) {
        thrown.expect(IllegalStateException.class);
        helpWindowHandle.isWindowOpen();
    }
   
}
```
###### \java\guitests\InputHistoryTest.java
``` java
public class InputHistoryTest extends DearJimGuiTest {

    /*
    @Test
    public void getPrevInput_noPrevInput_noChange() {
        assertGetPrevInputSuccess("");
    }
  

    @Test
    public void getNextInput_noNextInput_noChange() {
        assertGetNextInputSuccess("");
    }
    */

    @Test
    public void getPrevAndNextInput_singlePrevInput_ableToNavigatePrevAndNext() {
        commandBox.runCommand("list done");
        assertCommandInput("");
        assertGetPrevInputSuccess("list done");
        assertGetNextInputSuccess("");
    }

    @Test
    public void getPrevInput_navigatePrevInputWhileTypingHalfwayOnLatestInput_incompleteLatestInputSaved() {
        commandBox.runCommand("find lol");
        commandBox.enterCommand("I hope this command is saved when I press up!!");
        assertGetPrevInputSuccess("find lol");
        assertGetNextInputSuccess("I hope this command is saved when I press up!!");
        assertGetNextInputSuccess("I hope this command is saved when I press up!!");
    }

    @Test
    public void getPrevInput_typingOverAPrevInput_savedPrevInputIsNotOverwritten() {
        commandBox.runCommand("list done");
        commandBox.runCommand("find lol");
        assertGetPrevInputSuccess("find lol");
        assertGetPrevInputSuccess("list done");
        commandBox.runCommand("This input will not overwrite the previous one that was here");
        assertCommandInput("");
        assertGetPrevInputSuccess("This input will not overwrite the previous one that was here");
        assertGetPrevInputSuccess("find lol");
        assertGetPrevInputSuccess("list done");
    }

    private void assertGetPrevInputSuccess(String expected) {
        commandBox.getPreviousInput();
        assertCommandInput(expected);
    }

    private void assertGetNextInputSuccess(String expected) {
        commandBox.getNextInput();
        assertCommandInput(expected);
    }

}
```
###### \java\guitests\UndoAndRedoCommandTest.java
``` java
public class UndoAndRedoCommandTest extends DearJimGuiTest {
    
    private TestTask[] originalUndoneList = td.getTypicalUndoneTasks();
    private TestTask[] originalDoneList = td.getTypicalDoneTasks();

    @Override
    protected TaskManager getInitialData() {
        TaskManager ab = TestUtil.generateEmptyTaskManager();
        TypicalTestTasks.loadTaskManagerUndoneListWithSampleData(ab);
        TypicalTestTasks.loadTaskManagerDoneListWithSampleDate(ab);
        return ab;
    }
    
    @Test
    public void undoCommand_noPreviousUndoableCommand_nothingToUndo() {
        commandBox.runCommand("list");
        assertUndoSuccess(td.getTypicalUndoneTasks());
    }
    
    @Test
    public void redoCommand_noUndoToRedo_nothingToRedo() {
        commandBox.runCommand("list");
        assertRedoSuccess(td.getTypicalUndoneTasks());
    }
    
    @Test
    public void undoAndRedoCommand_addTask_deleteForUndoReaddForRedo() {
        TestTask taskToAdd = td.hoon;
        assertAddSuccess(taskToAdd, originalUndoneList);
        
        // undo the add
        assertUndoSuccess(originalUndoneList);
        
        // redo the add
        TestTask[] withHoon = TestUtil.addTasksToList(originalUndoneList, taskToAdd);
        assertRedoSuccess(withHoon);
        
        // check if works on list done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(withHoon));
    }
    
    @Test
    public void undoAndRedoCommand_deleteUndoneTask_readdForUndoDeleteForRedo() {
        
        TestTask[] undoneListWithoutCarl = TestUtil.removeTaskFromList(originalUndoneList, 3);
        
        assertDeleteSuccess(3, originalUndoneList);
                
        // undo the delete
        assertUndoSuccess(originalUndoneList);
        
        // delete hoon again
        assertRedoSuccess(undoneListWithoutCarl);
        
        // check if works on list done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(undoneListWithoutCarl));
    }
    
    @Test
    public void undoAndRedoCommand_deleteDoneTask_readdForUndoDeleteForRedo() {
       
        TestTask[] doneListWithoutGeorge = TestUtil.removeTaskFromList(originalDoneList, 7);
               
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(originalDoneList));
        assertDeleteSuccess(7, originalDoneList);
        assertUndoSuccess(originalDoneList);
        assertRedoSuccess(doneListWithoutGeorge);
        
        // check if works on list undone view
        commandBox.runCommand("list");
        assertUndoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(originalDoneList));
        commandBox.runCommand("list");
        assertRedoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(doneListWithoutGeorge));
    }
    
    @Test
    public void undoAndRedoCommand_clearUndoneTasks_unclearForUndoReclearForRedo() {

        assertUndoneListClearCommandSuccess();
        assertUndoSuccess(originalUndoneList);
        assertRedoSuccess();
        
        // check if targets undone tasks even on done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching());
    }

    
    @Test
    public void undoAndRedoCommand_clearDoneTasks_unclearForUndoReclearForRedo() {
        
        commandBox.runCommand("list done");
        assertDoneListClearCommandSuccess();
        assertUndoSuccess(originalDoneList);
        assertRedoSuccess();

        // check if targets done task even on undone view
        commandBox.runCommand("list");
        assertUndoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(originalDoneList));
        commandBox.runCommand("list");
        assertRedoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching());
    }
    
    @Test
    public void undoAndRedoCommand_editTask_reverseEditForUndoReeditforRedo() {
        TestTask aliceEdit = new TestTask(td.alice);
        TestTask aliceTaskBackup = new TestTask(td.alice);
        
        aliceEdit.setName(new Name("Meet Alice at jUnit mall"));
        try {
            aliceEdit.setStartDate(DateTime.convertStringToDate("2pm"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        try {
            aliceEdit.setEndDate(DateTime.convertStringToDate("3pm"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        try {
            aliceEdit.setRecurrence(new RecurrenceRate("3", "days"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        aliceEdit.setPriority(Priority.HIGH);
        
        originalUndoneList[0] = aliceEdit;
                
        commandBox.runCommand("edit 1 Meet Alice at jUnit mall from 2pm to 3pm repeat every 3 days -high");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        
        originalUndoneList[0] = aliceTaskBackup;
        assertUndoSuccess(originalUndoneList);
        originalUndoneList[0] = aliceEdit;
        assertRedoSuccess(originalUndoneList);
        
        // check if this works on the list done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        originalUndoneList[0] = aliceTaskBackup;
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        originalUndoneList[0] = aliceEdit;
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        
    }
    
    @Test
    public void undoAndRedoCommand_doneTask_undoneForUndoDoneForRedo() {
        //Setup for done
        TestTask aliceEdit = new TestTask(td.alice);

        aliceEdit.setName(new Name("Meet Alice at jUnit mall"));
        try {
            aliceEdit.setStartDate(DateTime.convertStringToDate("today 2pm"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        try {
            aliceEdit.setEndDate(DateTime.convertStringToDate("tomorrow 3pm"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        try {
            aliceEdit.setRecurrence(new RecurrenceRate("3", "days"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        aliceEdit.setPriority(Priority.HIGH);
        
        TestTask aliceRecur = new TestTask(aliceEdit);
        
        try {
            aliceRecur.setStartDate(DateTime.convertStringToDate("2pm 3 days later"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        
        try {
            aliceRecur.setEndDate(DateTime.convertStringToDate("3pm 4 days later"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        
        commandBox.runCommand("list done");
        commandBox.runCommand("delete 1");
        commandBox.runCommand("list");
        
        originalUndoneList[0] = aliceEdit;
        commandBox.runCommand("edit 1 Meet Alice at jUnit mall from today 2pm to tomorrow 3pm repeat every 3 days -high");
        assertTrue(personListPanel.isListMatching(originalUndoneList));

        // Real done test
        commandBox.runCommand("done 1");
        originalUndoneList[0] = aliceRecur;
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        originalUndoneList[0] = aliceEdit;
        assertUndoSuccess(originalUndoneList);
        originalUndoneList[0] = aliceRecur;
        assertRedoSuccess(originalUndoneList);
        
        TestTask[] doneListBeforeDone = TestUtil.removeTaskFromList(originalDoneList, 1);
        TestTask[] newDoneList = Arrays.copyOf(originalDoneList, originalDoneList.length);
        newDoneList[0] = aliceEdit;
        
        // check if it works on the done list too
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(newDoneList));
        assertUndoSuccess(doneListBeforeDone);
        commandBox.runCommand("list");
        originalUndoneList[0] = aliceEdit;
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(newDoneList);
        commandBox.runCommand("list");
        originalUndoneList[0] = aliceRecur;
        assertTrue(personListPanel.isListMatching(originalUndoneList));

    }
    
    @Test
    public void undoAndRedoCommand_undoableCommandAfterUndo_resetUndo() {
        
        assertUndoneListClearCommandSuccess();
        assertUndoSuccess(originalUndoneList);
        assertAddSuccess(td.hoon, originalUndoneList);
        
        TestTask[] withHoon = TestUtil.addTasksToList(originalUndoneList, td.hoon);
        assertRedoSuccess(withHoon);
        
    }
    
    /**
     * Runs the undo command to undo the previous undoable command and confirms the result is correct.
     * @param expectedList A copy of the expected list after the undo command executes successfully.
     */
    private void assertUndoSuccess(TestTask... expectedList) {
        commandBox.runCommand("undo");
        assertTrue(personListPanel.isListMatching(expectedList));
    }
    
    /**
     * Runs the redo command to redo the previous undone command and confirms the result is correct.
     * @param expectedList A copy of the expected list after the redo command executes successfully.
     */
    private void assertRedoSuccess(TestTask... expectedList) {
        commandBox.runCommand("redo");
        assertTrue(personListPanel.isListMatching(expectedList));
    }
    
    /**
     * Runs the add command to add the specified task and confirms the result is correct.
     * @param taskToAdd the task to be added
     * @param currentList A copy of the current list of persons (before deletion).
     */
    private void assertAddSuccess(TestTask taskToAdd, TestTask... currentList) {
        commandBox.runCommand(taskToAdd.getAddCommand());

        //confirm the new card contains the right data
        TaskCardHandle addedCard = personListPanel.navigateToFloatingTask(taskToAdd.getName().getTaskName());
        assertMatching(taskToAdd, addedCard);

        //confirm the list now contains all previous persons plus the new person
        TestTask[] expectedList = TestUtil.addTasksToList(currentList, taskToAdd);
        assertTrue(personListPanel.isListMatching(expectedList));
    }
    
    /**
     * Runs the delete command to delete the task at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. to delete the first task in the list, 1 should be given as the 
     *        target index.
     * @param currentList A copy of the current list of tasks (before deletion).
     */
    private void assertDeleteSuccess(int targetIndexOneIndexed, final TestTask[] currentList) {
        TestTask personToDelete = currentList[targetIndexOneIndexed-1]; //-1 because array uses zero indexing
        TestTask[] expectedRemainder = TestUtil.removeTaskFromList(currentList, targetIndexOneIndexed);

        commandBox.runCommand("delete " + targetIndexOneIndexed);

        //confirm the list now contains all previous persons except the deleted person
        assertTrue(personListPanel.isListMatching(expectedRemainder));

        //confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_DELETE_ITEM_SUCCESS, TestUtil.generateDisplayString(personToDelete)));
    }
        
    /**
     * Runs the clear command and confirms the result is correct (that undone list is cleared).
     */
    private void assertUndoneListClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task Manager undone list has been cleared!");
    }

    /**
     * Runs the clear command and confirms the result is correct (that done list is cleared).
     */
    private void assertDoneListClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task Manager done list has been cleared!");
    }
    

}
```
###### \java\seedu\address\logic\LogicManagerTest.java
``` java
    @Test
    public void toolTip_invalidCommandInput_incorrectCommandTooltip() {
        assertToolTipBehavior("", MESSAGE_TOOLTIP_INVALID_COMMAND_FORMAT);
        assertToolTipBehavior("   ", MESSAGE_TOOLTIP_INVALID_COMMAND_FORMAT);    
    }
    
    
    @Test
    public void toolTip_commandBeginningSubstringsOfAdd_addToolTip() {
        // simple add tooltip
        assertToolTipBehavior("a", AddCommand.TOOL_TIP);
        assertToolTipBehavior("ad", AddCommand.TOOL_TIP);
        assertToolTipBehavior("add", AddCommand.TOOL_TIP);
        assertToolTipBehavior("    add", AddCommand.TOOL_TIP);    

        
        //complicated add tooltip
        assertToolTipBehavior("add f", AddCommand.TOOL_TIP+ "\n\tAdding task: \n\tName:\tf\n\tPriority:\tmedium");
        assertToolTipBehavior("meet akshay at 1pm", AddCommand.TOOL_TIP + "\n\tAdding task: \n\tName:\tmeet akshay\n\tStart Date:\t1pm\n\tPriority:\tmedium");
        assertToolTipBehavior("do cs2103 tests", AddCommand.TOOL_TIP + "\n\tAdding task: \n\tName:\tdo cs2103 tests\n\tPriority:\tmedium");
        assertToolTipBehavior("   lolo l ", AddCommand.TOOL_TIP + "\n\tAdding task: \n\tName:\tlolo l\n\tPriority:\tmedium");    
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfClear_clearToolTip() {
        assertToolTipBehavior("c", ClearCommand.TOOL_TIP);
        assertToolTipBehavior("cl", ClearCommand.TOOL_TIP);
        assertToolTipBehavior("cle", ClearCommand.TOOL_TIP);
        assertToolTipBehavior("clea", ClearCommand.TOOL_TIP);
        assertToolTipBehavior("clear", ClearCommand.TOOL_TIP);
        assertToolTipBehavior("clear a", ClearCommand.TOOL_TIP);
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfDelete_deleteToolTip() {
        assertToolTipBehavior("d", DeleteCommand.TOOL_TIP + "\n" + DoneCommand.TOOL_TIP);
        assertToolTipBehavior("de", DeleteCommand.TOOL_TIP);
        assertToolTipBehavior("del", DeleteCommand.TOOL_TIP);
        assertToolTipBehavior("dele", DeleteCommand.TOOL_TIP);
        assertToolTipBehavior("delet", DeleteCommand.TOOL_TIP);
        assertToolTipBehavior("delete", DeleteCommand.TOOL_TIP);
        assertToolTipBehavior("delete 0", DeleteCommand.TOOL_TIP);
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfDone_doneToolTip() {
        assertToolTipBehavior("d", DeleteCommand.TOOL_TIP + "\n" + DoneCommand.TOOL_TIP);
        assertToolTipBehavior("do", DoneCommand.TOOL_TIP);
        assertToolTipBehavior("don", DoneCommand.TOOL_TIP);
        assertToolTipBehavior("done", DoneCommand.TOOL_TIP);
        assertToolTipBehavior("done 0", DoneCommand.TOOL_TIP);
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfEdit_editToolTip() {
        // simple edit tooltip
        assertToolTipBehavior("e", EditCommand.TOOL_TIP + "\n" + ExitCommand.TOOL_TIP);
        assertToolTipBehavior("ed", EditCommand.TOOL_TIP);
        assertToolTipBehavior("edi", EditCommand.TOOL_TIP);
        assertToolTipBehavior("edit", EditCommand.TOOL_TIP);
        
        // complicated edit tooltip
        assertToolTipBehavior("edit 0", EditCommand.TOOL_TIP + "\n\tEditing task at INDEX 0: \n\tName:\tNo Change" +
                "\n\tStart Date:\tNo Change" + "\n\tEnd Date:\t\tNo Change" + "\n\tRecurrence Rate:\tNo Change" + 
                "\n\tPriority:\tNo Change");
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfExit_exitToolTip() {
        assertToolTipBehavior("e", EditCommand.TOOL_TIP + "\n" + ExitCommand.TOOL_TIP);
        assertToolTipBehavior("ex", ExitCommand.TOOL_TIP);
        assertToolTipBehavior("exi", ExitCommand.TOOL_TIP);
        assertToolTipBehavior("exit", ExitCommand.TOOL_TIP);
        assertToolTipBehavior("exit 0", ExitCommand.TOOL_TIP);
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfFind_findToolTip() {
        assertToolTipBehavior("f", FindCommand.TOOL_TIP);
        assertToolTipBehavior("fi", FindCommand.TOOL_TIP);
        assertToolTipBehavior("fin", FindCommand.TOOL_TIP);
        assertToolTipBehavior("find", FindCommand.TOOL_TIP);
        assertToolTipBehavior("find 0", FindCommand.TOOL_TIP);
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfHelp_helpToolTip() {
        assertToolTipBehavior("h", HelpCommand.TOOL_TIP);
        assertToolTipBehavior("he", HelpCommand.TOOL_TIP);
        assertToolTipBehavior("hel", HelpCommand.TOOL_TIP);
        assertToolTipBehavior("help", HelpCommand.TOOL_TIP);
        assertToolTipBehavior("help r", HelpCommand.TOOL_TIP);
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfList_listToolTip() {
        assertToolTipBehavior("l", ListCommand.TOOL_TIP);
        assertToolTipBehavior("li", ListCommand.TOOL_TIP);
        assertToolTipBehavior("lis", ListCommand.TOOL_TIP);
        assertToolTipBehavior("list", ListCommand.TOOL_TIP);
        assertToolTipBehavior("list done", ListCommand.TOOL_TIP);
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfRedo_redoToolTip() {
        assertToolTipBehavior("r", RedoCommand.TOOL_TIP);
        assertToolTipBehavior("re", RedoCommand.TOOL_TIP);
        assertToolTipBehavior("red", RedoCommand.TOOL_TIP);
        assertToolTipBehavior("redo", RedoCommand.TOOL_TIP);
        assertToolTipBehavior("redo done", RedoCommand.TOOL_TIP);
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfSelect_selectToolTip() {
        assertToolTipBehavior("s", SelectCommand.TOOL_TIP + "\n" + StoreCommand.TOOL_TIP);
        assertToolTipBehavior("se", SelectCommand.TOOL_TIP);
        assertToolTipBehavior("sel", SelectCommand.TOOL_TIP);
        assertToolTipBehavior("sele", SelectCommand.TOOL_TIP);
        assertToolTipBehavior("selec", SelectCommand.TOOL_TIP);
        assertToolTipBehavior("select", SelectCommand.TOOL_TIP);
        assertToolTipBehavior("select 1", SelectCommand.TOOL_TIP);
    }
    
    @Test
    public void toolTip_commandBeginningSubstringsOfUndo_undoToolTip() {
        assertToolTipBehavior("u", UndoCommand.TOOL_TIP);
        assertToolTipBehavior("un", UndoCommand.TOOL_TIP);
        assertToolTipBehavior("und", UndoCommand.TOOL_TIP);
        assertToolTipBehavior("undo", UndoCommand.TOOL_TIP);
        assertToolTipBehavior("undo done", UndoCommand.TOOL_TIP);
    }
    
```
