# A0093960X
###### /java/guitests/ClearCommandTest.java
``` java
public class ClearCommandTest extends DearJimGuiTest {

    @Override
    protected TaskManager getInitialData() {
        TaskManager ab = TestUtil.generateEmptyTaskManager();
        TypicalTestTasks.loadTaskManagerUndoneListWithSampleData(ab);
        TypicalTestTasks.loadTaskManagerDoneListWithSampleDate(ab);
        return ab;
    }

    /**
     * Runs the clear command on the undone task list without any arguments.
     */
    @Test
    public void clearCommand_clearUndoneListNormalCommand_listCleared() {
        // verify a non-empty list can be cleared
        assertTrue(personListPanel.isListMatching(td.getTypicalUndoneTasks()));
        assertListSize(7);
        assertUndoneListClearCommandSuccess();

        // verify other commands can work after a clear command
        commandBox.runCommand(td.hoon.getAddCommand());
        assertTrue(personListPanel.isListMatching(td.hoon));
        commandBox.runCommand("delete 1");
        assertListSize(0);

        // verify clear command works when the list is empty
        assertUndoneListClearCommandSuccess();
    }

    /**
     * Runs the clear command on the done task list without any arguments.
     */
    @Test
    public void clearCommand_clearDoneListNormalCommand_listCleared() {

        // verify a non-empty list can be cleared
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(td.getTypicalDoneTasks()));
        assertListSize(7);
        assertDoneListClearCommandSuccess();

        // verify other commands can work after a clear command
        commandBox.runCommand("list");
        commandBox.runCommand("done 1");
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(td.alice));
        commandBox.runCommand("delete 1");
        assertListSize(0);

        // verify clear command works when the list is empty
        assertDoneListClearCommandSuccess();
    }

    /**
     * Runs the clear command on both undone task list and done task list with
     * arguments and asserts that list is cleared in both cases.
     */
    @Test
    public void clearCommand_clearAnyListWithArgs_listCleared() {

        commandBox.runCommand("clear    1fasfs#!@32312");
        assertListSize(0);
        assertResultMessage(ClearCommand.MESSAGE_SUCCESS_UNDONE_LIST);

        commandBox.runCommand("list done");
        commandBox.runCommand("clear    1asdf123@#213");
        assertListSize(0);
        assertResultMessage(ClearCommand.MESSAGE_SUCCESS_DONE_LIST);

    }

    private void assertUndoneListClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task Manager undone list has been cleared!");
    }

    private void assertDoneListClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task Manager done list has been cleared!");
    }
}
```
###### /java/guitests/DearJimGuiTest.java
``` java
    /**
     * Asserts the message shown in the Result Display area is same as the given string.
     * 
     * @param expected the expected result message in the result display area
     */
    protected void assertResultMessage(String expected) {
        assertEquals(expected, resultDisplay.getText());
    }
    
    /**
     * Asserts the command input displayed in the command box area is same as the given string.
     * 
     * @param expected the expected command input string
     */
    protected void assertCommandInput(String expected) {
        assertEquals(expected, commandBox.getCommandInput());
    }
}
```
###### /java/guitests/guihandles/GuiHandle.java
``` java
    private static final String PRIORITY_LOW = "LOW";
    private static final String PRIORITY_MEDIUM = "MEDIUM";
    private static final String PRIORITY_HIGH = "HIGH";
    private static final String HEXADECIMAL_GREEN = "0x008000ff";
    private static final String HEXADECIMAL_YELLOW = "0xffff00ff";
    private static final String HEXADECIMAL_RED = "0xff0000ff";

```
###### /java/guitests/guihandles/GuiHandle.java
``` java
    /**
     * Looks for the priority rectangle and returns a String that 
     * @param fieldId
     * @param parentNode
     * @return
     */
    protected String getTextFromPriorityRectangle(String fieldId, Node parentNode) {
        Paint rectanglePaint = findPriorityRectangleAndGetPaint(fieldId, parentNode);
        String fillColour = rectanglePaint.toString();

        switch (fillColour) {
        case HEXADECIMAL_RED :
            return PRIORITY_HIGH;
        case HEXADECIMAL_YELLOW :
            return PRIORITY_MEDIUM;
        case HEXADECIMAL_GREEN :
            return PRIORITY_LOW;
        default :
            assert false : "Rectangle should only be of the 3 colours above";
            logger.info("Rectangle other than red, yellow or green was detected.");
            return PRIORITY_MEDIUM;
        }
    }

    /**
     * Looks for the priority rectangle and returns the Paint that fills the given priority rectangle.
     * @param fieldId the fieldId of the priority rectangle to find
     * @param parentNode the parent node that contains the priority rectangle
     * @return the Paint that fills the specified priority rectangle
     */
    private Paint findPriorityRectangleAndGetPaint(String fieldId, Node parentNode) {
        return ((Rectangle) guiRobot.from(parentNode).lookup(fieldId).tryQuery().get()).getFill();
    }

```
###### /java/guitests/guihandles/TaskCardHandle.java
``` java
    public String getPriority() {
        return getTextFromPriorityRectangle(PRIORITY_FIELD_ID);
        
    }
    
    public String getIndex() {
        return getTextFromLabel(INDEX_FIELD_ID);
        
    }
    
    public String getStartDate() {
        return getTextFromLabel(START_DATE_FIELD_ID);
        
    }
    
    public String getEndDate() {
        return getTextFromLabel(END_DATE_FIELD_ID);
        
    }
    
    public String getRecurrenceRate() {
        return getTextFromLabel(RECURRENCE_RATE_FIELD_ID);
        
    }
    

```
###### /java/guitests/guihandles/TaskCardHandle.java
``` java
    @Override
    public boolean equals(Object obj) {
        if(obj instanceof TaskCardHandle) {
            TaskCardHandle handle = (TaskCardHandle) obj;
            return getName().equals(handle.getName())
                    && getPriority().equals(handle.getPriority())
                    && getIndex().equals(handle.getIndex())
                    && getStartDate().equals(handle.getStartDate())
                    && getEndDate().equals(handle.getEndDate())
                    && getRecurrenceRate().equals(handle.getRecurrenceRate());
        }
        return super.equals(obj);
    }

```
###### /java/guitests/HelpWindowTest.java
``` java
public class HelpWindowTest extends DearJimGuiTest {
    
    @Rule
    public ExpectedException thrown = ExpectedException.none();
    
    @Test 
    public void helpCommand_helpCommandOnlyInUndoneList_helpWindowOpens() {
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommand());
    }
    
    @Test 
    public void helpCommand_helpCommandOnlyInDoneList_helpWindowOpens() {
        commandBox.runCommand("list done");
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommand());
    }
    
    @Test 
    public void helpCommand_helpCommandWithArgsInUndoneList_helpWindowOpens() {
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommandWithArgs("123123123123"));
    }
    
    @Test 
    public void helpCommand_helpCommandWithArgsInDoneList_helpWindowOpens() {
        commandBox.runCommand("list done");
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommandWithArgs("123123123123"));
    }
    
    @Test
    public void helpCommand_buttonPressWhileFocusOnHelpWindow_helpWindowCloses() {
        HelpWindowHandle helpWindow = commandBox.runHelpCommand();
        assertHelpWindowOpen(helpWindow);
        helpWindow.pressEnter();
        assertHelpWindowClosed(helpWindow);
    }

    private void assertHelpWindowOpenAndCloseIt(HelpWindowHandle helpWindowHandle) {
        assertTrue(helpWindowHandle.isWindowOpen());
        helpWindowHandle.closeWindow();
    }
    
    private void assertHelpWindowOpen(HelpWindowHandle helpWindowHandle) {
        assertTrue(helpWindowHandle.isWindowOpen());
    }
    
    private void assertHelpWindowClosed(HelpWindowHandle helpWindowHandle) {
        thrown.expect(IllegalStateException.class);
        helpWindowHandle.isWindowOpen();
    }
   
}
```
###### /java/guitests/InputHistoryTest.java
``` java
public class InputHistoryTest extends DearJimGuiTest {

    /*
    @Test
    public void getPrevInput_noPrevInput_noChange() {
        assertGetPrevInputSuccess("");
    }
  

    @Test
    public void getNextInput_noNextInput_noChange() {
        assertGetNextInputSuccess("");
    }
    */

    @Test
    public void getPrevAndNextInput_singlePrevInput_ableToNavigatePrevAndNext() {
        commandBox.runCommand("list done");
        assertCommandInput("");
        assertGetPrevInputSuccess("list done");
        assertGetNextInputSuccess("");
    }

    @Test
    public void getPrevInput_navigatePrevInputWhileTypingHalfwayOnLatestInput_incompleteLatestInputSaved() {
        commandBox.runCommand("find lol");
        commandBox.enterCommand("I hope this command is saved when I press up!!");
        assertGetPrevInputSuccess("find lol");
        assertGetNextInputSuccess("I hope this command is saved when I press up!!");
        assertGetNextInputSuccess("I hope this command is saved when I press up!!");
    }

    @Test
    public void getPrevInput_typingOverAPrevInput_savedPrevInputIsNotOverwritten() {
        commandBox.runCommand("list done");
        commandBox.runCommand("find lol");
        assertGetPrevInputSuccess("find lol");
        assertGetPrevInputSuccess("list done");
        commandBox.runCommand("This input will not overwrite the previous one that was here");
        assertCommandInput("");
        assertGetPrevInputSuccess("This input will not overwrite the previous one that was here");
        assertGetPrevInputSuccess("find lol");
        assertGetPrevInputSuccess("list done");
    }

    private void assertGetPrevInputSuccess(String expected) {
        commandBox.getPreviousInput();
        assertCommandInput(expected);
    }

    private void assertGetNextInputSuccess(String expected) {
        commandBox.getNextInput();
        assertCommandInput(expected);
    }

}
```
###### /java/guitests/UndoAndRedoCommandTest.java
``` java
public class UndoAndRedoCommandTest extends DearJimGuiTest {
    
    private TestTask[] originalUndoneList = td.getTypicalUndoneTasks();
    private TestTask[] originalDoneList = td.getTypicalDoneTasks();

    @Override
    protected TaskManager getInitialData() {
        TaskManager ab = TestUtil.generateEmptyTaskManager();
        TypicalTestTasks.loadTaskManagerUndoneListWithSampleData(ab);
        TypicalTestTasks.loadTaskManagerDoneListWithSampleDate(ab);
        return ab;
    }
    
    @Test
    public void undoCommand_noPreviousUndoableCommand_nothingToUndo() {
        commandBox.runCommand("list");
        assertUndoSuccess(td.getTypicalUndoneTasks());
    }
    
    @Test
    public void redoCommand_noUndoToRedo_nothingToRedo() {
        commandBox.runCommand("list");
        assertRedoSuccess(td.getTypicalUndoneTasks());
    }
    
    @Test
    public void undoAndRedoCommand_addTask_deleteForUndoReaddForRedo() {
        TestTask taskToAdd = td.hoon;
        assertAddSuccess(taskToAdd, originalUndoneList);
        
        // undo the add
        assertUndoSuccess(originalUndoneList);
        
        // redo the add
        TestTask[] withHoon = TestUtil.addTasksToList(originalUndoneList, taskToAdd);
        assertRedoSuccess(withHoon);
        
        // check if works on list done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(withHoon));
    }
    
    @Test
    public void undoAndRedoCommand_deleteUndoneTask_readdForUndoDeleteForRedo() {
        
        TestTask[] undoneListWithoutCarl = TestUtil.removeTaskFromList(originalUndoneList, 3);
        
        assertDeleteSuccess(3, originalUndoneList);
                
        // undo the delete
        assertUndoSuccess(originalUndoneList);
        
        // delete hoon again
        assertRedoSuccess(undoneListWithoutCarl);
        
        // check if works on list done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(undoneListWithoutCarl));
    }
    
    @Test
    public void undoAndRedoCommand_deleteDoneTask_readdForUndoDeleteForRedo() {
       
        TestTask[] doneListWithoutGeorge = TestUtil.removeTaskFromList(originalDoneList, 7);
               
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(originalDoneList));
        assertDeleteSuccess(7, originalDoneList);
        assertUndoSuccess(originalDoneList);
        assertRedoSuccess(doneListWithoutGeorge);
        
        // check if works on list undone view
        commandBox.runCommand("list");
        assertUndoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(originalDoneList));
        commandBox.runCommand("list");
        assertRedoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(doneListWithoutGeorge));
    }
    
    @Test
    public void undoAndRedoCommand_clearUndoneTasks_unclearForUndoReclearForRedo() {

        assertUndoneListClearCommandSuccess();
        assertUndoSuccess(originalUndoneList);
        assertRedoSuccess();
        
        // check if targets undone tasks even on done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching());
    }

    
    @Test
    public void undoAndRedoCommand_clearDoneTasks_unclearForUndoReclearForRedo() {
        
        commandBox.runCommand("list done");
        assertDoneListClearCommandSuccess();
        assertUndoSuccess(originalDoneList);
        assertRedoSuccess();

        // check if targets done task even on undone view
        commandBox.runCommand("list");
        assertUndoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(originalDoneList));
        commandBox.runCommand("list");
        assertRedoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching());
    }
    
    @Test
    public void undoAndRedoCommand_editTask_reverseEditForUndoReeditforRedo() {
        TestTask aliceEdit = new TestTask(td.alice);
        TestTask aliceTaskBackup = new TestTask(td.alice);
        
        aliceEdit.setName(new Name("Meet Alice at jUnit mall"));
        try {
            aliceEdit.setStartDate(DateTime.convertStringToDate("2pm"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        try {
            aliceEdit.setEndDate(DateTime.convertStringToDate("3pm"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        try {
            aliceEdit.setRecurrence(new RecurrenceRate("3", "days"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        aliceEdit.setPriority(Priority.HIGH);
        
        originalUndoneList[0] = aliceEdit;
                
        commandBox.runCommand("edit 1 Meet Alice at jUnit mall from 2pm to 3pm repeat every 3 days -high");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        
        originalUndoneList[0] = aliceTaskBackup;
        assertUndoSuccess(originalUndoneList);
        originalUndoneList[0] = aliceEdit;
        assertRedoSuccess(originalUndoneList);
        
        // check if this works on the list done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        originalUndoneList[0] = aliceTaskBackup;
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        originalUndoneList[0] = aliceEdit;
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        
    }
    
    @Test
    public void undoAndRedoCommand_doneTask_undoneForUndoDoneForRedo() {
        //Setup for done
        TestTask aliceEdit = new TestTask(td.alice);

        aliceEdit.setName(new Name("Meet Alice at jUnit mall"));
        try {
            aliceEdit.setStartDate(DateTime.convertStringToDate("today 2pm"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        try {
            aliceEdit.setEndDate(DateTime.convertStringToDate("tomorrow 3pm"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        try {
            aliceEdit.setRecurrence(new RecurrenceRate("3", "days"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        aliceEdit.setPriority(Priority.HIGH);
        
        TestTask aliceRecur = new TestTask(aliceEdit);
        
        try {
            aliceRecur.setStartDate(DateTime.convertStringToDate("2pm 3 days later"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        
        try {
            aliceRecur.setEndDate(DateTime.convertStringToDate("3pm 4 days later"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        
        commandBox.runCommand("list done");
        commandBox.runCommand("delete 1");
        commandBox.runCommand("list");
        
        originalUndoneList[0] = aliceEdit;
        commandBox.runCommand("edit 1 Meet Alice at jUnit mall from today 2pm to tomorrow 3pm repeat every 3 days -high");
        assertTrue(personListPanel.isListMatching(originalUndoneList));

        // Real done test
        commandBox.runCommand("done 1");
        originalUndoneList[0] = aliceRecur;
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        originalUndoneList[0] = aliceEdit;
        assertUndoSuccess(originalUndoneList);
        originalUndoneList[0] = aliceRecur;
        assertRedoSuccess(originalUndoneList);
        
        TestTask[] doneListBeforeDone = TestUtil.removeTaskFromList(originalDoneList, 1);
        TestTask[] newDoneList = Arrays.copyOf(originalDoneList, originalDoneList.length);
        newDoneList[0] = aliceEdit;
        
        // check if it works on the done list too
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(newDoneList));
        assertUndoSuccess(doneListBeforeDone);
        commandBox.runCommand("list");
        originalUndoneList[0] = aliceEdit;
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(newDoneList);
        commandBox.runCommand("list");
        originalUndoneList[0] = aliceRecur;
        assertTrue(personListPanel.isListMatching(originalUndoneList));

    }
    
    @Test
    public void undoAndRedoCommand_undoableCommandAfterUndo_resetUndo() {
        
        assertUndoneListClearCommandSuccess();
        assertUndoSuccess(originalUndoneList);
        assertAddSuccess(td.hoon, originalUndoneList);
        
        TestTask[] withHoon = TestUtil.addTasksToList(originalUndoneList, td.hoon);
        assertRedoSuccess(withHoon);
        
    }
    
    /**
     * Runs the undo command to undo the previous undoable command and confirms the result is correct.
     * @param expectedList A copy of the expected list after the undo command executes successfully.
     */
    private void assertUndoSuccess(TestTask... expectedList) {
        commandBox.runCommand("undo");
        assertTrue(personListPanel.isListMatching(expectedList));
    }
    
    /**
     * Runs the redo command to redo the previous undone command and confirms the result is correct.
     * @param expectedList A copy of the expected list after the redo command executes successfully.
     */
    private void assertRedoSuccess(TestTask... expectedList) {
        commandBox.runCommand("redo");
        assertTrue(personListPanel.isListMatching(expectedList));
    }
    
    /**
     * Runs the add command to add the specified task and confirms the result is correct.
     * @param taskToAdd the task to be added
     * @param currentList A copy of the current list of persons (before deletion).
     */
    private void assertAddSuccess(TestTask taskToAdd, TestTask... currentList) {
        commandBox.runCommand(taskToAdd.getAddCommand());

        //confirm the new card contains the right data
        TaskCardHandle addedCard = personListPanel.navigateToFloatingTask(taskToAdd.getName().getTaskName());
        assertMatching(taskToAdd, addedCard);

        //confirm the list now contains all previous persons plus the new person
        TestTask[] expectedList = TestUtil.addTasksToList(currentList, taskToAdd);
        assertTrue(personListPanel.isListMatching(expectedList));
    }
    
    /**
     * Runs the delete command to delete the task at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. to delete the first task in the list, 1 should be given as the 
     *        target index.
     * @param currentList A copy of the current list of tasks (before deletion).
     */
    private void assertDeleteSuccess(int targetIndexOneIndexed, final TestTask[] currentList) {
        TestTask personToDelete = currentList[targetIndexOneIndexed-1]; //-1 because array uses zero indexing
        TestTask[] expectedRemainder = TestUtil.removeTaskFromList(currentList, targetIndexOneIndexed);

        commandBox.runCommand("delete " + targetIndexOneIndexed);

        //confirm the list now contains all previous persons except the deleted person
        assertTrue(personListPanel.isListMatching(expectedRemainder));

        //confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_DELETE_TASK_SUCCESS, TestUtil.generateDisplayString(personToDelete)));
    }
        
    /**
     * Runs the clear command and confirms the result is correct (that undone list is cleared).
     */
    private void assertUndoneListClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task Manager undone list has been cleared!");
    }

    /**
     * Runs the clear command and confirms the result is correct (that done list is cleared).
     */
    private void assertDoneListClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task Manager done list has been cleared!");
    }
    

}
```
###### /java/seedu/address/logic/TooltipTest.java
``` java
public class TooltipTest {

    private static final String NEWLINE = "\n";
    private CommandParser commandParser;

    @Before
    public void setup() {
        commandParser = new CommandParser();
        EventsCenter.getInstance().registerHandler(this);
    }

    @After
    public void teardown() {
        EventsCenter.clearSubscribers();
    }

    @Test
    public void tooltip_undoneListInvalidCommandInput_incorrectCommandTooltip() {
        assertTooltipBehaviorUndoneList("   ", MESSAGE_TOOLTIP_INVALID_COMMAND_FORMAT);
    }

    @Test
    public void tooltip_doneListInvalidCommandInput_incorrectCommandTooltip() {
        assertToolTipBehaviorDoneList("   ", MESSAGE_TOOLTIP_INVALID_COMMAND_FORMAT);
    }

    @Test
    public void tooltip_doneListInvalidCommand_restrictedCommandTooltip() {
        assertToolTipBehaviorDoneList("add", MESSAGE_DONE_LIST_RESTRICTED_COMMANDS);
        assertToolTipBehaviorDoneList("edit", MESSAGE_DONE_LIST_RESTRICTED_COMMANDS);
        assertToolTipBehaviorDoneList("done", MESSAGE_DONE_LIST_RESTRICTED_COMMANDS);
    }

    @Test
    public void tooltip_undoneListCommandBeginningSubstringsOfAdd_addTooltip() {
        assertTooltipBehaviorUndoneList("a", AddCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("add", AddCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("    add", AddCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_undoneListDetailedAddInput_detailedAddTooltip() {
        assertTooltipBehaviorUndoneList("add Meet Hoon Meier from 2pm to 3pm repeat every month",
                buildAddTooltip("Meet Hoon Meier", "medium", "every month", "2pm", "3pm"));
        assertTooltipBehaviorUndoneList("meet akshay from today to tomorrow repeat every 3 days -high",
                buildAddTooltip("meet akshay", "high", "every 3 days", "today", "tomorrow"));
        assertTooltipBehaviorUndoneList("\"edit my essay by today\" by today -high",
                buildAddTooltip("edit my essay by today", "high", null, null, "today"));
    }

    @Test
    public void tooltip_undoneListCommandBeginningSubstringsOfEdit_editTooltip() {
        assertTooltipBehaviorUndoneList("edit", EditCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_detailedEditInput_detailedEditTooltip() {
        assertTooltipBehaviorUndoneList("edit 3 Call the school to ask something from 9am to 10am repeat every day -low",
                buildEditTooltip("3", "Call the school to ask something", "low", "every day", "9am", "10am"));
        assertTooltipBehaviorUndoneList("edit 100 repeat every 2 days -high -reset start",
                buildEditTooltip("100", "No Change", "high", "every 2 days", "RESET", "No Change"));
        assertTooltipBehaviorUndoneList("edit 342 from 1am -reset start end priority",
                buildEditTooltip("342", "No Change", "RESET", "No Change", "RESET", "RESET"));
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfClear_clearTooltip() {
        assertTooltipBehaviorUndoneList("c", ClearCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("clear", ClearCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("clear a", ClearCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfDelete_deleteTooltip() {
        assertTooltipBehaviorUndoneList("delete", DeleteCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("delete 100", DeleteCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfDone_doneTooltip() {
        assertTooltipBehaviorUndoneList("done", DoneCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("done 100", DoneCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfExit_exitTooltip() {
        assertTooltipBehaviorUndoneList("exit", ExitCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("exit 0", ExitCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfFind_findTooltip() {
        assertTooltipBehaviorUndoneList("f", FindCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("find", FindCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("find looking for my favourite task!", FindCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfHelp_helpTooltip() {
        assertTooltipBehaviorUndoneList("h", HelpCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("help", HelpCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("help me please DearJim", HelpCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfList_listTooltip() {
        assertTooltipBehaviorUndoneList("l", ListCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("list", ListCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("list done", ListCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfRedo_redoTooltip() {
        assertTooltipBehaviorUndoneList("r", RedoCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("redo", RedoCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("redo done", RedoCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfSelect_selectTooltip() {
        assertTooltipBehaviorUndoneList("select", SelectCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("select 1", SelectCommand.TOOL_TIP);
    }
    
    @Test
    public void tooltip_commandBeginningSubstringsOfStore_storeTooltip() {
        assertTooltipBehaviorUndoneList("store", StoreCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("store TodoList", StoreCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfUndo_undoTooltip() {
        assertTooltipBehaviorUndoneList("u", UndoCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("undo", UndoCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("undo done", UndoCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_ambiguousInput_multipleTooltips() {
        assertTooltipBehaviorUndoneList("d", String.join(NEWLINE, DeleteCommand.TOOL_TIP, DoneCommand.TOOL_TIP));
        assertTooltipBehaviorUndoneList("e", String.join(NEWLINE, EditCommand.TOOL_TIP, ExitCommand.TOOL_TIP));
        assertTooltipBehaviorUndoneList("s", String.join(NEWLINE, SelectCommand.TOOL_TIP, StoreCommand.TOOL_TIP));
    }

    /**
     * Sends the inputCommand to the Logic component to generate a tooltip that
     * will be compared against the expectedTooltip, assumes that the user is
     * currently viewing the undone list.
     * 
     * @param userInput the user input
     * @param expectedTooltip expected tool tip to be shown to user
     */
    private void assertTooltipBehaviorUndoneList(String userInput, String expectedToolTip) {
        String generatedToolTip = commandParser.parseForTooltip(userInput, false);
        assertEquals(expectedToolTip, generatedToolTip);
    }

    /**
     * Sends the inputCommand to the Logic component to generate a tooltip that
     * will be compared against the expectedTooltip, assumes that the user is
     * currently viewing the done list.
     * 
     * @param userInput the user input
     * @param expectedTooltip expected tool tip to be shown to user
     */
    private void assertToolTipBehaviorDoneList(String userInput, String expectedToolTip) {
        String generatedToolTip = commandParser.parseForTooltip(userInput, true);
        assertEquals(expectedToolTip, generatedToolTip);
    }

    /**
     * Helper method to build the add tooltip for testing purposes If a
     * parameter is passed null, that field will be assumed to be absent from
     * the tooltip.
     * 
     * @param name the String that will appear in the name field
     * @param priority the String that will appear in the priority field
     * @param recurrence the String that will appear in the recurrence field
     * @param startDate the String that will appear in the start date field
     * @param endDate the String that will appear in the end date field
     */
    private String buildAddTooltip(String name, String priority, String recurrence, String startDate, String endDate) {
        StringBuilder sb = new StringBuilder();
        sb.append(AddCommand.TOOL_TIP);
        sb.append("\n\tAdding task: ");
        sb.append("\n\tName:\t" + name);

        if (startDate != null) {
            sb.append("\n\tStart Date:\t" + startDate);
        }
        if (endDate != null) {
            sb.append("\n\tEnd Date:\t\t" + endDate);
        }
        if (recurrence != null) {
            sb.append("\n\tRecurrence Rate:\t" + recurrence);
        }
        sb.append("\n\tPriority:\t" + priority);

        return sb.toString();
    }

    /**
     * Helper method to build the edit tooltip for testing purposes.
     * 
     * @param index the String that will appear in the index field
     * @param name the String that will appear in the name field
     * @param priority the String that will appear in the priority field
     * @param recurrence the String that will appear in the recurrence field
     * @param startDate the String that will appear in the start date field
     * @param endDate the String that will appear in the end date field
     */
    private String buildEditTooltip(String index, String name, String priority, String recurrence, String startDate,
            String endDate) {
        StringBuilder sb = new StringBuilder();
        sb.append(EditCommand.TOOL_TIP);
        sb.append("\n\tEditing task at INDEX " + index + ": ");
        sb.append("\n\tName:\t" + name);
        sb.append("\n\tStart Date:\t" + startDate);
        sb.append("\n\tEnd Date:\t\t" + endDate);
        sb.append("\n\tRecurrence Rate:\t" + recurrence);
        sb.append("\n\tPriority:\t" + priority);

        return sb.toString();
    }
}
```
###### /java/seedu/address/model/item/TaskCompareTest.java
``` java
public class TaskCompareTest {

    // Tests that involve name and priority
    // Both no dates
    @Test
    public void taskCompareTo_bothNoDatesThisHigherPriority_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), null, null, null, Priority.HIGH);
        Task otherTask = new Task(new Name("a"), null, null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    @Test
    public void taskCompareTo_bothNoDatesThisLexiSmallerName_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), null, null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("b"), null, null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    // Both have start date only and equal
    @Test
    public void taskCompareTo_bothHaveStartDateOnlyAndSameButThisHigherPriority_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), new Date(2016, 1, 1), null, null, Priority.HIGH);
        Task otherTask = new Task(new Name("a"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_bothHaveStartDateOnlyAndSameLexiThisLexiSmallerName_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("b"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }      
    
    // Both have end date only and equal
    @Test
    public void taskCompareTo_bothHaveEndDateOnlyAndSameButThisHigherPriority_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), null, new Date(2016, 1, 1), null, Priority.HIGH);
        Task otherTask = new Task(new Name("a"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_bothHaveEndDateOnlyAndSameLexiThisLexiSmallerName_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("b"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    // Both have start and end date but equal
    @Test
    public void taskCompareTo_bothHaveAllDatesThisHigherPriority_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.HIGH);
        Task otherTask = new Task(new Name("a"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_bothHaveAllDatesThisLexiSmallerName_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("b"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    

    // Tests that involve dates only
    // This task has one date, other task has zero dates
    @Test
    public void taskCompareTo_thisHasStartDateOtherNoDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), null, null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    @Test
    public void taskCompareTo_thisHasEndDateOtherNoDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), null, null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    @Test
    public void taskCompareTo_thisbothDatesOtherNoDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 2), null,
                Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), null, null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    // This task has one date, other task has one date
    @Test
    public void taskCompareTo_thisHasEarlierStartDateOtherStartDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    @Test
    public void taskCompareTo_thisHasEarlierEndDateOtherEndDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), null, new Date(2016, 1, 2), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    @Test
    public void taskCompareTo_thisHasEarlierStartDateOtherEndDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), null, new Date(2016, 1, 2), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    // This task has one date, other has two dates
    @Test
    public void taskCompareTo_thisHasEarlierStartDateThanOtherTaskBothDates_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasEarlierStartDateThanOtherTaskEndButNotStartDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 2), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisAfterOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasLaterStartDateThanOtherTaskBothDates_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 4), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisAfterOther(thisTask.compareTo(otherTask));
    }
    
    // This task has only start date and equal to other both start and end date
    @Test
    public void taskCompareTo_thisStartDateEqualToOtherStartAndEndDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("a"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        System.out.println(thisTask.compareTo(otherTask));
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    // This task has only end date and equal to other both start and end date
    @Test
    public void taskCompareTo_thisEndDateEqualToOtherStartAndEndDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("a"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        assertThisAfterOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasEarlierEndDateThanOtherTaskBothDates_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasEarlierEndDateThanOtherTaskEndButNotStartDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), null, new Date(2016, 1, 2), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisAfterOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasLaterEndDateThanOtherTaskBothDates_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), null, new Date(2016, 1, 4), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisAfterOther(thisTask.compareTo(otherTask));
    }
    
    // Both tasks have start and end dates
    @Test
    public void taskCompareTo_thisHasEarlierStartDateThanOtherTask_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasSameStartDateButEarlierEndDateThanOtherTask_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 2), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    
    /**
     * Asserts that this task is before the other task being compared, assuming
     * that the compareNumber specified is the return value of this Task
     * compareTo the other Task.
     * 
     * @param compareNumber the return value for this.compareTo(other)
     */
    private void assertThisBeforeOther(int compareNumber) {
        assertTrue(compareNumber < 0);
    }

    /**
     * Asserts that this task is after the other task being compared, assuming
     * that the compareNumber specified is the return value of this Task
     * compareTo the other Task.
     * 
     * @param compareNumber the return value for this.compareTo(other)
     */
    private void assertThisAfterOther(int compareNumber) {
        assertTrue(compareNumber > 0);
    }
}
```
###### /java/seedu/address/testutil/StorageStub.java
``` java
/**
 * A Stub class for the Storage component
 *
 */
public class StorageStub extends ComponentManager implements Storage{

    @Override
    public Optional<ReadOnlyTaskManager> readTaskManager(String filePath) throws DataConversionException, IOException {
        return null;
    }

    @Override
    public void saveTaskManager(ReadOnlyTaskManager taskManager, String filePath) throws IOException { 
        return;
    }

    @Override
    public Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException {
        return null;
    }

    @Override
    public void saveUserPrefs(UserPrefs userPrefs) throws IOException {
        return;
    }

    @Override
    public String getTaskManagerFilePath() {
        return null;
    }

    @Override
    public void setTaskManagerFilePath(String filePath) {
        return;
    }

    @Override
    public Optional<ReadOnlyTaskManager> readTaskManager() throws DataConversionException, IOException {
        return null;
    }

    @Override
    public void saveTaskManager(ReadOnlyTaskManager taskManager) throws IOException {
        return;       
    }

    @Override
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent abce) {
        return;
    }

}
```
###### /java/seedu/address/testutil/UndoableCommandHistoryStub.java
``` java
public class UndoableCommandHistoryStub implements UndoableCommandHistory  {
    
    private boolean isEarliestCommand;
    private boolean isLatestCommand;
    
    public UndoableCommandHistoryStub() {
        isEarliestCommand = true;
        isLatestCommand = true;
    }

    @Override
    public void updateCommandHistory(UndoableCommand undoableCommand) {
        return;
    }

    @Override
    public boolean isEarliestCommand() {
        return isEarliestCommand;
    }

    @Override
    public boolean isLatestCommand() {
        return isLatestCommand;
    }
    

    @Override
    public UndoableCommand undoStep() {
        return null;
    }

    @Override
    public UndoableCommand redoStep() {
        return null;
    }
    
    public void setIsEarliestCommand(boolean isEarliestCommand) {
        this.isEarliestCommand = isEarliestCommand;
    }

    public void setIsLatestCommand(boolean isLatestCommand) {
        this.isLatestCommand = isLatestCommand;
    }

}
```
