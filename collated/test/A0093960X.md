# A0093960X
###### \java\guitests\ClearCommandGuiTest.java
``` java
public class ClearCommandGuiTest extends DearJimGuiTest {

    @Override
    protected TaskManager getInitialData() {
        TaskManager ab = TestUtil.generateEmptyTaskManager();
        TypicalTestTasks.loadTaskManagerUndoneListWithSampleData(ab);
        TypicalTestTasks.loadTaskManagerDoneListWithSampleDate(ab);
        return ab;
    }

    /**
     * Runs the clear command on the undone task list without any arguments.
     */
    @Test
    public void clearCommand_clearUndoneListNormalCommand_listCleared() {
        // verify a non-empty list can be cleared
        assertTrue(personListPanel.isListMatching(td.getTypicalUndoneTasks()));
        assertListSize(7);
        assertUndoneListClearCommandSuccess();

        // verify other commands can work after a clear command
        commandBox.runCommand(td.hoon.getAddCommand());
        assertTrue(personListPanel.isListMatching(td.hoon));
        commandBox.runCommand("delete 1");
        assertListSize(0);

        // verify clear command works when the list is empty
        assertUndoneListClearCommandSuccess();
    }

    /**
     * Runs the clear command on the done task list without any arguments.
     */
    @Test
    public void clearCommand_clearDoneListNormalCommand_listCleared() {

        // verify a non-empty list can be cleared
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(td.getTypicalDoneTasks()));
        assertListSize(7);
        assertDoneListClearCommandSuccess();

        // verify other commands can work after a clear command
        commandBox.runCommand("list");
        commandBox.runCommand("done 1");
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(td.alice));
        commandBox.runCommand("delete 1");
        assertListSize(0);

        // verify clear command works when the list is empty
        assertDoneListClearCommandSuccess();
    }

    /**
     * Runs the clear command on both undone task list and done task list with
     * arguments and asserts that list is cleared in both cases.
     */
    @Test
    public void clearCommand_clearAnyListWithArgs_listCleared() {

        commandBox.runCommand("clear    1fasfs#!@32312");
        assertListSize(0);
        assertResultMessage(ClearCommand.MESSAGE_SUCCESS_UNDONE_LIST);

        commandBox.runCommand("list done");
        commandBox.runCommand("clear    1asdf123@#213");
        assertListSize(0);
        assertResultMessage(ClearCommand.MESSAGE_SUCCESS_DONE_LIST);

    }

    private void assertUndoneListClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task Manager undone list has been cleared!");
    }

    private void assertDoneListClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task Manager done list has been cleared!");
    }
}
```
###### \java\guitests\DearJimGuiTest.java
``` java
    /**
     * Asserts the message shown in the Result Display area is same as the given string.
     * 
     * @param expected the expected result message in the result display area
     */
    protected void assertResultMessage(String expected) {
        assertEquals(expected, resultDisplay.getText());
    }
    
    /**
     * Asserts the command input displayed in the command box area is same as the given string.
     * 
     * @param expected the expected command input string
     */
    protected void assertCommandInput(String expected) {
        assertEquals(expected, commandBox.getCommandInput());
    }
}
```
###### \java\guitests\HelpWindowTest.java
``` java
public class HelpWindowTest extends DearJimGuiTest {
    
    @Rule
    public ExpectedException thrown = ExpectedException.none();
    
    @Test 
    public void helpCommand_helpCommandOnlyInUndoneList_helpWindowOpens() {
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommand());
    }
    
    @Test 
    public void helpCommand_helpCommandOnlyInDoneList_helpWindowOpens() {
        commandBox.runCommand("list done");
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommand());
    }
    
    @Test 
    public void helpCommand_helpCommandWithArgsInUndoneList_helpWindowOpens() {
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommandWithArgs("123123123123"));
    }
    
    @Test 
    public void helpCommand_helpCommandWithArgsInDoneList_helpWindowOpens() {
        commandBox.runCommand("list done");
        assertHelpWindowOpenAndCloseIt(commandBox.runHelpCommandWithArgs("123123123123"));
    }
    
    @Test
    public void helpCommand_buttonPressWhileFocusOnHelpWindow_helpWindowCloses() {
        HelpWindowHandle helpWindow = commandBox.runHelpCommand();
        assertHelpWindowOpen(helpWindow);
        helpWindow.pressEnter();
        assertHelpWindowClosed(helpWindow);
    }

    /**
     * Helper method to assert that the help window is open, and close the window after asserting it is.
     * @param helpWindowHandle The handle for the help window
     */
    private void assertHelpWindowOpenAndCloseIt(HelpWindowHandle helpWindowHandle) {
        assertTrue(helpWindowHandle.isWindowOpen());
        helpWindowHandle.closeWindow();
    }
    
    /**
     * Helper method to assert that the help window is open
     * @param helpWindowHandle The handle for the help window
     */
    private void assertHelpWindowOpen(HelpWindowHandle helpWindowHandle) {
        assertTrue(helpWindowHandle.isWindowOpen());
    }
    
    /**
     * Helper method to assert that the help window is closed
     * @param helpWindowHandle The handle for the help window
     */
    private void assertHelpWindowClosed(HelpWindowHandle helpWindowHandle) {
        thrown.expect(IllegalStateException.class);
        helpWindowHandle.isWindowOpen();
    }
   
}
```
###### \java\guitests\InputHistoryTest.java
``` java
public class InputHistoryTest extends DearJimGuiTest {
    
    @Test
    public void getPrevAndNextInput_singlePrevInput_ableToNavigatePrevAndNext() {
        commandBox.runCommand("list done");
        assertCommandInput("");
        assertGetPrevInputSuccess("list done");
        assertGetNextInputSuccess("");
    }

    @Test
    public void getPrevInput_prevInputWhileTypingHalfwayOnLatestInput_incompleteLatestInputSaved() {
        commandBox.runCommand("asdfasdfsdSDFSDFSDFSDFfind lol");
        commandBox.runCommand("fasdfsafsafas");
        commandBox.enterCommand("I hope this command is saved when I press up!!");
        assertGetPrevInputSuccess("fasdfsafsafas");
        assertGetPrevInputSuccess("asdfasdfsdSDFSDFSDFSDFfind lol");
        assertGetNextInputSuccess("fasdfsafsafas");
        assertGetNextInputSuccess("I hope this command is saved when I press up!!");
    }

    @Test
    public void getPrevInput_typingOverAPrevInput_savedPrevInputIsNotOverwritten() {
        commandBox.runCommand("list done");
        commandBox.runCommand("find lol");
        assertGetPrevInputSuccess("find lol");
        assertGetPrevInputSuccess("list done");
        commandBox.runCommand("This input will not overwrite the previous one that was here");
        assertCommandInput("");
        assertGetPrevInputSuccess("This input will not overwrite the previous one that was here");
        assertGetPrevInputSuccess("find lol");
        assertGetPrevInputSuccess("list done");
    }
    
    @Test
    public void getPrevAndNextInput_noPrevAndNextInput_noChange() {
        assertGetPrevInputSuccess("");
        assertGetNextInputSuccess("");
    }
      

    private void assertGetPrevInputSuccess(String expected) {
        commandBox.getPreviousInput();
        assertCommandInput(expected);
    }

    private void assertGetNextInputSuccess(String expected) {
        commandBox.getNextInput();
        assertCommandInput(expected);
    }

}
```
###### \java\guitests\UndoAndRedoCommandGuiTest.java
``` java
public class UndoAndRedoCommandGuiTest extends DearJimGuiTest {
    
    private TestTask[] originalUndoneList = td.getTypicalUndoneTasks();
    private TestTask[] originalDoneList = td.getTypicalDoneTasks();

    @Override
    protected TaskManager getInitialData() {
        TaskManager ab = TestUtil.generateEmptyTaskManager();
        TypicalTestTasks.loadTaskManagerUndoneListWithSampleData(ab);
        TypicalTestTasks.loadTaskManagerDoneListWithSampleDate(ab);
        return ab;
    }
    
    @Test
    public void undoCommand_noPreviousUndoableCommand_nothingToUndo() {
        commandBox.runCommand("list");
        assertUndoSuccess(td.getTypicalUndoneTasks());
    }
    
    @Test
    public void redoCommand_noUndoToRedo_nothingToRedo() {
        commandBox.runCommand("list");
        assertRedoSuccess(td.getTypicalUndoneTasks());
    }
    
    @Test
    public void undoAndRedoCommand_addTask_deleteForUndoReaddForRedo() {
        TestTask taskToAdd = td.hoon;
        assertAddSuccess(taskToAdd, originalUndoneList);
        
        // undo the add
        assertUndoSuccess(originalUndoneList);
        
        // redo the add
        TestTask[] withHoon = TestUtil.addTasksToList(originalUndoneList, taskToAdd);
        assertRedoSuccess(withHoon);
        
        // check if works on list done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(withHoon));
    }
    
    @Test
    public void undoAndRedoCommand_deleteUndoneTask_readdForUndoDeleteForRedo() {
        
        TestTask[] undoneListWithoutCarl = TestUtil.removeTaskFromList(originalUndoneList, 3);
        
        assertDeleteSuccess(3, originalUndoneList);
                
        // undo the delete
        assertUndoSuccess(originalUndoneList);
        
        // delete hoon again
        assertRedoSuccess(undoneListWithoutCarl);
        
        // check if works on list done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(undoneListWithoutCarl));
    }
    
    @Test
    public void undoAndRedoCommand_deleteDoneTask_readdForUndoDeleteForRedo() {
       
        TestTask[] doneListWithoutGeorge = TestUtil.removeTaskFromList(originalDoneList, 7);
               
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(originalDoneList));
        assertDeleteSuccess(7, originalDoneList);
        assertUndoSuccess(originalDoneList);
        assertRedoSuccess(doneListWithoutGeorge);
        
        // check if works on list undone view
        commandBox.runCommand("list");
        assertUndoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(originalDoneList));
        commandBox.runCommand("list");
        assertRedoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(doneListWithoutGeorge));
    }
    
    @Test
    public void undoAndRedoCommand_clearUndoneTasks_unclearForUndoReclearForRedo() {

        assertUndoneListClearCommandSuccess();
        assertUndoSuccess(originalUndoneList);
        assertRedoSuccess();
        
        // check if targets undone tasks even on done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching());
    }

    
    @Test
    public void undoAndRedoCommand_clearDoneTasks_unclearForUndoReclearForRedo() {
        
        commandBox.runCommand("list done");
        assertDoneListClearCommandSuccess();
        assertUndoSuccess(originalDoneList);
        assertRedoSuccess();

        // check if targets done task even on undone view
        commandBox.runCommand("list");
        assertUndoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(originalDoneList));
        commandBox.runCommand("list");
        assertRedoSuccess(originalUndoneList);
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching());
    }
    
    @Test
    public void undoAndRedoCommand_editTask_reverseEditForUndoReeditforRedo() {
        TestTask aliceEdit = new TestTask(td.alice);
        
        editTaskHelper(aliceEdit);
        
        TestTask[] newUndoneList = getNewUndoneListAfterEditFirstTask(aliceEdit);
                
        commandBox.runCommand("edit 1 Meet Alice at jUnit mall from 2pm to 3pm repeat every 3 days -high");
        assertTrue(personListPanel.isListMatching(newUndoneList));
        
        assertUndoSuccess(originalUndoneList);
        assertRedoSuccess(newUndoneList);
        
        // check if this works on the list done view
        commandBox.runCommand("list done");
        assertUndoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(originalUndoneList));
        commandBox.runCommand("list done");
        assertRedoSuccess(originalDoneList);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(newUndoneList));
        
    }
    
    @Test
    public void undoAndRedoCommand_doneTask_undoneForUndoDoneForRedo() {
        //Setup for done
        TestTask aliceEdit = new TestTask(td.alice);
        editTaskHelper(aliceEdit);
        TestTask aliceRecur = new TestTask(aliceEdit);
        editWithRecurHelper(aliceRecur);
        
        TestTask[] undoneListBeforeDone = getNewUndoneListAfterEditFirstTask(aliceEdit);
        TestTask[] undoneListAfterDone = getNewUndoneListAfterEditFirstTask(aliceRecur);

        
        commandBox.runCommand("list done");
        commandBox.runCommand("delete 1");
        commandBox.runCommand("list");
        
        commandBox.runCommand("edit 1 Meet Alice at jUnit mall from today 2pm to 3pm repeat every 3 days -high");
        assertTrue(personListPanel.isListMatching(undoneListBeforeDone));

        // Real done test
        commandBox.runCommand("done 1");
        assertTrue(personListPanel.isListMatching(undoneListAfterDone));
        assertUndoSuccess(undoneListBeforeDone);
        assertRedoSuccess(undoneListAfterDone);
        
        TestTask[] doneListBeforeDone = TestUtil.removeTaskFromList(originalDoneList, 1);
        
        TestTask[] doneListAfterDone = getNewDoneListAfterDoneFirstTask(aliceEdit);
        
        // check if it works on the done list too
        commandBox.runCommand("list done");
        assertTrue(personListPanel.isListMatching(doneListAfterDone));
        assertUndoSuccess(doneListBeforeDone);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(undoneListBeforeDone));
        commandBox.runCommand("list done");
        assertRedoSuccess(doneListAfterDone);
        commandBox.runCommand("list");
        assertTrue(personListPanel.isListMatching(undoneListAfterDone));

    }

   
    @Test
    public void undoAndRedoCommand_undoableCommandAfterUndo_resetUndo() {
        
        assertUndoneListClearCommandSuccess();
        assertUndoSuccess(originalUndoneList);
        assertAddSuccess(td.hoon, originalUndoneList);
        
        TestTask[] withHoon = TestUtil.addTasksToList(originalUndoneList, td.hoon);
        assertRedoSuccess(withHoon);
        
    }
    
    /**
     * Helper method to generate the new done list after edit (assuming the first task was edited)
     * 
     * @param editedTask The task that was edited
     * @return The new done list
     */
    private TestTask[] getNewDoneListAfterDoneFirstTask(TestTask editedTask) {
        TestTask[] doneListAfterDone = Arrays.copyOf(originalDoneList, originalDoneList.length);
        doneListAfterDone[0] = editedTask;
        return doneListAfterDone;
    }
 
    
    /**
     * Helper method to generate the new undone list after edit (assuming first task was edited)
     * @param editedTask The task that was edited
     * @return The new undone list
     */
    private TestTask[] getNewUndoneListAfterEditFirstTask(TestTask editedTask) {
        TestTask[] newUndoneList = Arrays.copyOf(originalUndoneList, originalUndoneList.length); 
        newUndoneList[0] = editedTask;
        return newUndoneList;
    }
    
    /**
     * Helper method to edit a test task to the desired edit.
     * 
     * @param aliceEdit The task to edit
     */
    private void editTaskHelper(TestTask aliceEdit) {
        try {
            aliceEdit.setName(new Name("Meet Alice at jUnit mall"));
            aliceEdit.setStartDate(DateTime.convertStringToDate("2pm"));
            aliceEdit.setEndDate(DateTime.convertStringToDate("3pm"));
            aliceEdit.setRecurrence(new RecurrenceRate("3", "days"));
            aliceEdit.setPriority(Priority.HIGH);
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
    }
    
    /**
     * Helper method to edit a test task to the desired edit, with a recurrence rate.
     * @param aliceRecur The task to edit
     */
    private void editWithRecurHelper(TestTask aliceRecur) {
        try {
            aliceRecur.setStartDate(DateTime.convertStringToDate("2pm 3 days later"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
        
        try {
            aliceRecur.setEndDate(DateTime.convertStringToDate("3pm 3 days later"));
        } catch (IllegalValueException e) {
            assert false : "The test data provided cannot be invalid";
        }
    }
    
    /**
     * Runs the undo command to undo the previous undoable command and confirms the result is correct.
     * 
     * @param expectedList A copy of the expected list after the undo command executes successfully.
     */
    private void assertUndoSuccess(TestTask... expectedList) {
        commandBox.runCommand("undo");
        assertTrue(personListPanel.isListMatching(expectedList));
    }
    
    /**
     * Runs the redo command to redo the previous undone command and confirms the result is correct.
     * 
     * @param expectedList A copy of the expected list after the redo command executes successfully.
     */
    private void assertRedoSuccess(TestTask... expectedList) {
        commandBox.runCommand("redo");
        assertTrue(personListPanel.isListMatching(expectedList));
    }
    
```
###### \java\seedu\address\commons\util\StringUtilTest.java
``` java
    @Test
    public void applyStringAtPosition_nullInput_assertionError() {
        thrown.expect(AssertionError.class);
        StringUtil.applyStringAtPosition(null, "valid string", 0);
    }
    
    @Test
    public void applyStringAtPosition_nullExtraString_assertionError() {
        thrown.expect(AssertionError.class);
        StringUtil.applyStringAtPosition("valid string", null, 0);
    }
    
    @Test
    public void applyStringAtPosition_ValidStringsLessThanZeroPosition_extraInFrontOfInput() {
        // boundary value -1
        assertEquals(StringUtil.applyStringAtPosition("input", "extrastring", -1), "extrastringinput");
    }
    
    @Test
    public void applyStringAtPosition_ValidStringsGreaterThanInputLengthPosition_extraBehindInput() {
        // boundary value 6 (input length 5)
        assertEquals(StringUtil.applyStringAtPosition("input", "extrastring", 6), "inputextrastring");
    }

    @Test
    public void applyStringAtPosition_ValidStringsValidPositionZero_extraStringInPosition() {
        // boundary value 0
        assertEquals(StringUtil.applyStringAtPosition("input", "extrastring", 0), "extrastringinput");
    }
    
    @Test
    public void applyStringAtPosition_ValidStringsValidPosition_extraStringInPosition() {
        // between boundaries
        assertEquals(StringUtil.applyStringAtPosition("input", "extrastring", 3), "inpextrastringut");
    }
    
    @Test
    public void applyStringAtPosition_ValidStringsValidPositionInputStringLength_extraStringInPosition() {
        // boundary value 5 (input length 5)
        assertEquals(StringUtil.applyStringAtPosition("input", "extrastring", 5), "inputextrastring");
    }

}
```
###### \java\seedu\address\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_clearInListUndone_clearsAllUndoneTaskOnly() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        List<Task> undoneTasks = helper.generateFloatingTaskListRange(4, 6);
        model.addTasks(undoneTasks);

        List<Task> doneTasks = helper.generateFloatingTaskList(3);
        model.addDoneTasks(doneTasks);

        TaskManager expectedAB = helper.generateTaskManagerUndoneAndDoneList(Collections.emptyList(),
                doneTasks);

        assertCommandBehaviorAndVerifyData("clear", ClearCommand.MESSAGE_SUCCESS_UNDONE_LIST, expectedAB,
                expectedAB.getUndoneTaskList(), expectedAB.getDoneTaskList());
    }

    @Test
    public void execute_clearInListDone_clearsAllDoneTaskOnly() throws Exception {
        model.setCurrentListToBeDoneList();

        TestDataHelper helper = new TestDataHelper();
        List<Task> doneTasks = helper.generateFloatingTaskListRange(4, 6);
        model.addDoneTasks(doneTasks);

        List<Task> undoneTasks = helper.generateFloatingTaskList(3);
        model.addTasks(undoneTasks);

        TaskManager expectedAB = helper.generateTaskManagerUndoneAndDoneList(undoneTasks,
                Collections.emptyList());
        assertCommandBehaviorAndVerifyData("clear", ClearCommand.MESSAGE_SUCCESS_DONE_LIST, expectedAB,
                expectedAB.getUndoneTaskList(), expectedAB.getDoneTaskList());
    }

    @Test
    public void execute_undoWithNoPreviousUndoableCommand_nothingToUndo() throws Exception {
        // Force clear history
        while (!history.isEarliestCommand()) {
            history.undoStep();
        }
        assertCommandBehaviorAndVerifyData("undo", UndoCommand.MESSAGE_FAILURE, new TaskManager(),
                Collections.emptyList(), Collections.emptyList());
        assertCommandBehaviorAndVerifyData("undo 23", UndoCommand.MESSAGE_FAILURE, new TaskManager(),
                Collections.emptyList(), Collections.emptyList());
    }

    @Test
    public void execute_redoWithNoPreviousUndo_nothingToRedo() throws Exception {
        assertCommandBehaviorAndVerifyData("redo", RedoCommand.MESSAGE_FAILURE, new TaskManager(),
                Collections.emptyList(), Collections.emptyList());
        assertCommandBehaviorAndVerifyData("redo 123", RedoCommand.MESSAGE_FAILURE, new TaskManager(),
                Collections.emptyList(), Collections.emptyList());
    }

    @Test
    public void execute_undoAndRedoSingleAddCommand_undoAndRedoAdd() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task toAdd = helper.generateFloatingTask(1);

        List<Task> taskList = helper.generateTaskList(toAdd);
        logic.execute(helper.generateAddCommand(toAdd));

        TaskManager expectedABAfterAdd = helper.generateTaskManagerUndoneAndDoneList(taskList,
                Collections.emptyList());

        assertCommandBehaviorAndVerifyData("undo", "Undid add item: " + toAdd.toString(), new TaskManager(),
                Collections.emptyList(), Collections.emptyList());
        assertCommandBehaviorAndVerifyData("redo", String.format(AddCommand.MESSAGE_SUCCESS, toAdd),
                expectedABAfterAdd, expectedABAfterAdd.getUndoneTaskList(),
                expectedABAfterAdd.getDoneTaskList());
    }
    
    @Test
    public void execute_undoAndRedoSingleClearCommand_undoAndRedoClear() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        List<Task> undoneTasks = helper.generateFloatingTaskListRange(4, 6);
        model.addTasks(undoneTasks);

        List<Task> doneTasks = helper.generateFloatingTaskList(3);
        model.addDoneTasks(doneTasks);

        TaskManager expectedABBeforeClear = helper.generateTaskManagerUndoneAndDoneList(undoneTasks,
                doneTasks);
        TaskManager expectedABAfterClear = helper.generateTaskManagerUndoneAndDoneList(Collections.emptyList(),
                doneTasks);
        
        logic.execute("clear");
        assertCommandBehaviorAndVerifyData("undo", ClearCommand.MESSAGE_UNDO_SUCCESS_UNDONE_LIST, expectedABBeforeClear,
                expectedABBeforeClear.getUndoneTaskList(), expectedABBeforeClear.getDoneTaskList());
        assertCommandBehaviorAndVerifyData("redo", ClearCommand.MESSAGE_SUCCESS_UNDONE_LIST,
                expectedABAfterClear, expectedABAfterClear.getUndoneTaskList(),
                expectedABAfterClear.getDoneTaskList());
    }
    
    @Test
    public void execute_undoAndRedoSingleEditCommand_undoAndRedoAdd() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task toEdit = helper.generateFloatingTask(1);
        Task beforeEdit = new Task(toEdit);

        List<Task> taskListBeforeEdit = helper.generateTaskList(beforeEdit);
        model.addTask(toEdit);
        logic.execute(helper.generateEditCommand());
        
        //assign parameters for expectations
        Name name = new Name("Do stuff later");
        Date startDate = DateTime.convertStringToDate("10am");
        Date endDate = DateTime.convertStringToDate("12pm");
        Priority priority = Priority.HIGH;
        RecurrenceRate recurrenceRate = new RecurrenceRate("1","day");
        
        List<Task> taskList = helper.generateTaskList(toEdit);
        TaskManager expectedABBeforeEdit = helper.generateTaskManagerUndoneAndDoneList(taskListBeforeEdit,
                Collections.emptyList());
        
        TaskManager expectedABAfterEdit = helper.generateTaskManagerUndoneAndDoneList(taskList,
                Collections.emptyList());
        expectedABAfterEdit.editFloatingTask(toEdit, name, startDate, endDate, priority, recurrenceRate);


        assertCommandBehaviorAndVerifyData("undo", String.format(EditCommand.MESSAGE_UNDO_SUCCESS, toEdit, beforeEdit), expectedABBeforeEdit,
                expectedABBeforeEdit.getUndoneTaskList(), expectedABBeforeEdit.getDoneTaskList());
        
        expectedABAfterEdit.editFloatingTask(toEdit, name, startDate, endDate, priority, recurrenceRate);
        assertCommandBehaviorAndVerifyData("redo", String.format(EditCommand.MESSAGE_SUCCESS, toEdit),
                expectedABAfterEdit, expectedABAfterEdit.getUndoneTaskList(),
                expectedABAfterEdit.getDoneTaskList());
    }
    
    @Test
    public void execute_undoAndRedoSingleDeleteCommand_undoAndRedoDelete() throws Exception {
        TestDataHelper helper = new TestDataHelper();

        List<Task> undoneTasks = helper.generateFloatingTaskList(1);
        model.addTasks(undoneTasks);

        TaskManager expectedABBeforeDelete = helper.generateTaskManagerUndoneAndDoneList(undoneTasks,
                Collections.emptyList());

        TaskManager expectedABAfterDelete = helper
                .generateTaskManagerUndoneAndDoneList(Collections.emptyList(), Collections.emptyList());

        logic.execute("delete 1");

        assertCommandBehaviorAndVerifyData("undo",
                String.format(DeleteCommand.MESSAGE_UNDO_SUCCESS, undoneTasks), expectedABBeforeDelete,
                expectedABBeforeDelete.getUndoneTaskList(), expectedABBeforeDelete.getDoneTaskList());
        
        assertCommandBehaviorAndVerifyData("redo",
                String.format(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS, ListUtil.generateDisplayString(undoneTasks)), expectedABAfterDelete,
                expectedABAfterDelete.getUndoneTaskList(), expectedABAfterDelete.getDoneTaskList());
    }
    
    @Test
    public void execute_undoAndRedoSingleDoneCommand_undoAndRedoDone() throws Exception {
        TestDataHelper helper = new TestDataHelper();

        List<Task> undoneTasks = helper.generateFloatingTaskList(1);
        model.addTasks(undoneTasks);

        TaskManager expectedABBeforeDone = helper.generateTaskManagerUndoneAndDoneList(undoneTasks,
                Collections.emptyList());

        TaskManager expectedABAfterDone = helper
                .generateTaskManagerUndoneAndDoneList(Collections.emptyList(), undoneTasks);

        logic.execute("done 1");

        assertCommandBehaviorAndVerifyData("undo",
                String.format(DoneCommand.MESSAGE_DONE_UNDO_SUCCESS, undoneTasks), expectedABBeforeDone,
                expectedABBeforeDone.getUndoneTaskList(), expectedABBeforeDone.getDoneTaskList());
        
        assertCommandBehaviorAndVerifyData("redo",
                String.format(DoneCommand.MESSAGE_DONE_TASK_SUCCESS, ListUtil.generateDisplayString(undoneTasks)), expectedABAfterDone,
                expectedABAfterDone.getUndoneTaskList(), expectedABAfterDone.getDoneTaskList());
    }

```
###### \java\seedu\address\logic\TooltipTest.java
``` java
public class TooltipTest {

    private static final String NEWLINE = "\n";
    private CommandParser commandParser;

    @Before
    public void setup() {
        commandParser = new CommandParser();
        EventsCenter.getInstance().registerHandler(this);
    }

    @After
    public void teardown() {
        EventsCenter.clearSubscribers();
    }

    @Test
    public void tooltip_undoneListInvalidCommandInput_incorrectCommandTooltip() {
        assertTooltipBehaviorUndoneList("   ", MESSAGE_TOOLTIP_INVALID_COMMAND_FORMAT);
    }

    @Test
    public void tooltip_doneListInvalidCommandInput_incorrectCommandTooltip() {
        assertToolTipBehaviorDoneList("   ", MESSAGE_TOOLTIP_INVALID_COMMAND_FORMAT);
    }

    @Test
    public void tooltip_doneListInvalidCommand_restrictedCommandTooltip() {
        assertToolTipBehaviorDoneList("add", MESSAGE_DONE_LIST_RESTRICTED_COMMANDS);
        assertToolTipBehaviorDoneList("edit", MESSAGE_DONE_LIST_RESTRICTED_COMMANDS);
        assertToolTipBehaviorDoneList("done", MESSAGE_DONE_LIST_RESTRICTED_COMMANDS);
    }

    @Test
    public void tooltip_undoneListCommandBeginningSubstringsOfAdd_addTooltip() {
        assertTooltipBehaviorUndoneList("a", AddCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("add", AddCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("    add", AddCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_undoneListDetailedAddInput_detailedAddTooltip() {
        assertTooltipBehaviorUndoneList("add Meet Hoon Meier from 2pm to 3pm repeat every month",
                buildAddTooltip("Meet Hoon Meier", "medium", "every month", "2pm", "3pm"));
        assertTooltipBehaviorUndoneList("meet akshay from today to tomorrow repeat every 3 days -high",
                buildAddTooltip("meet akshay", "high", "every 3 days", "today", "tomorrow"));
        assertTooltipBehaviorUndoneList("\"edit my essay by today\" by today -high",
                buildAddTooltip("edit my essay by today", "high", null, null, "today"));
    }

    @Test
    public void tooltip_undoneListCommandBeginningSubstringsOfEdit_editTooltip() {
        assertTooltipBehaviorUndoneList("edit", EditCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_detailedEditInput_detailedEditTooltip() {
        assertTooltipBehaviorUndoneList("edit 3 Call the school to ask something from 9am to 10am repeat every day -low",
                buildEditTooltip("3", "Call the school to ask something", "low", "every day", "9am", "10am"));
        assertTooltipBehaviorUndoneList("edit 100 repeat every 2 days -high -reset start",
                buildEditTooltip("100", "No Change", "high", "every 2 days", "RESET", "No Change"));
        assertTooltipBehaviorUndoneList("edit 342 from 1am -reset start end priority",
                buildEditTooltip("342", "No Change", "RESET", "No Change", "RESET", "RESET"));
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfClear_clearTooltip() {
        assertTooltipBehaviorUndoneList("c", ClearCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("clear", ClearCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("clear a", ClearCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfDelete_deleteTooltip() {
        assertTooltipBehaviorUndoneList("delete", DeleteCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("delete 100", DeleteCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfDone_doneTooltip() {
        assertTooltipBehaviorUndoneList("done", DoneCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("done 100", DoneCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfExit_exitTooltip() {
        assertTooltipBehaviorUndoneList("exit", ExitCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("exit 0", ExitCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfFind_findTooltip() {
        assertTooltipBehaviorUndoneList("f", FindCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("find", FindCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("find looking for my favourite task!", FindCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfHelp_helpTooltip() {
        assertTooltipBehaviorUndoneList("h", HelpCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("help", HelpCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("help me please DearJim", HelpCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfList_listTooltip() {
        assertTooltipBehaviorUndoneList("l", ListCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("list", ListCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("list done", ListCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfRedo_redoTooltip() {
        assertTooltipBehaviorUndoneList("r", RedoCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("redo", RedoCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("redo done", RedoCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfSelect_selectTooltip() {
        assertTooltipBehaviorUndoneList("select", SelectCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("select 1", SelectCommand.TOOL_TIP);
    }
    
    @Test
    public void tooltip_commandBeginningSubstringsOfStore_storeTooltip() {
        assertTooltipBehaviorUndoneList("store", StoreCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("store TodoList", StoreCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_commandBeginningSubstringsOfUndo_undoTooltip() {
        assertTooltipBehaviorUndoneList("u", UndoCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("undo", UndoCommand.TOOL_TIP);
        assertTooltipBehaviorUndoneList("undo done", UndoCommand.TOOL_TIP);
    }

    @Test
    public void tooltip_ambiguousInput_multipleTooltips() {
        assertTooltipBehaviorUndoneList("d", String.join(NEWLINE, DeleteCommand.TOOL_TIP, DoneCommand.TOOL_TIP));
        assertTooltipBehaviorUndoneList("e", String.join(NEWLINE, EditCommand.TOOL_TIP, ExitCommand.TOOL_TIP));
        assertTooltipBehaviorUndoneList("s", String.join(NEWLINE, SelectCommand.TOOL_TIP, StoreCommand.TOOL_TIP));
    }

    /**
     * Sends the inputCommand to the Logic component to generate a tooltip that
     * will be compared against the expectedTooltip, assumes that the user is
     * currently viewing the undone list.
     * 
     * @param userInput The user input
     * @param expectedTooltip Expected tool tip to be shown to user
     */
    private void assertTooltipBehaviorUndoneList(String userInput, String expectedToolTip) {
        String generatedToolTip = commandParser.parseForTooltip(userInput, false);
        assertEquals(expectedToolTip, generatedToolTip);
    }

    /**
     * Sends the inputCommand to the Logic component to generate a tooltip that
     * will be compared against the expectedTooltip, assumes that the user is
     * currently viewing the done list.
     * 
     * @param userInput The user input
     * @param expectedTooltip Expected tool tip to be shown to user
     */
    private void assertToolTipBehaviorDoneList(String userInput, String expectedToolTip) {
        String generatedToolTip = commandParser.parseForTooltip(userInput, true);
        assertEquals(expectedToolTip, generatedToolTip);
    }

    /**
     * Helper method to build the add tooltip for testing purposes If a
     * parameter is passed null, that field will be assumed to be absent from
     * the tooltip.
     * 
     * @param name The String that will appear in the name field
     * @param priority The String that will appear in the priority field
     * @param recurrence The String that will appear in the recurrence field
     * @param startDate The String that will appear in the start date field
     * @param endDate The String that will appear in the end date field
     */
    private String buildAddTooltip(String name, String priority, String recurrence, String startDate, String endDate) {
        StringBuilder sb = new StringBuilder();
        sb.append(AddCommand.TOOL_TIP);
        sb.append("\n\tAdding task: ");
        sb.append("\n\tName:\t" + name);

        if (startDate != null) {
            sb.append("\n\tStart Date:\t" + startDate);
        }
        if (endDate != null) {
            sb.append("\n\tEnd Date:\t\t" + endDate);
        }
        if (recurrence != null) {
            sb.append("\n\tRecurrence Rate:\t" + recurrence);
        }
        sb.append("\n\tPriority:\t" + priority);

        return sb.toString();
    }

    /**
     * Helper method to build the edit tooltip for testing purposes.
     * 
     * @param index The String that will appear in the index field
     * @param name The String that will appear in the name field
     * @param priority The String that will appear in the priority field
     * @param recurrence The String that will appear in the recurrence field
     * @param startDate The String that will appear in the start date field
     * @param endDate The String that will appear in the end date field
     */
    private String buildEditTooltip(String index, String name, String priority, String recurrence, String startDate,
            String endDate) {
        StringBuilder sb = new StringBuilder();
        sb.append(EditCommand.TOOL_TIP);
        sb.append("\n\tEditing task at INDEX " + index + ": ");
        sb.append("\n\tName:\t" + name);
        sb.append("\n\tStart Date:\t" + startDate);
        sb.append("\n\tEnd Date:\t\t" + endDate);
        sb.append("\n\tRecurrence Rate:\t" + recurrence);
        sb.append("\n\tPriority:\t" + priority);

        return sb.toString();
    }
}
```
###### \java\seedu\address\model\item\TaskCompareTest.java
``` java
public class TaskCompareTest {

    // Tests that involve name and priority
    // Both no dates
    @Test
    public void taskCompareTo_bothNoDatesThisHigherPriority_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), null, null, null, Priority.HIGH);
        Task otherTask = new Task(new Name("a"), null, null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    @Test
    public void taskCompareTo_bothNoDatesThisLexiSmallerName_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), null, null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("b"), null, null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    // Both have start date only and equal
    @Test
    public void taskCompareTo_bothHaveStartDateOnlyAndSameButThisHigherPriority_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), new Date(2016, 1, 1), null, null, Priority.HIGH);
        Task otherTask = new Task(new Name("a"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_bothHaveStartDateOnlyAndSameLexiThisLexiSmallerName_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("b"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }      
    
    // Both have end date only and equal
    @Test
    public void taskCompareTo_bothHaveEndDateOnlyAndSameButThisHigherPriority_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), null, new Date(2016, 1, 1), null, Priority.HIGH);
        Task otherTask = new Task(new Name("a"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_bothHaveEndDateOnlyAndSameLexiThisLexiSmallerName_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("b"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    // Both have start and end date but equal
    @Test
    public void taskCompareTo_bothHaveAllDatesThisHigherPriority_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.HIGH);
        Task otherTask = new Task(new Name("a"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_bothHaveAllDatesThisLexiSmallerName_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("b"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    

    // Tests that involve dates only
    // This task has one date, other task has zero dates
    @Test
    public void taskCompareTo_thisHasStartDateOtherNoDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), null, null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    @Test
    public void taskCompareTo_thisHasEndDateOtherNoDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), null, null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    @Test
    public void taskCompareTo_thisbothDatesOtherNoDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 2), null,
                Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), null, null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    // This task has one date, other task has one date
    @Test
    public void taskCompareTo_thisHasEarlierStartDateOtherStartDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), null, null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    @Test
    public void taskCompareTo_thisHasEarlierEndDateOtherEndDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), null, new Date(2016, 1, 2), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }

    @Test
    public void taskCompareTo_thisHasEarlierStartDateOtherEndDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), null, new Date(2016, 1, 2), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    // This task has one date, other has two dates
    @Test
    public void taskCompareTo_thisHasEarlierStartDateThanOtherTaskBothDates_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasEarlierStartDateThanOtherTaskEndButNotStartDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 2), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisAfterOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasLaterStartDateThanOtherTaskBothDates_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 4), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisAfterOther(thisTask.compareTo(otherTask));
    }
    
    // This task has only start date and equal to other both start and end date
    @Test
    public void taskCompareTo_thisStartDateEqualToOtherStartAndEndDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), new Date(2016, 1, 1), null, null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("a"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        System.out.println(thisTask.compareTo(otherTask));
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    // This task has only end date and equal to other both start and end date
    @Test
    public void taskCompareTo_thisEndDateEqualToOtherStartAndEndDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("a"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("a"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        assertThisAfterOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasEarlierEndDateThanOtherTaskBothDates_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), null, new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasEarlierEndDateThanOtherTaskEndButNotStartDate_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), null, new Date(2016, 1, 2), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisAfterOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasLaterEndDateThanOtherTaskBothDates_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), null, new Date(2016, 1, 4), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisAfterOther(thisTask.compareTo(otherTask));
    }
    
    // Both tasks have start and end dates
    @Test
    public void taskCompareTo_thisHasEarlierStartDateThanOtherTask_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 1), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 2), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    @Test
    public void taskCompareTo_thisHasSameStartDateButEarlierEndDateThanOtherTask_thisBeforeOther() {
        Task thisTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 2), null, Priority.MEDIUM);
        Task otherTask = new Task(new Name("same name"), new Date(2016, 1, 1), new Date(2016, 1, 3), null, Priority.MEDIUM);
        assertThisBeforeOther(thisTask.compareTo(otherTask));
    }
    
    
    /**
     * Asserts that this task is before the other task being compared, assuming
     * that the compareNumber specified is the return value of this Task
     * compareTo the other Task.
     * 
     * @param compareNumber the return value for this.compareTo(other)
     */
    private void assertThisBeforeOther(int compareNumber) {
        assertTrue(compareNumber < 0);
    }

    /**
     * Asserts that this task is after the other task being compared, assuming
     * that the compareNumber specified is the return value of this Task
     * compareTo the other Task.
     * 
     * @param compareNumber the return value for this.compareTo(other)
     */
    private void assertThisAfterOther(int compareNumber) {
        assertTrue(compareNumber > 0);
    }
}
```
###### \java\seedu\address\testutil\StorageStub.java
``` java
/**
 * A Stub class for the Storage component
 *
 */
public class StorageStub extends ComponentManager implements Storage{

    @Override
    public Optional<ReadOnlyTaskManager> readTaskManager(String filePath) throws DataConversionException, IOException {
        return null;
    }

    @Override
    public void saveTaskManager(ReadOnlyTaskManager taskManager, String filePath) throws IOException { 
        return;
    }

    @Override
    public Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException {
        return null;
    }

    @Override
    public void saveUserPrefs(UserPrefs userPrefs) throws IOException {
        return;
    }

    @Override
    public String getTaskManagerFilePath() {
        return null;
    }

    @Override
    public void setTaskManagerFilePath(String filePath) {
        return;
    }

    @Override
    public Optional<ReadOnlyTaskManager> readTaskManager() throws DataConversionException, IOException {
        return null;
    }

    @Override
    public void saveTaskManager(ReadOnlyTaskManager taskManager) throws IOException {
        return;       
    }

    @Override
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent abce) {
        return;
    }

}
```
